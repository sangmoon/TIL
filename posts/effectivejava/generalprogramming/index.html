<!doctype html><html lang=en-us>
<head>
<meta charset=utf-8>
<meta http-equiv=x-ua-compatible content="IE=edge,chrome=1">
<title>Sangmoon's TIL</title>
<meta name=viewport content="width=device-width,minimum-scale=1">
<meta name=description content="일반적인 프로그래밍 원칙들 규칙 53 리플렉션 대신 인터페이스를 이용하라 java.lang.reflect 를 활용하면 클래스 정보를 런타임에 가져 올 수 있다.
 Class 객체를 통해 생성자(Constructor), 메서드(Method), 필드(Field) 객체를 가져올 수 있다 멤버 이름, 필드 자료형, 메서드 시그니처 들을 알 수 있다. 객체를 생성할 수도 있고, 메서드를 호출할 수도 있으며 필드에 접근할 수도 있다.  단점도 많다.
 컴파일 시점에서 자료형 검사함으로써 얻는 이점을 모두 포기해야 한다 (존재하지 않는, 접근 할 수 없는 method 호출하면 런타임 오류 발생) 리플렉션 코드는 보기 싫고 장황하다.">
<meta name=generator content="Hugo 0.88.1">
<meta name=ROBOTS content="NOINDEX, NOFOLLOW">
<link rel=stylesheet href=/TIL/ananke/css/main.min.css>
<meta property="og:title" content>
<meta property="og:description" content="일반적인 프로그래밍 원칙들 규칙 53 리플렉션 대신 인터페이스를 이용하라 java.lang.reflect 를 활용하면 클래스 정보를 런타임에 가져 올 수 있다.
 Class 객체를 통해 생성자(Constructor), 메서드(Method), 필드(Field) 객체를 가져올 수 있다 멤버 이름, 필드 자료형, 메서드 시그니처 들을 알 수 있다. 객체를 생성할 수도 있고, 메서드를 호출할 수도 있으며 필드에 접근할 수도 있다.  단점도 많다.
 컴파일 시점에서 자료형 검사함으로써 얻는 이점을 모두 포기해야 한다 (존재하지 않는, 접근 할 수 없는 method 호출하면 런타임 오류 발생) 리플렉션 코드는 보기 싫고 장황하다.">
<meta property="og:type" content="article">
<meta property="og:url" content="https://sangmoon.github.io/TIL/posts/effectivejava/generalprogramming/"><meta property="article:section" content="posts">
<meta itemprop=name content>
<meta itemprop=description content="일반적인 프로그래밍 원칙들 규칙 53 리플렉션 대신 인터페이스를 이용하라 java.lang.reflect 를 활용하면 클래스 정보를 런타임에 가져 올 수 있다.
 Class 객체를 통해 생성자(Constructor), 메서드(Method), 필드(Field) 객체를 가져올 수 있다 멤버 이름, 필드 자료형, 메서드 시그니처 들을 알 수 있다. 객체를 생성할 수도 있고, 메서드를 호출할 수도 있으며 필드에 접근할 수도 있다.  단점도 많다.
 컴파일 시점에서 자료형 검사함으로써 얻는 이점을 모두 포기해야 한다 (존재하지 않는, 접근 할 수 없는 method 호출하면 런타임 오류 발생) 리플렉션 코드는 보기 싫고 장황하다.">
<meta itemprop=wordCount content="1186">
<meta itemprop=keywords content><meta name=twitter:card content="summary">
<meta name=twitter:title content>
<meta name=twitter:description content="일반적인 프로그래밍 원칙들 규칙 53 리플렉션 대신 인터페이스를 이용하라 java.lang.reflect 를 활용하면 클래스 정보를 런타임에 가져 올 수 있다.
 Class 객체를 통해 생성자(Constructor), 메서드(Method), 필드(Field) 객체를 가져올 수 있다 멤버 이름, 필드 자료형, 메서드 시그니처 들을 알 수 있다. 객체를 생성할 수도 있고, 메서드를 호출할 수도 있으며 필드에 접근할 수도 있다.  단점도 많다.
 컴파일 시점에서 자료형 검사함으로써 얻는 이점을 모두 포기해야 한다 (존재하지 않는, 접근 할 수 없는 method 호출하면 런타임 오류 발생) 리플렉션 코드는 보기 싫고 장황하다.">
</head>
<body class="ma0 avenir bg-near-white">
<header>
<div class=bg-black>
<nav class="pv3 ph3 ph4-ns" role=navigation>
<div class="flex-l justify-between items-center center">
<a href=/TIL/ class="f3 fw2 hover-white no-underline white-90 dib">
Sangmoon's TIL
</a>
<div class="flex-l items-center">
</div>
</div>
</nav>
</div>
</header>
<main class=pb7 role=main>
<article class="flex-l flex-wrap justify-between mw8 center ph3">
<header class="mt4 w-100">
<aside class="instapaper_ignoref b helvetica tracked">
POSTS
</aside>
<div id=sharing class=mt3>
<a href="https://www.facebook.com/sharer.php?u=https://sangmoon.github.io/TIL/posts/effectivejava/generalprogramming/" class="facebook no-underline" aria-label="share on Facebook"><svg height="32" style="enable-background:new 0 0 67 67" viewBox="0 0 67 67" width="32" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><path d="M28.765 50.32h6.744V33.998h4.499l.596-5.624h-5.095l.007-2.816c0-1.466.14-2.253 2.244-2.253h2.812V17.68h-4.5c-5.405.0-7.307 2.729-7.307 7.317v3.377h-3.369v5.625h3.369V50.32zM33 64C16.432 64 3 50.569 3 34S16.432 4 33 4s30 13.431 30 30S49.568 64 33 64z" style="fill-rule:evenodd;clip-rule:evenodd"/></svg>
</a>
<a href="https://twitter.com/share?url=https://sangmoon.github.io/TIL/posts/effectivejava/generalprogramming/&text=" class="twitter no-underline" aria-label="share on Twitter"><svg height="32" style="enable-background:new 0 0 67 67" viewBox="0 0 67 67" width="32" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><path d="M37.167 22.283c-2.619.953-4.274 3.411-4.086 6.101l.063 1.038-1.048-.127c-3.813-.487-7.145-2.139-9.974-4.915l-1.383-1.377-.356 1.017c-.754 2.267-.272 4.661 1.299 6.271.838.89.649 1.017-.796.487-.503-.169-.943-.296-.985-.233-.146.149.356 2.076.754 2.839.545 1.06 1.655 2.097 2.871 2.712l1.027.487-1.215.021c-1.173.0-1.215.021-1.089.467.419 1.377 2.074 2.839 3.918 3.475l1.299.444-1.131.678c-1.676.976-3.646 1.526-5.616 1.568C19.775 43.256 19 43.341 19 43.405c0 .211 2.557 1.397 4.044 1.864 4.463 1.377 9.765.783 13.746-1.568 2.829-1.673 5.657-5 6.978-8.221.713-1.716 1.425-4.851 1.425-6.354.0-.975.063-1.102 1.236-2.267.692-.678 1.341-1.419 1.467-1.631.21-.403.188-.403-.88-.043-1.781.636-2.033.551-1.152-.402.649-.678 1.425-1.907 1.425-2.267.0-.063-.314.042-.671.233-.377.212-1.215.53-1.844.72l-1.131.361-1.027-.7c-.566-.381-1.361-.805-1.781-.932C39.766 21.902 38.131 21.944 37.167 22.283zM33 64C16.432 64 3 50.569 3 34S16.432 4 33 4s30 13.431 30 30S49.568 64 33 64z" style="fill-rule:evenodd;clip-rule:evenodd;fill:"/></svg>
</a>
<a href="https://www.linkedin.com/shareArticle?mini=true&url=https://sangmoon.github.io/TIL/posts/effectivejava/generalprogramming/&title=" class="linkedin no-underline" aria-label="share on LinkedIn"><svg height="32" style="enable-background:new 0 0 65 65" viewBox="0 0 65 65" width="32" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><path d="M50.837 48.137V36.425c0-6.275-3.35-9.195-7.816-9.195-3.604.0-5.219 1.983-6.119 3.374V27.71h-6.79c.09 1.917.0 20.427.0 20.427h6.79V36.729c0-.609.044-1.219.224-1.655.49-1.22 1.607-2.483 3.482-2.483 2.458.0 3.44 1.873 3.44 4.618v10.929H50.837zM22.959 24.922c2.367.0 3.842-1.57 3.842-3.531-.044-2.003-1.475-3.528-3.797-3.528s-3.841 1.524-3.841 3.528c0 1.961 1.474 3.531 3.753 3.531H22.959zM34 64C17.432 64 4 50.568 4 34 4 17.431 17.432 4 34 4s30 13.431 30 30c0 16.568-13.432 30-30 30zM26.354 48.137V27.71h-6.789v20.427h6.789z" style="fill-rule:evenodd;clip-rule:evenodd;fill:"/></svg>
</a>
</div>
<h1 class="f1 athelas mt3 mb1"></h1>
</header>
<div class="nested-copy-line-height lh-copy serif f4 nested-links nested-img mid-gray pr4-l w-two-thirds-l"><h1 id=일반적인-프로그래밍-원칙들>일반적인 프로그래밍 원칙들</h1>
<h2 id=규칙-53-리플렉션-대신-인터페이스를-이용하라>규칙 53 리플렉션 대신 인터페이스를 이용하라</h2>
<p>java.lang.reflect 를 활용하면 클래스 정보를 런타임에 가져 올 수 있다.</p>
<ul>
<li>Class 객체를 통해 생성자(Constructor), 메서드(Method), 필드(Field) 객체를 가져올 수 있다</li>
<li>멤버 이름, 필드 자료형, 메서드 시그니처 들을 알 수 있다.</li>
<li>객체를 생성할 수도 있고, 메서드를 호출할 수도 있으며 필드에 접근할 수도 있다.</li>
</ul>
<p>단점도 많다.</p>
<ul>
<li>컴파일 시점에서 자료형 검사함으로써 얻는 이점을 모두 포기해야 한다 (존재하지 않는, 접근 할 수 없는 method 호출하면 런타임 오류 발생)</li>
<li>리플렉션 코드는 보기 싫고 장황하다. 가독성 떨어진다</li>
<li>성능이 낮다 (저자 컴퓨터에서는 2 ~ 50 배 가량 느렸다)</li>
</ul>
<h3 id=일반적인-프로그램은-프로그램-실행-중-리플렉션을-통해-객체를-이용하려-하면-안-된다>일반적인 프로그램은 프로그램 실행 중 리플렉션을 통해 객체를 이용하려 하면 안 된다</h3>
<p>리플렉션이 필요한 복잡한 프로그램 예시 (여기에 포함 안 되면 리플렉션 사용 ㄴㄴ)</p>
<ul>
<li>클래스 브라우저</li>
<li>객체 검사도구</li>
<li>코드 분석 도구</li>
<li>해석적 내장형 시스템(interpretive embedded system) ???</li>
<li>스텁 컴파일러가 없는 원격 프로시저 호출(???)</li>
</ul>
<h3 id=리플렉션을-아주-제한적으로-사용하면-오버헤드는-피하면서-리플렉션의-장점을-누릴-수-있다>리플렉션을 아주 제한적으로 사용하면 오버헤드는 피하면서 리플렉션의 장점을 누릴 수 있다.</h3>
<ul>
<li>객체 생성은 리플렉션으로, 참조는 인터페이스나 상위 클래스로</li>
</ul>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#75715e>// command line으로 받은 첫번째 인자의 클래스를 이용해 Set&lt;String&gt; 을 만드는 프로그램. 나머지 인자는 해당 Set에 집어 넣음
</span><span style=color:#75715e>// 생성은 리플렉션, 참조와 사용은 인터페이스
</span><span style=color:#75715e></span>
<span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>main</span><span style=color:#f92672>(</span>String<span style=color:#f92672>[]</span> args<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
    Class<span style=color:#f92672>&lt;?</span> <span style=color:#66d9ef>extends</span> Set<span style=color:#f92672>&lt;</span>String<span style=color:#f92672>&gt;&gt;</span> cl <span style=color:#f92672>=</span> <span style=color:#66d9ef>null</span><span style=color:#f92672>;</span>
    <span style=color:#66d9ef>try</span> <span style=color:#f92672>{</span>
        cl <span style=color:#f92672>=</span> <span style=color:#f92672>(</span>Class<span style=color:#f92672>&lt;?</span> <span style=color:#66d9ef>extends</span> Set<span style=color:#f92672>&lt;</span>String<span style=color:#f92672>&gt;&gt;)</span> Class<span style=color:#f92672>.</span><span style=color:#a6e22e>forName</span><span style=color:#f92672>(</span>args<span style=color:#f92672>[</span>0<span style=color:#f92672>]);</span> <span style=color:#75715e>// unchecked cast
</span><span style=color:#75715e></span>    <span style=color:#f92672>}</span> <span style=color:#66d9ef>catch</span> <span style=color:#f92672>(</span>ClassNotFoundException e<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
        System<span style=color:#f92672>.</span><span style=color:#a6e22e>err</span><span style=color:#f92672>.</span><span style=color:#a6e22e>println</span><span style=color:#f92672>(</span><span style=color:#e6db74>&#34;Class not found.&#34;</span><span style=color:#f92672>);</span>
        System<span style=color:#f92672>.</span><span style=color:#a6e22e>exit</span><span style=color:#f92672>(</span>1<span style=color:#f92672>);</span>
    <span style=color:#f92672>}</span>

    <span style=color:#75715e>// get constructor
</span><span style=color:#75715e></span>    Constructor<span style=color:#f92672>&lt;?</span> <span style=color:#66d9ef>extends</span> Set<span style=color:#f92672>&lt;</span>String<span style=color:#f92672>&gt;&gt;</span> cons <span style=color:#f92672>=</span> <span style=color:#66d9ef>null</span><span style=color:#f92672>;</span>
    <span style=color:#66d9ef>try</span> <span style=color:#f92672>{</span>
        cons <span style=color:#f92672>=</span> cl<span style=color:#f92672>.</span><span style=color:#a6e22e>getDeclaredConstructor</span><span style=color:#f92672>();</span>
    <span style=color:#f92672>}</span> <span style=color:#66d9ef>catch</span> <span style=color:#f92672>(</span>NoSuchMethodException e<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
        System<span style=color:#f92672>.</span><span style=color:#a6e22e>err</span><span style=color:#f92672>.</span><span style=color:#a6e22e>println</span><span style=color:#f92672>(</span><span style=color:#e6db74>&#34;No parameterless constructor.&#34;</span><span style=color:#f92672>);</span>
        System<span style=color:#f92672>.</span><span style=color:#a6e22e>exit</span><span style=color:#f92672>(</span>1<span style=color:#f92672>);</span>
    <span style=color:#f92672>}</span>

    <span style=color:#75715e>// Instantiate the set
</span><span style=color:#75715e></span>    Set<span style=color:#f92672>&lt;</span>String<span style=color:#f92672>&gt;</span> s <span style=color:#f92672>=</span> <span style=color:#66d9ef>null</span><span style=color:#f92672>;</span>  <span style=color:#75715e>// Set으로 참조
</span><span style=color:#75715e></span>
    <span style=color:#66d9ef>try</span> <span style=color:#f92672>{</span>
        <span style=color:#75715e>// cl.newInstance() 를 안쓰고 굳이 생성자 호출하는 이유는?
</span><span style=color:#75715e></span>        s <span style=color:#f92672>=</span> cons<span style=color:#f92672>.</span><span style=color:#a6e22e>newInstance</span><span style=color:#f92672>();</span>
    <span style=color:#f92672>}</span> <span style=color:#66d9ef>catch</span> <span style=color:#f92672>(</span>IllegalAccessException e<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
        System<span style=color:#f92672>.</span><span style=color:#a6e22e>err</span><span style=color:#f92672>.</span><span style=color:#a6e22e>println</span><span style=color:#f92672>(</span><span style=color:#e6db74>&#34;Class not accessible.&#34;</span><span style=color:#f92672>);</span>
        System<span style=color:#f92672>.</span><span style=color:#a6e22e>exit</span><span style=color:#f92672>(</span>1<span style=color:#f92672>);</span>
    <span style=color:#f92672>}</span> <span style=color:#66d9ef>catch</span> <span style=color:#f92672>(</span>InstantiationException e<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
        System<span style=color:#f92672>.</span><span style=color:#a6e22e>err</span><span style=color:#f92672>.</span><span style=color:#a6e22e>println</span><span style=color:#f92672>(</span><span style=color:#e6db74>&#34;Class not instantiable&#34;</span><span style=color:#f92672>);</span>
        System<span style=color:#f92672>.</span><span style=color:#a6e22e>exit</span><span style=color:#f92672>(</span>1<span style=color:#f92672>);</span>
    <span style=color:#f92672>}</span> <span style=color:#66d9ef>catch</span> <span style=color:#f92672>(</span>InvocationTargetException e<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
        System<span style=color:#f92672>.</span><span style=color:#a6e22e>err</span><span style=color:#f92672>.</span><span style=color:#a6e22e>println</span><span style=color:#f92672>(</span><span style=color:#e6db74>&#34;Constructor threw &#34;</span> <span style=color:#f92672>+</span> e<span style=color:#f92672>.</span><span style=color:#a6e22e>getCause</span><span style=color:#f92672>());</span>
        System<span style=color:#f92672>.</span><span style=color:#a6e22e>exit</span><span style=color:#f92672>(</span>1<span style=color:#f92672>);</span>
    <span style=color:#f92672>}</span> <span style=color:#66d9ef>catch</span> <span style=color:#f92672>(</span>ClassCastException e<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
        System<span style=color:#f92672>.</span><span style=color:#a6e22e>err</span><span style=color:#f92672>.</span><span style=color:#a6e22e>println</span><span style=color:#f92672>(</span><span style=color:#e6db74>&#34;Class doesn&#39;t implements Set&#34;</span><span style=color:#f92672>);</span>
        System<span style=color:#f92672>.</span><span style=color:#a6e22e>exit</span><span style=color:#f92672>(</span>1<span style=color:#f92672>);</span>
    <span style=color:#f92672>}</span>

    s<span style=color:#f92672>.</span><span style=color:#a6e22e>addAll</span><span style=color:#f92672>(</span>Arrays<span style=color:#f92672>.</span><span style=color:#a6e22e>asList</span><span style=color:#f92672>(</span>args<span style=color:#f92672>).</span><span style=color:#a6e22e>subList</span><span style=color:#f92672>(</span>1<span style=color:#f92672>,</span> args<span style=color:#f92672>.</span><span style=color:#a6e22e>length</span><span style=color:#f92672>));</span>
    System<span style=color:#f92672>.</span><span style=color:#a6e22e>out</span><span style=color:#f92672>.</span><span style=color:#a6e22e>println</span><span style=color:#f92672>(</span>s<span style=color:#f92672>);</span>
    <span style=color:#75715e>/// etc
</span><span style=color:#75715e></span><span style=color:#f92672>}</span>
</code></pre></div><ul>
<li>어떤 클래스가 Set을 구현했는지 검증하는 검사도구로 사용 가능 (generic set tester)</li>
<li>일반적 집합 성능 분석 도구 (generic performance analysis tool) 로도 사용 가능</li>
</ul>
<p>2개의 단점 존재</p>
<ul>
<li>6 가지 런타임 오류 발생. 리플렉션 안 썼으면 컴파일 시점에서 다 감지 가능</li>
<li>클래스 객체 생성 위해 코드 엄청 많이 씀. 생성자 호출로 했으면 한 줄로 가능</li>
</ul>
<p>하지만 객체 생성 부분에서만 나타나는 문제로 일단 객체 생성 후에는 Set&lt;>으로 참조하기 때문에 아무 영향 없다.</p>
<p>리플렉션은 실행 시점에 존재하지 않는 클래스나 메서드, 필드에 대한 종속성 관리에 적합.
어떤 패키지의 버전이 여러가지 이고, 그 전부를 지원하는 또 다른 패키지를 구현해야 할 때
모든 버전을 지원하는 최소한의 환경만 컴파일하고, 새로운 클래스나 메서드는 리플렉션을 통해 접근</p>
<h3 id=요약>요약</h3>
<ul>
<li>리플렉션은 특정 종류의 복잡한 시스템 프로그래밍에 필요한 강력한 도구</li>
<li>단점 매우 많음</li>
<li>사용하고 싶다면 객체를 만들 때만 사용하고 참조할 때는 컴파일 시에 알고 있는 인터페이스나 상위 클래스만 사용할 것</li>
</ul>
<h2 id=규칙-54-네이티브-메서드는-신중히-사용하라>규칙 54 네이티브 메서드는 신중히 사용하라</h2>
<p>JNI(java native interface) 는 C나 C++로 작성된 native method 호출하는 데 이용되는 기능.</p>
<p>3가지 용도로 쓰임</p>
<ol>
<li>레지스트리나 파일락 같은 특정 플랫폼에 고유한 기능을 이용</li>
<li>이미 구현되있는 라이브러리를 이용할 수 있음</li>
<li>성능 상 중요한 부분을 네이티브 언어에 맡길 수 있음</li>
</ol>
<h3 id=네이티브-메서드를-통해-성능을-개선하는-것을-추천-안함>네이티브 메서드를 통해 성능을 개선하는 것을 추천 안함</h3>
<ul>
<li>현재 JVM은 네이티브에 필적하는 성능을 낸다.</li>
<li>네이티브 메서드는 심각한 문제 1. 안전하지 않다. memory corruption error 발생 가능</li>
<li>플랫폼 종속적</li>
<li>디버깅 어려움</li>
<li>네이티브와 jvm 넘나드는 코드 때문에 오히려 성능 떨어질 수 있음</li>
<li>이해하기 어렵고 작성하기 난감한 접착 코드 작성해야 함</li>
</ul>
<h3 id=요약-1>요약</h3>
<ul>
<li>네이티브 메서드 쓰지 마라</li>
<li>퍼포먼스 향상 될 일 거의 없다</li>
<li>굳이 써야 한다면 네이티브 코드를 최소화 하고 전체를 다 테스트 해야한다. 작은 버그가 어플리케이션을 다 망침.</li>
</ul>
<h2 id=규칙-55-신중하게-최적화하라>규칙 55 신중하게 최적화하라</h2>
<p>최적화 관련 명언 3개가 있다.</p>
<blockquote>
<p>맹목적인 어리석음을 비롯한 다른 어떤 이유보다도, 효율성이라는 이름으로 저질러지는 죄악이 더 많다. - 윌리엄 울프</p>
</blockquote>
<blockquote>
<p>작은 효율성에 대해서는, 말하자면 97% 정도에 대해서는, 잊어버려라. 섣부른 최적화는 모든 악의 근원이다. - 도널드 커누스</p>
</blockquote>
<blockquote>
<p>최적화 할 때는 아래 두 규칙을 따르라.
규칙 1: 하지 마라
규칙 2: (전문가들만 따를 것) 아직은 하지 마라 - 완벽히 명료한, 최적화되지 않은 해답을 얻을 때까지는 - M.A. 잭슨 M</p>
</blockquote>
<h3 id=중간-요약>중간 요약</h3>
<p><code>최적화 하지마라</code></p>
<ul>
<li>
<p>성능 때문에 구조적인 원칙을 희생하지 마라. 빠른 프로그램이 아닌, 좋은 프로그램을 만드려 노력하라. 좋은 프로그램이라면 좋은 구조를 갖추었기 때문에 최적화의 여지도 충분.</p>
</li>
<li>
<p>설계 할 때는 성능을 제약할 가능성이 있는 결정들은 피하라. 가장 까다로운 부분은 모듈간의 상호작용이나 외부와의 상호작용을 명시하는 부분, 즉 <code>API</code>, <code>통신 프로토콜</code>, <code>지속성 데이터 형식</code> 등 이다. 이런 부분은 성능 문제가 발견된 후 수정이 어렵다.</p>
</li>
<li>
<p>API를 설계할 때 내리는 결정들이 성능에 어떤 영향을 끼칠지 생각하라.</p>
<ul>
<li>public 자료형을 변경 가능하게 만들면 방어적 복사를 많이 해야한다.</li>
<li>composition이 적절할 public class에 상속을 적용하면 해당 클래스는 영원히 상위 클래스에 묶이게 되서 하위 클래스 성능에 제약 가해질 수 있다.</li>
<li>인터페이스가 적당한 API 에 구현자료형 사용하면 해당 API가 특정 구현에 종속되어 나중에 더 빠른 구현이 나와도 개선할 수 없다.</li>
</ul>
</li>
<li>
<p>성능을 위해 API를 급진적으로 바꾸는 건 바람직하지 않다.</p>
<ul>
<li>너무 많이 변경된 API를 지원하는건 개발자가 너무 힘들다.</li>
</ul>
</li>
<li>
<p>최적화를 시도할 때마다 전후 성능을 측정하고 비교하라</p>
<ul>
<li>JVM 마다, 릴리스 마다, 프로세서 마다 차이가 크다.</li>
</ul>
</li>
</ul>
<h3 id=요약-2>요약</h3>
<ul>
<li>빠른 프로그램 만들고자 애쓰지 마라</li>
<li>대신 좋은 프로그램 짜기 위해 노력하면 성능은 따라 온다</li>
<li>시스템 설계할 때 API, 통신 프로토콜, 지속성 데이터 형식을 성계할 때 성능 문제를 따져봐라.</li>
<li>성능 문제 있을 때 처음 해야 할건 구현에 쓰인 알고리즘 검토. 이게 잘못되면 저수준 최적화 의미없음.</li>
</ul>
<h2 id=규칙-56-일반적으로-통용되는-작명-관습을-따르라>규칙 56 일반적으로 통용되는 작명 관습을 따르라</h2>
<ol>
<li>철자에 관한 것</li>
</ol>
<ul>
<li>
<p>package</p>
<ul>
<li>마침표를 구분자로 하는 계층적 이름</li>
<li>소문자 사용</li>
<li>숫자 거의 사용 X</li>
<li>앞에 2개는 조직의 인터넷 도메인을 따온다 (<code>com.tmax</code>)</li>
<li>나머지 부분은 어떤 패키지 인지 설명하는 하나이상의 컴포넌트로 구성</li>
<li>의미가 확실한 약어면 좋음(utilities 보다 util)</li>
</ul>
</li>
<li>
<p>enum, class, interface</p>
<ul>
<li>첫 글자는 대문자</li>
<li>널리 쓰이는 약어(max, min)을 제외하면 약어는 피한다</li>
</ul>
</li>
<li>
<p>메서드, 필드</p>
<ul>
<li>첫 글자는 소문자</li>
<li>상수 필드의 경우 모두 대문자로 쓰며 <code>_</code> 로 구분한다.</li>
</ul>
</li>
<li>
<p>지역 변수</p>
<ul>
<li>메서드, 필드와 같은 규칙</li>
<li>약어를 많이 사용</li>
</ul>
</li>
<li>
<p>자료형 인자</p>
<ul>
<li>보통 하나의 대문자</li>
<li>임의 자료형 T</li>
<li>컬렉션의 요소 자료형 E</li>
<li>맵의 키와 값은 K, V</li>
<li>예외인 경우 X</li>
<li>임의 자료형의 연속은 T, U, V or T1, T2, T3</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th>식별자 자료형</th>
<th>예제</th>
</tr>
</thead>
<tbody>
<tr>
<td>패키지</td>
<td>com.tmax.proobject</td>
</tr>
<tr>
<td>클래스나 인터페이스</td>
<td>ChannelEventHandler, BodyParser</td>
</tr>
<tr>
<td>메서드나 필드</td>
<td>remove, ensureCapacity</td>
</tr>
<tr>
<td>상수 필드</td>
<td>MIN_VALUE, NEGETIVE_INFINITY</td>
</tr>
<tr>
<td>지역 변수</td>
<td>i, xref, houseNumber</td>
</tr>
<tr>
<td>자료형 인자</td>
<td>T, E, K, V, X, T1, T2</td>
</tr>
</tbody>
</table>
<ol start=2>
<li>문법에 관한 것</li>
</ol>
<p>철자 관습보다 가변적이고 논쟁 여지가 많다.</p>
<ul>
<li>패키지는 문법 관습 없음</li>
<li>클래스나 enum 은 단수형 명자나 명사구 붙는다 (Timer, BuffedWriter, ChessPiece)</li>
<li>인터페이스도 클래스와 비슷하며 able이나 ible 같은 형용사격 어미가 붙기도 한다 (Collection, Comparator, Runnable, Iterable, Accessible)</li>
<li>어노테이션은 쓰임새가 너무 다양해 지배적인 규칙이 없다. 명사, 동사, 전치사, 형용사 다 쓰인다 (BindingAnnotation, Inject, ImplementedBy, Singleton)</li>
<li>어떤 동작을 수행하는 메서드는 동사나 동사구를 이름으로 한다(append, add)</li>
<li>boolean 값을 반환하는 method는 보통 is, 가끔 has 로 시작한다 (isDigit, isEmpty, hasSiblings)</li>
<li>boolean 이외의 속성을 반환하는 메서드는 보통 명사나 명사구, get으로 시작한다 (size, hashCode, getTime)</li>
<li>bean 클래스에 속한 메서드이름은 반드시 get으로 시작해야 한다. 속성을 설정하는 건 set으로 시작해야 한다.</li>
<li>객체의 자료형을 변환하는 메서드, 다른 자료형의 <code>독립적 객체</code>를 반환하는 메서드는 보통 toType 형태를 붙인다 (toString, toArray)</li>
<li>인자로 전달받은 객체와 다른 자료형의 <code>View 객체</code>를 반환하는 메서드는 asType 형태의 이름을 붙인다 (asList)</li>
<li>호출 객체와 동일한 기본 자료형 값을 반환하는 경우 typeValue 로 붙인다 (intValue)</li>
<li>정적 팩토리 메서드는 valueOf, of, getInstance, newInstance, getType, newType 등을 붙인다</li>
<li>필드는 특별한 관습 없고 별로 중요하지 않다 (잘 설계된 API는 외부로 필드를 거의 공개 안하기 때문)</li>
<li>boolean field는 메서드와 같은 이름을 붙이거나 is를 생략한다 (initialized, composite)</li>
<li>다른 필드는 보통 명사나 명사구를 쓴다 (height, digits, bodyStyle)</li>
<li>지역 변수는 더 중요하지 않다.</li>
</ul>
<h3 id=요약-3>요약</h3>
<ul>
<li>표준 작명 관습을 내면화 시켜서 제2의 천성인 것 처럼 사용하자</li>
<li>철자 관습은 직관적이며 모호한 부분이 없다</li>
<li>문법 관습은 좀 더 복잡하고 느슨하다</li>
</ul>
<ul class=pa0>
</ul>
<div class="mt6 instapaper_ignoref">
</div>
</div>
<aside class="w-30-l mt6-l">
</aside>
</article>
</main>
<footer class="bg-black bottom-0 w-100 pa3" role=contentinfo>
<div class="flex justify-between">
<a class="f4 fw4 hover-white no-underline white-70 dn dib-ns pv2 ph3" href=https://sangmoon.github.io/TIL>
&copy; Sangmoon's TIL 2021
</a>
<div>
</div>
</div>
</footer>
</body>
</html>