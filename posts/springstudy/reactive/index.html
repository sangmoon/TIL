<!doctype html><html lang=en-us>
<head>
<meta charset=utf-8>
<meta http-equiv=x-ua-compatible content="IE=edge,chrome=1">
<title>Sangmoon's TIL</title>
<meta name=viewport content="width=device-width,minimum-scale=1">
<meta name=description content="Reactive Programming  Reactive Programming이 어떤 것인지 rxJava(reactive java) 를 통해 설명 webflux 는 이것과 용어는 다르겠지만.. 핵심 개념이나 프로그래밍 방식은 유사할 것이라 생각 Reactive programmming with rxJava ch.4 까지 참조  public class Main { public static void main(String[] args) { Observable.just(&#34;Hello world&#34;).subscribe(System.out::println); } } 미리 알아야 할 것  Generic, lambda, method reference
 what is Monad? rx 들어가기 전에 모나드가 무엇인지 알아보자. CompletableFuture니 Observable이니 Flux 니 다 모나드이기 때문에 알면 확실히 편하다!">
<meta name=generator content="Hugo 0.88.1">
<meta name=ROBOTS content="NOINDEX, NOFOLLOW">
<link rel=stylesheet href=/TIL/ananke/css/main.min.css>
<meta property="og:title" content>
<meta property="og:description" content="Reactive Programming  Reactive Programming이 어떤 것인지 rxJava(reactive java) 를 통해 설명 webflux 는 이것과 용어는 다르겠지만.. 핵심 개념이나 프로그래밍 방식은 유사할 것이라 생각 Reactive programmming with rxJava ch.4 까지 참조  public class Main { public static void main(String[] args) { Observable.just(&#34;Hello world&#34;).subscribe(System.out::println); } } 미리 알아야 할 것  Generic, lambda, method reference
 what is Monad? rx 들어가기 전에 모나드가 무엇인지 알아보자. CompletableFuture니 Observable이니 Flux 니 다 모나드이기 때문에 알면 확실히 편하다!">
<meta property="og:type" content="article">
<meta property="og:url" content="https://sangmoon.github.io/TIL/posts/springstudy/reactive/"><meta property="article:section" content="posts">
<meta itemprop=name content>
<meta itemprop=description content="Reactive Programming  Reactive Programming이 어떤 것인지 rxJava(reactive java) 를 통해 설명 webflux 는 이것과 용어는 다르겠지만.. 핵심 개념이나 프로그래밍 방식은 유사할 것이라 생각 Reactive programmming with rxJava ch.4 까지 참조  public class Main { public static void main(String[] args) { Observable.just(&#34;Hello world&#34;).subscribe(System.out::println); } } 미리 알아야 할 것  Generic, lambda, method reference
 what is Monad? rx 들어가기 전에 모나드가 무엇인지 알아보자. CompletableFuture니 Observable이니 Flux 니 다 모나드이기 때문에 알면 확실히 편하다!">
<meta itemprop=wordCount content="2103">
<meta itemprop=keywords content><meta name=twitter:card content="summary">
<meta name=twitter:title content>
<meta name=twitter:description content="Reactive Programming  Reactive Programming이 어떤 것인지 rxJava(reactive java) 를 통해 설명 webflux 는 이것과 용어는 다르겠지만.. 핵심 개념이나 프로그래밍 방식은 유사할 것이라 생각 Reactive programmming with rxJava ch.4 까지 참조  public class Main { public static void main(String[] args) { Observable.just(&#34;Hello world&#34;).subscribe(System.out::println); } } 미리 알아야 할 것  Generic, lambda, method reference
 what is Monad? rx 들어가기 전에 모나드가 무엇인지 알아보자. CompletableFuture니 Observable이니 Flux 니 다 모나드이기 때문에 알면 확실히 편하다!">
</head>
<body class="ma0 avenir bg-near-white">
<header>
<div class=bg-black>
<nav class="pv3 ph3 ph4-ns" role=navigation>
<div class="flex-l justify-between items-center center">
<a href=/TIL/ class="f3 fw2 hover-white no-underline white-90 dib">
Sangmoon's TIL
</a>
<div class="flex-l items-center">
</div>
</div>
</nav>
</div>
</header>
<main class=pb7 role=main>
<article class="flex-l flex-wrap justify-between mw8 center ph3">
<header class="mt4 w-100">
<aside class="instapaper_ignoref b helvetica tracked">
POSTS
</aside>
<div id=sharing class=mt3>
<a href="https://www.facebook.com/sharer.php?u=https://sangmoon.github.io/TIL/posts/springstudy/reactive/" class="facebook no-underline" aria-label="share on Facebook"><svg height="32" style="enable-background:new 0 0 67 67" viewBox="0 0 67 67" width="32" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><path d="M28.765 50.32h6.744V33.998h4.499l.596-5.624h-5.095l.007-2.816c0-1.466.14-2.253 2.244-2.253h2.812V17.68h-4.5c-5.405.0-7.307 2.729-7.307 7.317v3.377h-3.369v5.625h3.369V50.32zM33 64C16.432 64 3 50.569 3 34S16.432 4 33 4s30 13.431 30 30S49.568 64 33 64z" style="fill-rule:evenodd;clip-rule:evenodd"/></svg>
</a>
<a href="https://twitter.com/share?url=https://sangmoon.github.io/TIL/posts/springstudy/reactive/&text=" class="twitter no-underline" aria-label="share on Twitter"><svg height="32" style="enable-background:new 0 0 67 67" viewBox="0 0 67 67" width="32" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><path d="M37.167 22.283c-2.619.953-4.274 3.411-4.086 6.101l.063 1.038-1.048-.127c-3.813-.487-7.145-2.139-9.974-4.915l-1.383-1.377-.356 1.017c-.754 2.267-.272 4.661 1.299 6.271.838.89.649 1.017-.796.487-.503-.169-.943-.296-.985-.233-.146.149.356 2.076.754 2.839.545 1.06 1.655 2.097 2.871 2.712l1.027.487-1.215.021c-1.173.0-1.215.021-1.089.467.419 1.377 2.074 2.839 3.918 3.475l1.299.444-1.131.678c-1.676.976-3.646 1.526-5.616 1.568C19.775 43.256 19 43.341 19 43.405c0 .211 2.557 1.397 4.044 1.864 4.463 1.377 9.765.783 13.746-1.568 2.829-1.673 5.657-5 6.978-8.221.713-1.716 1.425-4.851 1.425-6.354.0-.975.063-1.102 1.236-2.267.692-.678 1.341-1.419 1.467-1.631.21-.403.188-.403-.88-.043-1.781.636-2.033.551-1.152-.402.649-.678 1.425-1.907 1.425-2.267.0-.063-.314.042-.671.233-.377.212-1.215.53-1.844.72l-1.131.361-1.027-.7c-.566-.381-1.361-.805-1.781-.932C39.766 21.902 38.131 21.944 37.167 22.283zM33 64C16.432 64 3 50.569 3 34S16.432 4 33 4s30 13.431 30 30S49.568 64 33 64z" style="fill-rule:evenodd;clip-rule:evenodd;fill:"/></svg>
</a>
<a href="https://www.linkedin.com/shareArticle?mini=true&url=https://sangmoon.github.io/TIL/posts/springstudy/reactive/&title=" class="linkedin no-underline" aria-label="share on LinkedIn"><svg height="32" style="enable-background:new 0 0 65 65" viewBox="0 0 65 65" width="32" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><path d="M50.837 48.137V36.425c0-6.275-3.35-9.195-7.816-9.195-3.604.0-5.219 1.983-6.119 3.374V27.71h-6.79c.09 1.917.0 20.427.0 20.427h6.79V36.729c0-.609.044-1.219.224-1.655.49-1.22 1.607-2.483 3.482-2.483 2.458.0 3.44 1.873 3.44 4.618v10.929H50.837zM22.959 24.922c2.367.0 3.842-1.57 3.842-3.531-.044-2.003-1.475-3.528-3.797-3.528s-3.841 1.524-3.841 3.528c0 1.961 1.474 3.531 3.753 3.531H22.959zM34 64C17.432 64 4 50.568 4 34 4 17.431 17.432 4 34 4s30 13.431 30 30c0 16.568-13.432 30-30 30zM26.354 48.137V27.71h-6.789v20.427h6.789z" style="fill-rule:evenodd;clip-rule:evenodd;fill:"/></svg>
</a>
</div>
<h1 class="f1 athelas mt3 mb1"></h1>
</header>
<div class="nested-copy-line-height lh-copy serif f4 nested-links nested-img mid-gray pr4-l w-two-thirds-l"><h1 id=reactive-programming>Reactive Programming</h1>
<ul>
<li>Reactive Programming이 어떤 것인지 rxJava(reactive java) 를 통해 설명</li>
<li>webflux 는 이것과 용어는 다르겠지만.. 핵심 개념이나 프로그래밍 방식은 유사할 것이라 생각</li>
<li>Reactive programmming with rxJava ch.4 까지 참조</li>
</ul>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Main</span> <span style=color:#f92672>{</span>
    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>main</span><span style=color:#f92672>(</span>String<span style=color:#f92672>[]</span> args<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
        Observable<span style=color:#f92672>.</span><span style=color:#a6e22e>just</span><span style=color:#f92672>(</span><span style=color:#e6db74>&#34;Hello world&#34;</span><span style=color:#f92672>).</span><span style=color:#a6e22e>subscribe</span><span style=color:#f92672>(</span>System<span style=color:#f92672>.</span><span style=color:#a6e22e>out</span><span style=color:#f92672>::</span>println<span style=color:#f92672>);</span>
    <span style=color:#f92672>}</span>
<span style=color:#f92672>}</span>
</code></pre></div><h2 id=미리-알아야-할-것>미리 알아야 할 것</h2>
<blockquote>
<p>Generic, lambda, method reference</p>
</blockquote>
<h2 id=what-is-monad>what is Monad?</h2>
<p>rx 들어가기 전에 모나드가 무엇인지 알아보자.
CompletableFuture니 Observable이니 Flux 니 다 모나드이기 때문에 알면 확실히 편하다!</p>
<p>모나드 정의 대한 가장 쉬운 설명</p>
<p><img src=https://github.com/sangmoon/TIL/raw/master/springStudy/resource/monad.png alt=flip></p>
<p>&mldr;? 갑자기 수학이..?</p>
<ul>
<li>flatMap은 <code>monad</code> 가 구현해야 하는 bind method, m 은 모나드, x는 모나드의 내부 값..</li>
<li>결합법칙이 적용되어야 한다</li>
<li>2,3 번은 중립적이어야 한다는 말인데..설명할 수 없다. 아는게 설명할 수가 없어..</li>
</ul>
<p>또 프로그래밍 언어에서는 다음 3개의 특징을 만족해야 한다</p>
<ul>
<li>모나드는 다른 타입을 받는 타입이다 (Generic)</li>
<li>모나드 의 값을 생성하는 함수가 있어야 한다(생성자)</li>
<li>다른 모나드타입으로 진행하는 함수가 있어야 한다(flatMap)</li>
</ul>
<p>&mldr; 일단 이렇다고 알아두고 구체적인 설명으로 들어가 봅시다.</p>
<h3 id=functor>functor</h3>
<p>functor는 다음 조건을 만족하는 녀석을 말한다.<br>
함수를 인자로 받아 결과를 반환하는 method(여기선 map) 만 있으면 됨</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#f92672>import</span> java.util.function.Function<span style=color:#f92672>;</span>

<span style=color:#66d9ef>interface</span> <span style=color:#a6e22e>Functor</span><span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span> <span style=color:#f92672>{</span>
    <span style=color:#f92672>&lt;</span>R<span style=color:#f92672>&gt;</span> Functor<span style=color:#f92672>&lt;</span>R<span style=color:#f92672>&gt;</span> <span style=color:#a6e22e>map</span><span style=color:#f92672>(</span>Function<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>,</span>R<span style=color:#f92672>&gt;</span> f<span style=color:#f92672>);</span>
<span style=color:#f92672>}</span>
</code></pre></div><p>예를 들어보자면 &mldr;</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Identity</span><span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span> <span style=color:#66d9ef>implements</span> Functor<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>,</span> Identity<span style=color:#f92672>&lt;?&gt;&gt;</span> <span style=color:#f92672>{</span>
    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>final</span> T value<span style=color:#f92672>;</span>

    Identity<span style=color:#f92672>(</span>T value<span style=color:#f92672>)</span> <span style=color:#f92672>{</span> <span style=color:#66d9ef>this</span><span style=color:#f92672>.</span><span style=color:#a6e22e>value</span> <span style=color:#f92672>=</span> value<span style=color:#f92672>;</span> <span style=color:#f92672>}</span>

    <span style=color:#66d9ef>public</span> <span style=color:#f92672>&lt;</span>R<span style=color:#f92672>&gt;</span> Identity<span style=color:#f92672>&lt;</span>R<span style=color:#f92672>&gt;</span> <span style=color:#a6e22e>map</span><span style=color:#f92672>(</span>Function<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>,</span>R<span style=color:#f92672>&gt;</span> f<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
        <span style=color:#66d9ef>final</span> R result <span style=color:#f92672>=</span> f<span style=color:#f92672>.</span><span style=color:#a6e22e>apply</span><span style=color:#f92672>(</span>value<span style=color:#f92672>);</span>
        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>new</span> Identity<span style=color:#f92672>&lt;&gt;(</span>result<span style=color:#f92672>);</span>
    <span style=color:#f92672>}</span>
<span style=color:#f92672>}</span>
</code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#75715e>// 다음과 같이 쓸 수 있다.
</span><span style=color:#75715e></span>Identity<span style=color:#f92672>&lt;</span>String<span style=color:#f92672>&gt;</span> idString <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Identity<span style=color:#f92672>&lt;&gt;(</span><span style=color:#e6db74>&#34;abc&#34;</span><span style=color:#f92672>);</span>
Identity<span style=color:#f92672>&lt;</span>Integer<span style=color:#f92672>&gt;</span> idInt <span style=color:#f92672>=</span> idString<span style=color:#f92672>.</span><span style=color:#a6e22e>map</span><span style=color:#f92672>(</span>String<span style=color:#f92672>::</span>length<span style=color:#f92672>);</span>

<span style=color:#75715e>// chaining 도 물론 가능!
</span><span style=color:#75715e></span>Identity<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>byte</span><span style=color:#f92672>[]&gt;</span> idBytes <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Identity<span style=color:#f92672>&lt;&gt;(</span>customer<span style=color:#f92672>)</span>
    <span style=color:#f92672>.</span><span style=color:#a6e22e>map</span><span style=color:#f92672>(</span>Customer<span style=color:#f92672>::</span>getAddress<span style=color:#f92672>)</span>
    <span style=color:#f92672>.</span><span style=color:#a6e22e>map</span><span style=color:#f92672>(</span>Address<span style=color:#f92672>::</span>street<span style=color:#f92672>)</span>
    <span style=color:#f92672>.</span><span style=color:#a6e22e>map</span><span style=color:#f92672>((</span>String s<span style=color:#f92672>)</span> <span style=color:#f92672>-&gt;</span> s<span style=color:#f92672>.</span><span style=color:#a6e22e>substring</span><span style=color:#f92672>(</span>0<span style=color:#f92672>,</span>3<span style=color:#f92672>))</span>
    <span style=color:#f92672>.</span><span style=color:#a6e22e>map</span><span style=color:#f92672>(</span>String<span style=color:#f92672>::</span>toLowerCase<span style=color:#f92672>)</span>
    <span style=color:#f92672>.</span><span style=color:#a6e22e>map</span><span style=color:#f92672>(</span>String<span style=color:#f92672>::</span>getBytes<span style=color:#f92672>);</span>
</code></pre></div><p>그런데 이렇게만 보면 method chaining과 다를 바가 없음</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#75715e>// 그냥 method chaining
</span><span style=color:#75715e></span><span style=color:#66d9ef>byte</span><span style=color:#f92672>[]</span> bytes <span style=color:#f92672>=</span> customer
    <span style=color:#f92672>.</span><span style=color:#a6e22e>getAddress</span><span style=color:#f92672>()</span>
    <span style=color:#f92672>.</span><span style=color:#a6e22e>street</span><span style=color:#f92672>()</span>
    <span style=color:#f92672>.</span><span style=color:#a6e22e>substring</span><span style=color:#f92672>(</span>0<span style=color:#f92672>,</span>3<span style=color:#f92672>)</span>
    <span style=color:#f92672>.</span><span style=color:#a6e22e>toLowerCase</span><span style=color:#f92672>()</span>
    <span style=color:#f92672>.</span><span style=color:#a6e22e>getBytes</span><span style=color:#f92672>();</span>
</code></pre></div><p>펑터의 장점은 무엇일까??</p>
<ol>
<li>내부에서 함수의 동작을 제어할 수 있다.</li>
</ol>
<p>java8 에 추가된 Optional을 직접 구현한 FOptional 클래스를 보자
Optional은 NPE 를 피하며 프로그래밍하기 위한 API!</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>FOptional</span><span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span> <span style=color:#66d9ef>implements</span> Functor<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>,</span>FOptional<span style=color:#f92672>&lt;?&gt;&gt;</span> <span style=color:#f92672>{</span>
    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>final</span> T valueOrNull<span style=color:#f92672>;</span>

    <span style=color:#66d9ef>private</span> <span style=color:#a6e22e>FOptional</span><span style=color:#f92672>(</span>T valueOrNull<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
        <span style=color:#66d9ef>this</span><span style=color:#f92672>.</span><span style=color:#a6e22e>valueOrNull</span> <span style=color:#f92672>=</span> valueOrNull<span style=color:#f92672>;</span>
    <span style=color:#f92672>}</span>
    <span style=color:#66d9ef>public</span> <span style=color:#f92672>&lt;</span>R<span style=color:#f92672>&gt;</span> FOptional<span style=color:#f92672>&lt;</span>R<span style=color:#f92672>&gt;</span> <span style=color:#a6e22e>map</span><span style=color:#f92672>(</span>Function<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>,</span>R<span style=color:#f92672>&gt;</span> f<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
        <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>valueOrNull <span style=color:#f92672>==</span> <span style=color:#66d9ef>null</span><span style=color:#f92672>)</span> <span style=color:#75715e>// 비어있으면 f 를 사용하지 않음
</span><span style=color:#75715e></span>            <span style=color:#66d9ef>return</span> empty<span style=color:#f92672>();</span>
        <span style=color:#66d9ef>else</span>
            <span style=color:#66d9ef>return</span> of<span style=color:#f92672>(</span>f<span style=color:#f92672>.</span><span style=color:#a6e22e>apply</span><span style=color:#f92672>(</span>valueOrNull<span style=color:#f92672>));</span>
    <span style=color:#f92672>}</span>
    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span> FOptional<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span> <span style=color:#a6e22e>of</span><span style=color:#f92672>(</span>T a<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>new</span> FOptional<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;(</span>a<span style=color:#f92672>);</span>
    <span style=color:#f92672>}</span>
    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span> FOptional<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span> <span style=color:#a6e22e>empty</span><span style=color:#f92672>()</span> <span style=color:#f92672>{</span>
        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>new</span> FOptional<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;(</span><span style=color:#66d9ef>null</span><span style=color:#f92672>);</span>
    <span style=color:#f92672>}</span>
<span style=color:#f92672>}</span>
</code></pre></div><p>팩토리 메소드를 통해 값을 갖는 optional과 null인 optional 생성 가능.<br>
값이 null 이면 원래는 NPE지만 함수를 실행시키지 않고 빈 optional 반환. 신기하죠?</p>
<p>또 다른 예제는 List 를 펑터 형태로 바꾼 Flist</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>FList</span><span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span> <span style=color:#66d9ef>implements</span> Functor<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>,</span> FList<span style=color:#f92672>&lt;?&gt;&gt;</span> <span style=color:#f92672>{</span>
    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>final</span> List<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span> list<span style=color:#f92672>;</span> <span style=color:#75715e>// immutable 해야함
</span><span style=color:#75715e></span>
    FList<span style=color:#f92672>(</span>Iterable<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span> iterable<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
        list <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> ArrayList<span style=color:#f92672>&lt;&gt;();</span>
        iterable<span style=color:#f92672>.</span><span style=color:#a6e22e>forEach</span><span style=color:#f92672>(</span>list<span style=color:#f92672>::</span>add<span style=color:#f92672>);</span> <span style=color:#75715e>// 대략 이런 느낌
</span><span style=color:#75715e></span>    <span style=color:#f92672>}</span>

    <span style=color:#a6e22e>@Override</span>
    <span style=color:#66d9ef>public</span> <span style=color:#f92672>&lt;</span>R<span style=color:#f92672>&gt;</span> FList<span style=color:#f92672>&lt;</span>R<span style=color:#f92672>&gt;</span> <span style=color:#a6e22e>map</span><span style=color:#f92672>(</span>Function<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>,</span> R<span style=color:#f92672>&gt;</span> f<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
        ArrayList<span style=color:#f92672>&lt;</span>R<span style=color:#f92672>&gt;</span> result <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> ArrayList<span style=color:#f92672>&lt;</span>R<span style=color:#f92672>&gt;(</span>list<span style=color:#f92672>.</span><span style=color:#a6e22e>size</span><span style=color:#f92672>());</span>
        <span style=color:#66d9ef>for</span><span style=color:#f92672>(</span>T t<span style=color:#f92672>:</span> list<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
            result<span style=color:#f92672>.</span><span style=color:#a6e22e>add</span><span style=color:#f92672>(</span>f<span style=color:#f92672>.</span><span style=color:#a6e22e>apply</span><span style=color:#f92672>(</span>t<span style=color:#f92672>));</span>
        <span style=color:#f92672>}</span>
        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>new</span> FList<span style=color:#f92672>&lt;&gt;(</span>result<span style=color:#f92672>);</span>
    <span style=color:#f92672>}</span>
<span style=color:#f92672>}</span>
</code></pre></div><p>Flist의 장점은 무엇일까?? 내부 값이 1개든 10개든 같은 메소드 적용 가능하다는 것!</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#f92672>import static</span> java.util.Arrays.asList<span style=color:#f92672>;</span>

FList<span style=color:#f92672>&lt;</span>Customer<span style=color:#f92672>&gt;</span> customers <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> FList<span style=color:#f92672>&lt;&gt;(</span>asList<span style=color:#f92672>(</span>cust1<span style=color:#f92672>,</span> cust2<span style=color:#f92672>));</span>
FList<span style=color:#f92672>&lt;</span>String<span style=color:#f92672>&gt;</span> streets <span style=color:#f92672>=</span> customers
        <span style=color:#f92672>.</span><span style=color:#a6e22e>map</span><span style=color:#f92672>(</span>Customer<span style=color:#f92672>::</span>getAddress<span style=color:#f92672>)</span>
        <span style=color:#f92672>.</span><span style=color:#a6e22e>map</span><span style=color:#f92672>(</span>Address<span style=color:#f92672>::</span>street<span style=color:#f92672>);</span>
</code></pre></div><p>단순 메소드 체이닝으로는 불가능한 영역. flist 대신에 java8의 Stream 사용해도 되지 않을까?<br>
사실 Stream 도 functor 이자 모나드 이다!!</p>
<h3 id=functor-에서-모나드로>functor 에서 모나드로</h3>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java>FOptional<span style=color:#f92672>&lt;</span>Integer<span style=color:#f92672>&gt;</span> <span style=color:#a6e22e>tryParse</span><span style=color:#f92672>(</span>String s<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
    <span style=color:#66d9ef>try</span> <span style=color:#f92672>{</span>
        <span style=color:#66d9ef>final</span> <span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> Integer<span style=color:#f92672>.</span><span style=color:#a6e22e>parseInt</span><span style=color:#f92672>(</span>s<span style=color:#f92672>);</span>
        <span style=color:#66d9ef>return</span> FOptional<span style=color:#f92672>.</span><span style=color:#a6e22e>of</span><span style=color:#f92672>(</span>i<span style=color:#f92672>);</span>
    <span style=color:#f92672>}</span> <span style=color:#66d9ef>catch</span> <span style=color:#f92672>(</span>NumberFormatException e<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
        <span style=color:#66d9ef>return</span> FOptional<span style=color:#f92672>.</span><span style=color:#a6e22e>empty</span><span style=color:#f92672>();</span>
    <span style=color:#f92672>}</span>
<span style=color:#f92672>}</span>
</code></pre></div><p>위와 같이 Optinal을 반환하는 메소드를 생각해보자. 스트링을 받아 Integer로 변환되면 해당 값을 Optional로 반환하고,
실패하면 빈 Optional을 반환한다. ( Exception을 throw 하지 않는 이유는 함수형 언어 스타일과 맞지 않기 때문..
순수 함수형 언어에는 예외가 없다, 오류나 부적절한 조건도 값으로 명시)</p>
<p>그러면 client code는 ?</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java>FOptional<span style=color:#f92672>&lt;</span>String<span style=color:#f92672>&gt;</span> str <span style=color:#f92672>=</span> FOptional<span style=color:#f92672>.</span><span style=color:#a6e22e>of</span><span style=color:#f92672>(</span><span style=color:#e6db74>&#34;42&#34;</span><span style=color:#f92672>);</span>
FOptional<span style=color:#f92672>&lt;</span>FOptional<span style=color:#f92672>&lt;</span>Integer<span style=color:#f92672>&gt;&gt;</span> num <span style=color:#f92672>=</span> str<span style=color:#f92672>.</span><span style=color:#a6e22e>map</span><span style=color:#f92672>(</span><span style=color:#66d9ef>this</span><span style=color:#f92672>::</span>tryParse<span style=color:#f92672>);</span> <span style=color:#75715e>// Optional 안에 Optional이 !?
</span></code></pre></div><p>functor 예제에서는 단순 Type을 메소드 반환값으로 해서 괜찮았으나 Optional을 반환형으로 하게 되면 문제가 생긴다.
보기에도 가독성이 떨어지고, 메소드 체이닝에도 문제가 생긴다.</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java>FOptional<span style=color:#f92672>&lt;</span>Integer<span style=color:#f92672>&gt;</span> num1 <span style=color:#f92672>=</span> <span style=color:#75715e>// ...
</span><span style=color:#75715e></span>FOptional<span style=color:#f92672>&lt;</span>FOptional<span style=color:#f92672>&lt;</span>Integer<span style=color:#f92672>&gt;&gt;</span> num2 <span style=color:#f92672>=</span> <span style=color:#75715e>// ...
</span><span style=color:#75715e></span>
FOptional<span style=color:#f92672>&lt;</span>Date<span style=color:#f92672>&gt;</span> date1 <span style=color:#f92672>=</span> num1<span style=color:#f92672>.</span><span style=color:#a6e22e>map</span><span style=color:#f92672>(</span>t <span style=color:#f92672>-&gt;</span> <span style=color:#66d9ef>new</span> Date<span style=color:#f92672>(</span>t<span style=color:#f92672>));</span>
<span style=color:#75715e>// 컴파일 안됨
</span><span style=color:#75715e></span>FOptional<span style=color:#f92672>&lt;</span>Date<span style=color:#f92672>&gt;</span> date2 <span style=color:#f92672>=</span> num2<span style=color:#f92672>.</span><span style=color:#a6e22e>map</span><span style=color:#f92672>(</span>t <span style=color:#f92672>-&gt;</span> <span style=color:#66d9ef>new</span> Date<span style=color:#f92672>(</span>t<span style=color:#f92672>));</span>
</code></pre></div><p>펑터를 2번 감싸는 것으로 문제가 발생함.. 이를 해결하기 위해 모나드 탄생</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>interface</span> <span style=color:#a6e22e>Monad</span><span style=color:#f92672>&lt;</span>T<span style=color:#f92672>,</span> M <span style=color:#66d9ef>extends</span> Monad<span style=color:#f92672>&lt;?,</span>M<span style=color:#f92672>&gt;&gt;</span> <span style=color:#66d9ef>extends</span> Functor<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>,</span> M<span style=color:#f92672>&gt;{</span>
    M <span style=color:#a6e22e>flatMap</span><span style=color:#f92672>(</span>Function<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>,</span>M<span style=color:#f92672>&gt;</span> f<span style=color:#f92672>);</span>
<span style=color:#75715e>// &lt;R&gt; Functor&lt;R&gt; map(Function&lt;T,R&gt; f);
</span><span style=color:#75715e>// Functor&lt;R&gt; 을 반환하지 않고 새로운 M을 반환함 
</span><span style=color:#75715e></span><span style=color:#f92672>}</span>
</code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#75715e>// optional 에 구현한 코드
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>public</span> FOptional<span style=color:#f92672>&lt;?&gt;</span> flatMap<span style=color:#f92672>(</span>Function<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>,</span> FOptional<span style=color:#f92672>&lt;?&gt;&gt;</span> f<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
        <span style=color:#66d9ef>if</span><span style=color:#f92672>(</span>valueOrNull <span style=color:#f92672>==</span> <span style=color:#66d9ef>null</span><span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
            <span style=color:#66d9ef>return</span> FOptional<span style=color:#f92672>.</span><span style=color:#a6e22e>empty</span><span style=color:#f92672>();</span>
        <span style=color:#f92672>}</span> <span style=color:#66d9ef>else</span> <span style=color:#f92672>{</span>
            <span style=color:#66d9ef>return</span> f<span style=color:#f92672>.</span><span style=color:#a6e22e>apply</span><span style=color:#f92672>(</span>valueOrNull<span style=color:#f92672>);</span>
            <span style=color:#75715e>// return of(f.apply(valueOrNull));
</span><span style=color:#75715e></span>        <span style=color:#f92672>}</span>
    <span style=color:#f92672>}</span>
</code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java>FOptional<span style=color:#f92672>&lt;</span>String<span style=color:#f92672>&gt;</span> num <span style=color:#f92672>=</span> FOptional<span style=color:#f92672>.</span><span style=color:#a6e22e>of</span><span style=color:#f92672>(</span><span style=color:#e6db74>&#34;42&#34;</span><span style=color:#f92672>);</span>
<span style=color:#75715e>// 이젠 정상 동작
</span><span style=color:#75715e></span>FOptional<span style=color:#f92672>&lt;</span>Integer<span style=color:#f92672>&gt;</span> answer <span style=color:#f92672>=</span> num<span style=color:#f92672>.</span><span style=color:#a6e22e>flatMap</span><span style=color:#f92672>(</span><span style=color:#66d9ef>this</span><span style=color:#f92672>::</span>tryParse<span style=color:#f92672>);</span>
</code></pre></div><p>여기까지가 모나드 정리..!
사실 오늘 강의 끝내도 됨&mldr;
이제 rxJava 로 들어가 봅시다.</p>
<h2 id=reactive-programming-with-rxjava>Reactive Programming with rxJava</h2>
<p>rxJava 의 특징</p>
<h3 id=observable-and-observer-push-versus-pull>Observable and Observer (Push versus Pull)</h3>
<p><code>Observable</code>(Supplier) 과 <code>Observer</code>(Consumer) 를 우선 구분해야 합니다.</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#66d9ef>interface</span> <span style=color:#a6e22e>Observable</span><span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span> <span style=color:#f92672>{</span>
    Subscription <span style=color:#a6e22e>subscribe</span><span style=color:#f92672>(</span>Observer s<span style=color:#f92672>)</span>
<span style=color:#f92672>}</span>
</code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#66d9ef>interface</span> <span style=color:#a6e22e>Observer</span><span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span> <span style=color:#f92672>{</span>
    <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>onNext</span><span style=color:#f92672>(</span>T t<span style=color:#f92672>)</span>            <span style=color:#75715e>// 이벤트 발생시
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>onError</span><span style=color:#f92672>(</span>Throwable t<span style=color:#f92672>)</span>   <span style=color:#75715e>// 에러 발생시
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>onCompleted</span><span style=color:#f92672>()</span>          <span style=color:#75715e>// 스트림 완료시
</span><span style=color:#75715e></span><span style=color:#f92672>}</span>
</code></pre></div><h3 id=async-versus-sync>Async versus Sync</h3>
<p>Observable은 async 하지만 꼭 그럴 필요는 없습니다.<br>
synchronous 하게 할 수 있고 default 는 sync 입니다.<br>
synchronous <code>Observable</code> 은 subscribe 되면 모든 데이터를 subscriber 쓰레드로 보내고 완료됩니다.</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java>Obervable<span style=color:#f92672>.</span><span style=color:#a6e22e>create</span><span style=color:#f92672>(</span>s <span style=color:#f92672>-&gt;</span> <span style=color:#f92672>{</span>
    s<span style=color:#f92672>.</span><span style=color:#a6e22e>onNext</span><span style=color:#f92672>(</span><span style=color:#e6db74>&#34;Hello World&#34;</span><span style=color:#f92672>);</span>    <span style=color:#75715e>// (1) 여기가 blocking long time IO 라면?? 그만큼 기다려야 함.
</span><span style=color:#75715e></span>    s<span style=color:#f92672>.</span><span style=color:#a6e22e>onCompleted</span><span style=color:#f92672>();</span>
<span style=color:#f92672>}).</span><span style=color:#a6e22e>subscribe</span><span style=color:#f92672>(</span>hello <span style=color:#f92672>-&gt;</span> System<span style=color:#f92672>.</span><span style=color:#a6e22e>out</span><span style=color:#f92672>.</span><span style=color:#a6e22e>println</span><span style=color:#f92672>(</span>hello<span style=color:#f92672>));</span>
</code></pre></div><p>이 예제는 완벽히 sync 함..(하나의 thread 가 전부 수행)</p>
<ol>
<li>Obervable.create로 Observable 생성</li>
<li>subscribe() 통해 구독</li>
<li>Obervable 시작되면서 onNext(&ldquo;hello World) 실행</li>
<li>onCompleted() 실행</li>
</ol>
<p>(1) 이 오래걸리는 blocking job 이라면 그 만큼 block 됨
(2) 여러 쓰래드에 작업을 할당하는 것은 뒤 챕터에서 &mldr;</p>
<h3 id=concurrency-and-parallelism>Concurrency and Parallelism</h3>
<ul>
<li>Concurrency: 하나의 CPU에서 여러 task를 <code>time slicing</code> 으로 진행</li>
<li>Parallelism: 멀티코어에서 동시에 작업 진행</li>
</ul>
<blockquote>
<p><code>하나의 Observable에 대해 이벤트(onNext(), onCompleted(), onError()) 는 concurrently 하게 발생할 수 없다</code> 고 rxJava 규약에 나와 있음</p>
</blockquote>
<p>Observable은 여러 쓰레드가 이벤트를 발생시킬 수 있지만, 하나의 쓰레드가 이벤트 발생 중이면, 다른 쓰레드가 inter-leaving 해서는 안 된다.</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#75715e>// 이렇게 쓰지 말자
</span><span style=color:#75715e></span>Observable<span style=color:#f92672>.</span><span style=color:#a6e22e>create</span><span style=color:#f92672>(</span>s <span style=color:#f92672>-&gt;</span> <span style=color:#f92672>{</span>
    <span style=color:#75715e>// Thread A
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>new</span> Thread<span style=color:#f92672>(()</span> <span style=color:#f92672>-&gt;</span> <span style=color:#f92672>{</span>
        s<span style=color:#f92672>.</span><span style=color:#a6e22e>onNext</span><span style=color:#f92672>(</span><span style=color:#e6db74>&#34;one&#34;</span><span style=color:#f92672>);</span>
        s<span style=color:#f92672>.</span><span style=color:#a6e22e>onNext</span><span style=color:#f92672>(</span><span style=color:#e6db74>&#34;two&#34;</span><span style=color:#f92672>);</span>

    <span style=color:#f92672>}).</span><span style=color:#a6e22e>start</span><span style=color:#f92672>();</span>

    <span style=color:#75715e>// Thread B
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>new</span> Thread<span style=color:#f92672>(()</span> <span style=color:#f92672>-&gt;</span> <span style=color:#f92672>{</span>
        s<span style=color:#f92672>.</span><span style=color:#a6e22e>onNext</span><span style=color:#f92672>(</span><span style=color:#e6db74>&#34;three&#34;</span><span style=color:#f92672>);</span>
        s<span style=color:#f92672>.</span><span style=color:#a6e22e>onNext</span><span style=color:#f92672>(</span><span style=color:#e6db74>&#34;four&#34;</span><span style=color:#f92672>);</span>
    <span style=color:#f92672>}).</span><span style=color:#a6e22e>start</span><span style=color:#f92672>();</span>
<span style=color:#f92672>})</span>
</code></pre></div><p>그럼 멀티쓰레딩 이용 못하는 것 아닌가?? rxJava 에서는 Composition을 이용해 해결</p>
<blockquote>
<p>하나의 Observable 스트림은 항상 serialize 해야 한다. 하지만 각각의 스트림은 독립적으로 동작할 수 있으니 그걸 합치자!</p>
</blockquote>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#75715e>// 규약에 맞는 버전
</span><span style=color:#75715e></span>Observable<span style=color:#f92672>&lt;</span>String<span style=color:#f92672>&gt;</span> a <span style=color:#f92672>=</span> Observable<span style=color:#f92672>.</span><span style=color:#a6e22e>create</span><span style=color:#f92672>(</span>s <span style=color:#f92672>-&gt;</span> <span style=color:#f92672>{</span>
    <span style=color:#66d9ef>new</span> Thread<span style=color:#f92672>(()</span> <span style=color:#f92672>-&gt;</span> <span style=color:#f92672>{</span>
        s<span style=color:#f92672>.</span><span style=color:#a6e22e>onNext</span><span style=color:#f92672>(</span><span style=color:#e6db74>&#34;one&#34;</span><span style=color:#f92672>);</span>
        s<span style=color:#f92672>.</span><span style=color:#a6e22e>onNext</span><span style=color:#f92672>(</span><span style=color:#e6db74>&#34;two&#34;</span><span style=color:#f92672>);</span>

    <span style=color:#f92672>}).</span><span style=color:#a6e22e>start</span><span style=color:#f92672>();</span>
<span style=color:#f92672>});</span>
Observable<span style=color:#f92672>&lt;</span>String<span style=color:#f92672>&gt;</span> b <span style=color:#f92672>=</span> Observable<span style=color:#f92672>.</span><span style=color:#a6e22e>create</span><span style=color:#f92672>(</span>s <span style=color:#f92672>-&gt;</span> <span style=color:#f92672>{</span>
    <span style=color:#66d9ef>new</span> Thread<span style=color:#f92672>(()</span> <span style=color:#f92672>-&gt;</span> <span style=color:#f92672>{</span>
        s<span style=color:#f92672>.</span><span style=color:#a6e22e>onNext</span><span style=color:#f92672>(</span><span style=color:#e6db74>&#34;three&#34;</span><span style=color:#f92672>);</span>
        s<span style=color:#f92672>.</span><span style=color:#a6e22e>onNext</span><span style=color:#f92672>(</span><span style=color:#e6db74>&#34;four&#34;</span><span style=color:#f92672>);</span>
    <span style=color:#f92672>}).</span><span style=color:#a6e22e>start</span><span style=color:#f92672>();</span>
<span style=color:#f92672>});</span>

<span style=color:#75715e>// c 는 a와 b를 subscribe 하면서 새로운 serialized stream을 만듬
</span><span style=color:#75715e>// 내부적으로 atomic 연산 사용
</span><span style=color:#75715e></span>Observable<span style=color:#f92672>&lt;</span>String<span style=color:#f92672>&gt;</span> c <span style=color:#f92672>=</span> Observable<span style=color:#f92672>.</span><span style=color:#a6e22e>merge</span><span style=color:#f92672>(</span>a<span style=color:#f92672>,</span> b<span style=color:#f92672>);</span>
</code></pre></div><h3 id=duality>Duality</h3>
<p><code>Observable</code> 은 <code>Iterable</code> 과 쌍둥이 같은 존재</p>
<table>
<thead>
<tr>
<th>Pull(<code>Iterable</code>)</th>
<th>Push(<code>Observable</code>)</th>
</tr>
</thead>
<tbody>
<tr>
<td>T next()</td>
<td>onNext(T)</td>
</tr>
<tr>
<td>throws Exception</td>
<td>onError(Throwable)</td>
</tr>
<tr>
<td>returns</td>
<td>onCompleted()</td>
</tr>
</tbody>
</table>
<ul>
<li>Iterable 은 Consumer가 next()를 호출해서 데이터를 가져옴</li>
<li>Observable 은 producer가 onNext()를 실행해 데이터를 밀어 넣어줌</li>
</ul>
<p>rxJava는 Pull 이 아닌 Push 를 기반으로 동작(pull 도 되긴 합니다..)</p>
<h3 id=cardinality>Cardinality</h3>
<p>Observable 은 여러 값을 push 하는 것을 지원(마치 async Iterable 처럼)</p>
<table>
<thead>
<tr>
<th></th>
<th>One</th>
<th>Many</th>
</tr>
</thead>
<tbody>
<tr>
<td>Synchronous</td>
<td>T getData()</td>
<td>Iterable getData()</td>
</tr>
<tr>
<td>Asynchronous</td>
<td><code>Future</code>&lt;T> getData()</td>
<td><code>Observable</code>&lt;T> getData()</td>
</tr>
</tbody>
</table>
<h2 id=reactive-extension>Reactive Extension</h2>
<p>reactive extension 의 용어들과 core concept 설명</p>
<h3 id=subscribing-to-notifications-from-observable>Subscribing to Notifications from Observable</h3>
<p>Subscribe 할 때는 3개의 콜백을 등록할 수 있음(onNext, onError, onCompleted)<br>
<code>onNext</code>* ( <code>onCompleted</code> | <code>onError</code> )? 로 요약 가능<br>
onNext 0개 이상 발행 후 onCompleted 나 onError 가 불릴 수 있음</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java>Observable<span style=color:#f92672>&lt;</span>Tweet<span style=color:#f92672>&gt;</span> tweets <span style=color:#f92672>=</span> <span style=color:#75715e>//..
</span><span style=color:#75715e></span>
<span style=color:#75715e>// Type A: lambda
</span><span style=color:#75715e></span>tweets<span style=color:#f92672>.</span><span style=color:#a6e22e>subscribe</span><span style=color:#f92672>(</span>
    <span style=color:#f92672>(</span>Tweet tweet<span style=color:#f92672>)</span> <span style=color:#f92672>-&gt;</span> <span style=color:#f92672>{</span>System<span style=color:#f92672>.</span><span style=color:#a6e22e>out</span><span style=color:#f92672>.</span><span style=color:#a6e22e>println</span><span style=color:#f92672>(</span>tweet<span style=color:#f92672>);},</span>
    <span style=color:#f92672>(</span>Throwable t<span style=color:#f92672>)</span> <span style=color:#f92672>-&gt;</span> <span style=color:#f92672>{</span>t<span style=color:#f92672>.</span><span style=color:#a6e22e>printStackTrace</span><span style=color:#f92672>();},</span>
    <span style=color:#f92672>()</span> <span style=color:#f92672>-&gt;</span> <span style=color:#f92672>{</span><span style=color:#66d9ef>this</span><span style=color:#f92672>.</span><span style=color:#a6e22e>noMore</span><span style=color:#f92672>();}</span>
<span style=color:#f92672>);</span>

<span style=color:#75715e>// Type B: method reference
</span><span style=color:#75715e></span>tweets<span style=color:#f92672>.</span><span style=color:#a6e22e>subscribe</span><span style=color:#f92672>(</span>
    System<span style=color:#f92672>.</span><span style=color:#a6e22e>out</span><span style=color:#f92672>::</span>println<span style=color:#f92672>,</span>
    Throwable<span style=color:#f92672>::</span>printStackTrace<span style=color:#f92672>,</span>
    <span style=color:#66d9ef>this</span><span style=color:#f92672>::</span>noMore<span style=color:#f92672>);</span>
</code></pre></div><p>아예 observer 객체를 따로 만들 수 있음</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java>Observer<span style=color:#f92672>&lt;</span>Tweet<span style=color:#f92672>&gt;</span> observer <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Observer<span style=color:#f92672>&lt;</span>Tweet<span style=color:#f92672>&gt;</span> <span style=color:#f92672>{</span>
    <span style=color:#75715e>// 가장 고전적인 방법
</span><span style=color:#75715e></span>    <span style=color:#a6e22e>@Override</span>
    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>onNext</span><span style=color:#f92672>(</span>Tweet tweet<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
        System<span style=color:#f92672>.</span><span style=color:#a6e22e>out</span><span style=color:#f92672>.</span><span style=color:#a6e22e>println</span><span style=color:#f92672>(</span>tweet<span style=color:#f92672>);</span>
    <span style=color:#f92672>}</span>

    <span style=color:#a6e22e>@Override</span>
    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>onError</span><span style=color:#f92672>(</span>Throwable e<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
        e<span style=color:#f92672>.</span><span style=color:#a6e22e>printStackTrace</span><span style=color:#f92672>();</span>
    <span style=color:#f92672>}</span>

    <span style=color:#a6e22e>@Override</span>
    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>onCompleted</span><span style=color:#f92672>()</span> <span style=color:#f92672>{</span>
        noMore<span style=color:#f92672>();</span>
    <span style=color:#f92672>}</span>
<span style=color:#f92672>}</span>
</code></pre></div><h3 id=controlling-listeners-by-using-subscription-and-subscribert>Controlling Listeners by Using Subscription and Subscriber</h3>
<p>observable - observer 관계를 Subscription 객체를 통해 알 수 있다.</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java>Subscription subscription <span style=color:#f92672>=</span> tweets<span style=color:#f92672>.</span><span style=color:#a6e22e>subscribe</span><span style=color:#f92672>(</span>System<span style=color:#f92672>.</span><span style=color:#a6e22e>out</span><span style=color:#f92672>::</span>println<span style=color:#f92672>);</span>
subscription<span style=color:#f92672>.</span><span style=color:#a6e22e>unsubscribe</span><span style=color:#f92672>();</span> <span style=color:#75715e>// 구독 취소할 수 있음
</span></code></pre></div><h3 id=creating-observable>Creating Observable</h3>
<p>앞에선 Observable::create 를 통해 observable 객체를 만듬<br>
미리 만들어 놓은 helper method 들이 있음</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java>Observable<span style=color:#f92672>.</span><span style=color:#a6e22e>just</span><span style=color:#f92672>(</span>value<span style=color:#f92672>)</span>
<span style=color:#75715e>/*
</span><span style=color:#75715e>    value 하나만 emit 하고 completed 되는 Observable
</span><span style=color:#75715e>*/</span>

Observable<span style=color:#f92672>.</span><span style=color:#a6e22e>from</span><span style=color:#f92672>(</span>value<span style=color:#f92672>)</span>
<span style=color:#75715e>/*
</span><span style=color:#75715e>    Just랑 비슷하지만, Iterable&lt;T&gt; 나 T[] 를 인풋으로 받아 순차적으로 emit 하고 complete 돠는 Observable
</span><span style=color:#75715e>*/</span>

Observable<span style=color:#f92672>.</span><span style=color:#a6e22e>range</span><span style=color:#f92672>(</span>from<span style=color:#f92672>,</span> n<span style=color:#f92672>)</span>
<span style=color:#75715e>/*
</span><span style=color:#75715e>    from 부터 시작해 n개의 integer를 emit 하고 complete 되는 observable
</span><span style=color:#75715e>*/</span>

Observable<span style=color:#f92672>.</span><span style=color:#a6e22e>empty</span><span style=color:#f92672>()</span>
<span style=color:#75715e>/*
</span><span style=color:#75715e>    바로 완료되는 observable
</span><span style=color:#75715e>*/</span>

Observable<span style=color:#f92672>.</span><span style=color:#a6e22e>never</span><span style=color:#f92672>()</span>
<span style=color:#75715e>/*
</span><span style=color:#75715e>    아무런 이벤트도 emit 하지 않는 observable
</span><span style=color:#75715e>*/</span>
Observable<span style=color:#f92672>.</span><span style=color:#a6e22e>error</span><span style=color:#f92672>()</span>
<span style=color:#75715e>/*
</span><span style=color:#75715e>    error를 바로 emit 하는 observable
</span><span style=color:#75715e>*/</span>
</code></pre></div><p>just 의 내부 구현을 생각해본다면..</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#66d9ef>static</span> <span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span> Observable<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span> just<span style=color:#f92672>&lt;</span>T x<span style=color:#f92672>&gt;</span> <span style=color:#f92672>{</span>
    <span style=color:#66d9ef>return</span> Observable<span style=color:#f92672>.</span><span style=color:#a6e22e>create</span><span style=color:#f92672>(</span>subscriber <span style=color:#f92672>-&gt;</span> <span style=color:#f92672>{</span>
        subscriber<span style=color:#f92672>.</span><span style=color:#a6e22e>onNext</span><span style=color:#f92672>(</span>x<span style=color:#f92672>);</span>
        subscriber<span style=color:#f92672>.</span><span style=color:#a6e22e>onCompleted</span><span style=color:#f92672>();</span>
    <span style=color:#f92672>});</span>
<span style=color:#f92672>}</span>
</code></pre></div><p>나머지 5개는 숙제~</p>
<h4 id=mastering-observablecreate>Mastering Observable.create()</h4>
<p>create 는 default sync. 이를 이용해 내부 동작을 더 잘 알아보자</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#75715e>// 로그용 함수
</span><span style=color:#75715e></span><span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>log</span><span style=color:#f92672>(</span>Object msg<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
    Ststem<span style=color:#f92672>.</span><span style=color:#a6e22e>out</span><span style=color:#f92672>.</span><span style=color:#a6e22e>println</span><span style=color:#f92672>(</span>Thread<span style=color:#f92672>.</span><span style=color:#a6e22e>getCurrentThread</span><span style=color:#f92672>().</span><span style=color:#a6e22e>getName</span><span style=color:#f92672>()</span> <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34;: &#34;</span> <span style=color:#f92672>+</span> msg<span style=color:#f92672>);</span>
<span style=color:#f92672>}</span>

log<span style=color:#f92672>(</span><span style=color:#e6db74>&#34;before&#34;</span><span style=color:#f92672>);</span>
Observable<span style=color:#f92672>.</span><span style=color:#a6e22e>range</span><span style=color:#f92672>(</span>5<span style=color:#f92672>,</span>3<span style=color:#f92672>).</span><span style=color:#a6e22e>subscribe</span><span style=color:#f92672>(</span>i <span style=color:#f92672>-&gt;</span> <span style=color:#f92672>{</span>
    log<span style=color:#f92672>(</span>i<span style=color:#f92672>);</span>
<span style=color:#f92672>});</span>
log<span style=color:#f92672>(</span><span style=color:#e6db74>&#34;after&#34;</span><span style=color:#f92672>)</span>


<span style=color:#75715e>/*
</span><span style=color:#75715e>결과
</span><span style=color:#75715e>main: before
</span><span style=color:#75715e>main: 5
</span><span style=color:#75715e>main: 6
</span><span style=color:#75715e>main: 7
</span><span style=color:#75715e>main: after
</span><span style=color:#75715e>*/</span>
</code></pre></div><p>만약 여러 subscriber 가 있다면?</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java>Observable<span style=color:#f92672>&lt;</span>Integer<span style=color:#f92672>&gt;</span> ints <span style=color:#f92672>=</span> 
    Observable<span style=color:#f92672>.</span><span style=color:#a6e22e>create</span><span style=color:#f92672>(</span>subscriber <span style=color:#f92672>-&gt;</span> <span style=color:#f92672>{</span>
        log<span style=color:#f92672>(</span><span style=color:#e6db74>&#34;create&#34;</span><span style=color:#f92672>);</span>
        subscriber<span style=color:#f92672>.</span><span style=color:#a6e22e>onNext</span><span style=color:#f92672>(</span>42<span style=color:#f92672>);</span>
        subscriber<span style=color:#f92672>.</span><span style=color:#a6e22e>onCompleted</span><span style=color:#f92672>();</span>
    <span style=color:#f92672>});</span>

log<span style=color:#f92672>(</span><span style=color:#e6db74>&#34;start&#34;</span><span style=color:#f92672>);</span>
ints<span style=color:#f92672>.</span><span style=color:#a6e22e>subscribe</span><span style=color:#f92672>(</span>i <span style=color:#f92672>-&gt;</span> log<span style=color:#f92672>(</span><span style=color:#e6db74>&#34;Element A: &#34;</span> <span style=color:#f92672>+</span> i<span style=color:#f92672>));</span>
ints<span style=color:#f92672>.</span><span style=color:#a6e22e>subscribe</span><span style=color:#f92672>(</span>i <span style=color:#f92672>-&gt;</span> log<span style=color:#f92672>(</span><span style=color:#e6db74>&#34;Element B: &#34;</span> <span style=color:#f92672>+</span> i<span style=color:#f92672>));</span>
log<span style=color:#f92672>(</span><span style=color:#e6db74>&#34;exit&#34;</span><span style=color:#f92672>);</span>

<span style=color:#75715e>/*
</span><span style=color:#75715e>결과
</span><span style=color:#75715e>main: start
</span><span style=color:#75715e>main: create
</span><span style=color:#75715e>main: Element A: 42
</span><span style=color:#75715e>main: create
</span><span style=color:#75715e>main: Element B: 42
</span><span style=color:#75715e>main: exit
</span><span style=color:#75715e>*/</span>
</code></pre></div><p>subscribe를 순차적으로 실행함을 알 수 있음</p>
<h2 id=operators-and-transformations>Operators and Transformations</h2>
<p>하이레벨 데이터 파이프 라이닝 방식을 알아 보자<br>
marble diagram 이란 것으로 스트림 파이프라이닝을 표현
<img src=https://github.com/sangmoon/TIL/raw/master/springStudy/resource/flip.png alt=flip></p>
<h3 id=core-operators-mapping-and-filteringflatmap>Core Operators: Mapping and Filtering(FlatMap)</h3>
<p>Stream API 와 아주 유사. 거의 같다고 볼 수 있다.</p>
<ul>
<li>관심 없는 이벤트가 있다면? filter를 사용하자</li>
</ul>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java>Observable<span style=color:#f92672>&lt;</span>String<span style=color:#f92672>&gt;</span> strings <span style=color:#f92672>=</span> someFileSource<span style=color:#f92672>.</span><span style=color:#a6e22e>lines</span><span style=color:#f92672>();</span>
Observable<span style=color:#f92672>&lt;</span>String<span style=color:#f92672>&gt;</span> comments <span style=color:#f92672>=</span> strings<span style=color:#f92672>.</span><span style=color:#a6e22e>filter</span><span style=color:#f92672>(</span>s <span style=color:#f92672>-&gt;</span> s<span style=color:#f92672>.</span><span style=color:#a6e22e>startWith</span><span style=color:#f92672>(</span><span style=color:#e6db74>&#34;#&#34;</span><span style=color:#f92672>));</span>
Observable<span style=color:#f92672>&lt;</span>String<span style=color:#f92672>&gt;</span> instructions <span style=color:#f92672>=</span> strings<span style=color:#f92672>.</span><span style=color:#a6e22e>filter</span><span style=color:#f92672>(</span>s <span style=color:#f92672>-&gt;</span> s<span style=color:#f92672>.</span><span style=color:#a6e22e>startWith</span><span style=color:#f92672>(</span><span style=color:#e6db74>&#34;&gt;&#34;</span><span style=color:#f92672>));</span>
Observable<span style=color:#f92672>&lt;</span>Empty<span style=color:#f92672>&gt;</span> empty <span style=color:#f92672>=</span> strings<span style=color:#f92672>.</span><span style=color:#a6e22e>filter</span><span style=color:#f92672>(</span>String<span style=color:#f92672>::</span>isBlank<span style=color:#f92672>);</span>
</code></pre></div><p><img src=https://github.com/sangmoon/TIL/raw/master/springStudy/resource/filter.png alt=filter></p>
<ul>
<li>변환을 시키려면 ? map 을 쓰자</li>
</ul>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java>Observable<span style=color:#f92672>&lt;</span>Tweets<span style=color:#f92672>&gt;</span> tweets <span style=color:#f92672>=</span> <span style=color:#75715e>//
</span><span style=color:#75715e></span>Observable<span style=color:#f92672>&lt;</span>Date<span style=color:#f92672>&gt;</span> dates <span style=color:#f92672>=</span> tweets<span style=color:#f92672>.</span><span style=color:#a6e22e>map</span><span style=color:#f92672>(</span>status <span style=color:#f92672>-&gt;</span> status<span style=color:#f92672>.</span><span style=color:#a6e22e>getCreatedAt</span><span style=color:#f92672>());</span> <span style=color:#75715e>// 변환 가능
</span><span style=color:#75715e></span>Observable<span style=color:#f92672>&lt;</span>Instant<span style=color:#f92672>&gt;</span> instants <span style=color:#f92672>=</span> tweeets<span style=color:#f92672>.</span><span style=color:#a6e22e>map</span><span style=color:#f92672>(</span>Status<span style=color:#f92672>::</span>getCreatedAt<span style=color:#f92672>).</span><span style=color:#a6e22e>map</span><span style=color:#f92672>(</span>Date<span style=color:#f92672>::</span>toInstant<span style=color:#f92672>);</span> <span style=color:#75715e>// chaining 도 물론 가능
</span></code></pre></div><p><img src=https://github.com/sangmoon/TIL/raw/master/springStudy/resource/map.png alt=map></p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#75715e>// 실행 결과는??
</span><span style=color:#75715e></span>Observable<span style=color:#f92672>.</span><span style=color:#a6e22e>just</span><span style=color:#f92672>(</span>8<span style=color:#f92672>,</span> 9<span style=color:#f92672>,</span> 10<span style=color:#f92672>)</span>
    <span style=color:#f92672>.</span><span style=color:#a6e22e>doOnNext</span><span style=color:#f92672>(</span>i <span style=color:#f92672>-&gt;</span> System<span style=color:#f92672>.</span><span style=color:#a6e22e>out</span><span style=color:#f92672>.</span><span style=color:#a6e22e>println</span><span style=color:#f92672>(</span><span style=color:#e6db74>&#34;A: &#34;</span> <span style=color:#f92672>+</span> i<span style=color:#f92672>))</span>
    <span style=color:#f92672>.</span><span style=color:#a6e22e>filter</span><span style=color:#f92672>(</span>i <span style=color:#f92672>-&gt;</span> i <span style=color:#f92672>%</span> 3 <span style=color:#f92672>&gt;</span> 0<span style=color:#f92672>)</span>
    <span style=color:#f92672>.</span><span style=color:#a6e22e>doOnNext</span><span style=color:#f92672>(</span>i <span style=color:#f92672>-&gt;</span> System<span style=color:#f92672>.</span><span style=color:#a6e22e>out</span><span style=color:#f92672>.</span><span style=color:#a6e22e>println</span><span style=color:#f92672>(</span><span style=color:#e6db74>&#34;B: &#34;</span> <span style=color:#f92672>+</span> i<span style=color:#f92672>))</span>
    <span style=color:#f92672>.</span><span style=color:#a6e22e>map</span><span style=color:#f92672>(</span>i <span style=color:#f92672>-&gt;</span> <span style=color:#e6db74>&#34;#&#34;</span> <span style=color:#f92672>+</span> i <span style=color:#f92672>*</span> 10<span style=color:#f92672>)</span>
    <span style=color:#f92672>.</span><span style=color:#a6e22e>doOnNext</span><span style=color:#f92672>(</span>i <span style=color:#f92672>-&gt;</span> System<span style=color:#f92672>.</span><span style=color:#a6e22e>out</span><span style=color:#f92672>.</span><span style=color:#a6e22e>println</span><span style=color:#f92672>(</span><span style=color:#e6db74>&#34;C: &#34;</span> <span style=color:#f92672>+</span> i<span style=color:#f92672>))</span>
    <span style=color:#f92672>.</span><span style=color:#a6e22e>filter</span><span style=color:#f92672>(</span>s <span style=color:#f92672>-&gt;</span> s<span style=color:#f92672>.</span><span style=color:#a6e22e>length</span><span style=color:#f92672>()</span> <span style=color:#f92672>&lt;</span> 4<span style=color:#f92672>);</span>

</code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#75715e>// 실행 결과는??
</span><span style=color:#75715e></span>Observable<span style=color:#f92672>.</span><span style=color:#a6e22e>just</span><span style=color:#f92672>(</span>8<span style=color:#f92672>,</span> 9<span style=color:#f92672>,</span> 10<span style=color:#f92672>)</span>
    <span style=color:#f92672>.</span><span style=color:#a6e22e>doOnNext</span><span style=color:#f92672>(</span>i <span style=color:#f92672>-&gt;</span> System<span style=color:#f92672>.</span><span style=color:#a6e22e>out</span><span style=color:#f92672>.</span><span style=color:#a6e22e>println</span><span style=color:#f92672>(</span><span style=color:#e6db74>&#34;A: &#34;</span> <span style=color:#f92672>+</span> i<span style=color:#f92672>))</span>
    <span style=color:#f92672>.</span><span style=color:#a6e22e>filter</span><span style=color:#f92672>(</span>i <span style=color:#f92672>-&gt;</span> i <span style=color:#f92672>%</span> 3 <span style=color:#f92672>&gt;</span> 0<span style=color:#f92672>)</span>
    <span style=color:#f92672>.</span><span style=color:#a6e22e>doOnNext</span><span style=color:#f92672>(</span>i <span style=color:#f92672>-&gt;</span> System<span style=color:#f92672>.</span><span style=color:#a6e22e>out</span><span style=color:#f92672>.</span><span style=color:#a6e22e>println</span><span style=color:#f92672>(</span><span style=color:#e6db74>&#34;B: &#34;</span> <span style=color:#f92672>+</span> i<span style=color:#f92672>))</span>
    <span style=color:#f92672>.</span><span style=color:#a6e22e>map</span><span style=color:#f92672>(</span>i <span style=color:#f92672>-&gt;</span> <span style=color:#e6db74>&#34;#&#34;</span> <span style=color:#f92672>+</span> i <span style=color:#f92672>*</span> 10<span style=color:#f92672>)</span>
    <span style=color:#f92672>.</span><span style=color:#a6e22e>doOnNext</span><span style=color:#f92672>(</span>i <span style=color:#f92672>-&gt;</span> System<span style=color:#f92672>.</span><span style=color:#a6e22e>out</span><span style=color:#f92672>.</span><span style=color:#a6e22e>println</span><span style=color:#f92672>(</span><span style=color:#e6db74>&#34;C: &#34;</span> <span style=color:#f92672>+</span> i<span style=color:#f92672>))</span>
    <span style=color:#f92672>.</span><span style=color:#a6e22e>filter</span><span style=color:#f92672>(</span>s <span style=color:#f92672>-&gt;</span> s<span style=color:#f92672>.</span><span style=color:#a6e22e>length</span><span style=color:#f92672>()</span> <span style=color:#f92672>&lt;</span> 4<span style=color:#f92672>)</span>
    <span style=color:#f92672>.</span><span style=color:#a6e22e>subscribe</span><span style=color:#f92672>(</span>i <span style=color:#f92672>-&gt;</span> System<span style=color:#f92672>.</span><span style=color:#a6e22e>out</span><span style=color:#f92672>.</span><span style=color:#a6e22e>println</span><span style=color:#f92672>(</span><span style=color:#e6db74>&#34;D: &#34;</span> <span style=color:#f92672>+</span> i<span style=color:#f92672>));</span>

<span style=color:#75715e>/*
</span><span style=color:#75715e>A: 8
</span><span style=color:#75715e>B: 8
</span><span style=color:#75715e>C: #80
</span><span style=color:#75715e>D: #80
</span><span style=color:#75715e>A: 9
</span><span style=color:#75715e>A: 10
</span><span style=color:#75715e>B: 10
</span><span style=color:#75715e>C: #100
</span><span style=color:#75715e>*/</span>
</code></pre></div><ul>
<li><code>flatMap</code> 아마.. 가장 중요한 메소드</li>
</ul>
<ol>
<li>map과 유사하지만, 새로운 Observable을 반환한다.</li>
<li>1의 특징 때문에 asynchronus fork-join 처럼 사용될 수 있다.(Observable은 asynchronous 작업을 뜻하기 때문)</li>
<li>내부 로직을 뜯어보면 각각 새로운 inner Observable을 생성하고(fork execution), inner Observable을 모두 구독하여 하나의 Stream 처럼 행동(join) 한다.</li>
</ol>
<p><img src=https://github.com/sangmoon/TIL/raw/master/springStudy/resource/flatmap.png alt=flatmap></p>
<p>flatmap 예시.. 차량 번호판 판독기를 만들고자 함</p>
<ul>
<li>고속도로 통과하는 차량 사진을 스트림으로 받음</li>
<li>비전 알고리즘을 돌려서 번호판만 따로 뽑아냄</li>
<li>판독에 실패 할 수도 있고, 어떤 경우에는 차 1대에서 2개의 번호판을 뽑아낼 수도 있음</li>
</ul>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java>Observable<span style=color:#f92672>&lt;</span>CarPhoto<span style=color:#f92672>&gt;</span> <span style=color:#a6e22e>cars</span><span style=color:#f92672>()</span> <span style=color:#f92672>{</span>
<span style=color:#75715e>// ...
</span><span style=color:#75715e></span><span style=color:#f92672>}</span>
Observable<span style=color:#f92672>&lt;</span>LicensePlate<span style=color:#f92672>&gt;</span> <span style=color:#a6e22e>recognize</span><span style=color:#f92672>(</span>CarPhoto car<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
<span style=color:#75715e>// ...
</span><span style=color:#75715e></span><span style=color:#f92672>}</span>
</code></pre></div><p>Observable 를 기본 data stream 으로 하면 다음과 같이 설계 가능</p>
<ul>
<li>사진에서 번호판 못 찾음(empty())</li>
<li>모듈에서 심각한 에러가 발생해 실패함(onError())</li>
<li>하나 이상의 번호판을 발견(onNext()* onComplete())</li>
</ul>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java>Observable<span style=color:#f92672>&lt;</span>CarPhoto<span style=color:#f92672>&gt;</span> cars <span style=color:#f92672>=</span> cars<span style=color:#f92672>();</span>

<span style=color:#75715e>// generic을 2번 해야함...
</span><span style=color:#75715e></span>Observable<span style=color:#f92672>&lt;</span>Observable<span style=color:#f92672>&lt;</span>LicensePlate<span style=color:#f92672>&gt;&gt;</span> plates <span style=color:#f92672>=</span> cars<span style=color:#f92672>.</span><span style=color:#a6e22e>map</span><span style=color:#f92672>(</span><span style=color:#66d9ef>this</span><span style=color:#f92672>::</span>recognize<span style=color:#f92672>);</span>

<span style=color:#75715e>// generic을 1번만 써도 됨!
</span><span style=color:#75715e></span>Observable<span style=color:#f92672>&lt;</span>LicensePlate<span style=color:#f92672>&gt;</span> plates2 <span style=color:#f92672>=</span> cars<span style=color:#f92672>.</span><span style=color:#a6e22e>flatMap</span><span style=color:#f92672>(</span><span style=color:#66d9ef>this</span><span style=color:#f92672>::</span>recognize<span style=color:#f92672>);</span>
</code></pre></div><ul>
<li>map 은 내부 Observable로 값을 감싼다.(이전 예제 에선 그냥 값을 반환하는 function 을 map에 사용해서 문제 없었음)</li>
<li>nested Observable은 가독성도 떨어지고, 문제가 많음</li>
<li>flatMap은 이를 해결할 수 있음</li>
</ul>
<p>이것 말고도 merge, zip collect, reduce, custom operator 등 많은데 시간 관계상 스킵</p>
<h2 id=applying-reactive-programming-to-existing-applications>Applying Reactive Programming to Existing Applications</h2>
<p>지금까지 single thread 로만 했으니 멀티 쓰레딩을 적용해보자</p>
<h3 id=imperative-concurrency>Imperative Concurrency</h3>
<p>보통의 enterprise 어플리케이션은 하나의 쓰레드가 하나의 요청을 수행함</p>
<ul>
<li>TCP 요청 받기</li>
<li>HTTP 요청 파싱</li>
<li>controller나 serlvet 호출</li>
<li>db call blocking</li>
<li>결과 계산</li>
<li>response 인코딩</li>
<li>raw bytes 클라이언트에 전송</li>
</ul>
<p>이게 thread 엄청 잡아먹으니&mldr; event-driven 나오게 되었음</p>
<p>예제 상황<br>
비행기 예매 시스템</p>
<ol>
<li>클라이언트가 clientID, 비행기ID 입력</li>
<li>승객, 비행기 각각 조회 후</li>
<li>비행기 예약하고</li>
<li>이메일로 티켓정보 보내줘야함</li>
</ol>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#75715e>// 고전적인 스타일
</span><span style=color:#75715e>// 모두 blocking job 이라 가정
</span><span style=color:#75715e></span>Flight <span style=color:#a6e22e>lookupFlight</span><span style=color:#f92672>(</span>String flightNo<span style=color:#f92672>);</span>   <span style=color:#75715e>// 비행기 조회
</span><span style=color:#75715e></span>Passenger <span style=color:#a6e22e>findPassenger</span><span style=color:#f92672>(</span><span style=color:#66d9ef>long</span> id<span style=color:#f92672>);</span>       <span style=color:#75715e>// 승객 조회
</span><span style=color:#75715e></span>Ticket <span style=color:#a6e22e>bookTicket</span><span style=color:#f92672>(</span>Flight flight<span style=color:#f92672>,</span> Passenger passenger<span style=color:#f92672>);</span> <span style=color:#75715e>// 티켓예매
</span><span style=color:#75715e></span>SmtpResponse <span style=color:#a6e22e>sendEmail</span><span style=color:#f92672>(</span>Ticket ticket<span style=color:#f92672>);</span>  <span style=color:#75715e>// 이메일 전송
</span><span style=color:#75715e></span>
<span style=color:#75715e>// client code
</span><span style=color:#75715e></span>Flight flight <span style=color:#f92672>=</span> lookupFlight<span style=color:#f92672>(</span><span style=color:#e6db74>&#34;KA 783&#34;</span><span style=color:#f92672>);</span>
Passenger passenger <span style=color:#f92672>=</span> findPassenger<span style=color:#f92672>(</span>42<span style=color:#f92672>);</span>
Ticket ticket <span style=color:#f92672>=</span> bookTicket<span style=color:#f92672>(</span>flight<span style=color:#f92672>,</span> passenger<span style=color:#f92672>);</span>
sendEmail<span style=color:#f92672>(</span>ticket<span style=color:#f92672>);</span>
</code></pre></div><p>다 블럭킹 메소드이기 때문에 순차적으로 진행. 몇몇 포인트 들이 보임</p>
<ul>
<li>비행기 조회와 승객 검색은 동시에 할 수 있음</li>
<li>예매는 앞의 2개 작업이 끝나야 함</li>
<li>예매의 결과 내보내는 작업과 email 전송은 동시에 진행할 수 있음</li>
</ul>
<p>이를 rx 스타일로 바꾸면?</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#75715e>// Observable wrapper
</span><span style=color:#75715e></span>Observable<span style=color:#f92672>&lt;</span>Flight<span style=color:#f92672>&gt;</span> <span style=color:#a6e22e>rxLookupFlight</span><span style=color:#f92672>(</span>String FlightNo<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
    <span style=color:#66d9ef>return</span> Observable<span style=color:#f92672>.</span><span style=color:#a6e22e>defer</span><span style=color:#f92672>(()</span> <span style=color:#f92672>-&gt;</span> <span style=color:#f92672>{</span>
        Observable<span style=color:#f92672>.</span><span style=color:#a6e22e>just</span><span style=color:#f92672>(</span>lookupFlight<span style=color:#f92672>(</span>flightNo<span style=color:#f92672>));</span>
    <span style=color:#f92672>});</span>
<span style=color:#f92672>}</span>

Observable<span style=color:#f92672>&lt;</span>Passenger<span style=color:#f92672>&gt;</span> <span style=color:#a6e22e>rxFindPassenger</span><span style=color:#f92672>(</span><span style=color:#66d9ef>long</span> id<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
    <span style=color:#66d9ef>return</span> Observable<span style=color:#f92672>.</span><span style=color:#a6e22e>defer</span><span style=color:#f92672>(()-&gt;</span> <span style=color:#f92672>{</span>
        Observable<span style=color:#f92672>.</span><span style=color:#a6e22e>just</span><span style=color:#f92672>(</span>findPassenger<span style=color:#f92672>(</span>id<span style=color:#f92672>));</span>
    <span style=color:#f92672>});</span>
<span style=color:#f92672>}</span>

<span style=color:#75715e>//client code
</span><span style=color:#75715e></span>Observable<span style=color:#f92672>&lt;</span>Flight<span style=color:#f92672>&gt;</span> flight <span style=color:#f92672>=</span> rxLookupFlight<span style=color:#f92672>(</span><span style=color:#e6db74>&#34;KA 783&#34;</span><span style=color:#f92672>);</span> <span style=color:#75715e>// 1
</span><span style=color:#75715e></span>Observable<span style=color:#f92672>&lt;</span>Passenger<span style=color:#f92672>&gt;</span> passenger <span style=color:#f92672>=</span> rxFindPassenger<span style=color:#f92672>(</span>42<span style=color:#f92672>);</span> 
Observable<span style=color:#f92672>&lt;</span>Ticket<span style=color:#f92672>&gt;</span> ticket <span style=color:#f92672>=</span> flight<span style=color:#f92672>.</span><span style=color:#a6e22e>zipWith</span><span style=color:#f92672>(</span>passenger<span style=color:#f92672>,</span> <span style=color:#f92672>(</span>f<span style=color:#f92672>,</span> p<span style=color:#f92672>)</span> <span style=color:#f92672>-&gt;</span> bookTicket<span style=color:#f92672>(</span>f<span style=color:#f92672>,</span> p<span style=color:#f92672>));</span> <span style=color:#75715e>//2
</span><span style=color:#75715e></span>ticket<span style=color:#f92672>.</span><span style=color:#a6e22e>subscribe</span><span style=color:#f92672>(</span><span style=color:#66d9ef>this</span><span style=color:#f92672>::</span>sendEmail<span style=color:#f92672>);</span> <span style=color:#75715e>//3
</span></code></pre></div><p>위 코드는 고전 스타일 코드와 결과적으로 동일하게 동작함.</p>
<ol>
<li>flight, passenger 의 Observable을 만듬.(defer를 썼기 때문에 blocking 작업도 lazy 하게 처리)</li>
<li>두 Observable을 zip 해서 예매하는 ticket Observable 생성
아직 까지 어떠한 콜백도 실행되지 않음</li>
<li><code>ticket.subscribe</code> 를 실행하는 순간 flight와 passenger도 자동적으로 구독하게 됨</li>
<li>우선 flight의 lookupFlight 메소드 실행됨</li>
<li>그리고 passenger 의 findPassenger 실행</li>
<li>이제 downstream으로 데이터가 내려와 bookTicket 실행</li>
<li>마지막으로 this::sendEmail 실행</li>
</ol>
<p>이제 conccurency 적용해보자</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#75715e>//client code
</span><span style=color:#75715e></span>Observable<span style=color:#f92672>&lt;</span>Flight<span style=color:#f92672>&gt;</span> flight <span style=color:#f92672>=</span> rxLookupFlight<span style=color:#f92672>(</span><span style=color:#e6db74>&#34;KA 783&#34;</span><span style=color:#f92672>).</span><span style=color:#a6e22e>subscribeOn</span><span style=color:#f92672>(</span>Scheduler<span style=color:#f92672>.</span><span style=color:#a6e22e>io</span><span style=color:#f92672>());</span> <span style=color:#75715e>//1
</span><span style=color:#75715e></span>Observable<span style=color:#f92672>&lt;</span>Passenger<span style=color:#f92672>&gt;</span> passenger <span style=color:#f92672>=</span> rxFindPassenger<span style=color:#f92672>(</span>42<span style=color:#f92672>).</span><span style=color:#a6e22e>subscribeOn</span><span style=color:#f92672>(</span>Scheduler<span style=color:#f92672>.</span><span style=color:#a6e22e>io</span><span style=color:#f92672>());</span> 
Observable<span style=color:#f92672>&lt;</span>Ticket<span style=color:#f92672>&gt;</span> ticket <span style=color:#f92672>=</span> flight<span style=color:#f92672>.</span><span style=color:#a6e22e>zipWith</span><span style=color:#f92672>(</span>passenger<span style=color:#f92672>,</span> <span style=color:#f92672>(</span>f<span style=color:#f92672>,</span> p<span style=color:#f92672>)</span> <span style=color:#f92672>-&gt;</span> bookTicket<span style=color:#f92672>(</span>f<span style=color:#f92672>,</span> p<span style=color:#f92672>));</span> 
ticket<span style=color:#f92672>.</span><span style=color:#a6e22e>subscribe</span><span style=color:#f92672>(</span><span style=color:#66d9ef>this</span><span style=color:#f92672>::</span>sendEmail<span style=color:#f92672>);</span> <span style=color:#75715e>//3
</span></code></pre></div><ol>
<li>subscribeOn 사용하면 Observable.create 가 실행되는 쓰레드를 설정할 수 있음..
결과는 같지만 concurrency 적용할 수 있다.</li>
</ol>
<h1 id=끝>끝</h1>
<h2 id=과제-어떻게-하지>과제 어떻게 하지&mldr;</h2>
<ol>
<li>rxJava로만 가능하게</li>
<li>배우진 않았지만 webflux 로..</li>
<li>rxNetty 활용한 서버로..?</li>
</ol>
<ul class=pa0>
</ul>
<div class="mt6 instapaper_ignoref">
</div>
</div>
<aside class="w-30-l mt6-l">
</aside>
</article>
</main>
<footer class="bg-black bottom-0 w-100 pa3" role=contentinfo>
<div class="flex justify-between">
<a class="f4 fw4 hover-white no-underline white-70 dn dib-ns pv2 ph3" href=https://sangmoon.github.io/TIL>
&copy; Sangmoon's TIL 2021
</a>
<div>
</div>
</div>
</footer>
</body>
</html>