<!doctype html><html lang=en-us>
<head>
<meta charset=utf-8>
<meta http-equiv=x-ua-compatible content="IE=edge,chrome=1">
<title>Sangmoon's TIL</title>
<meta name=viewport content="width=device-width,minimum-scale=1">
<meta name=description content="Thread 기본적으로 main thread 존재(java launcher에 의해 실행되는 사용자 thread. public static void miain(String[]) 실행)
시작 creator thread에서 start() 호출하면 새로 thread 만들어서 해당 thread에서 run() 실행
종료 run() method가 종료되면 thread가 종료
다른 방식으로 thread를 제어하는 method는 모두 금지
 stop() destroy() suspend() resume()  why? 쓰레드가 임의의 lock을 잡은 상태에서 stop하거나 suspend 했을 때 답이 없다. JVM이 오버헤드가 너무 커진다.
남은 방법은 interrupt를 해당 thread에 notification 하는 것 뿐.">
<meta name=generator content="Hugo 0.88.1">
<meta name=ROBOTS content="NOINDEX, NOFOLLOW">
<link rel=stylesheet href=/TIL/ananke/css/main.min.css>
<meta property="og:title" content>
<meta property="og:description" content="Thread 기본적으로 main thread 존재(java launcher에 의해 실행되는 사용자 thread. public static void miain(String[]) 실행)
시작 creator thread에서 start() 호출하면 새로 thread 만들어서 해당 thread에서 run() 실행
종료 run() method가 종료되면 thread가 종료
다른 방식으로 thread를 제어하는 method는 모두 금지
 stop() destroy() suspend() resume()  why? 쓰레드가 임의의 lock을 잡은 상태에서 stop하거나 suspend 했을 때 답이 없다. JVM이 오버헤드가 너무 커진다.
남은 방법은 interrupt를 해당 thread에 notification 하는 것 뿐.">
<meta property="og:type" content="article">
<meta property="og:url" content="https://sangmoon.github.io/TIL/posts/java/thread/"><meta property="article:section" content="posts">
<meta itemprop=name content>
<meta itemprop=description content="Thread 기본적으로 main thread 존재(java launcher에 의해 실행되는 사용자 thread. public static void miain(String[]) 실행)
시작 creator thread에서 start() 호출하면 새로 thread 만들어서 해당 thread에서 run() 실행
종료 run() method가 종료되면 thread가 종료
다른 방식으로 thread를 제어하는 method는 모두 금지
 stop() destroy() suspend() resume()  why? 쓰레드가 임의의 lock을 잡은 상태에서 stop하거나 suspend 했을 때 답이 없다. JVM이 오버헤드가 너무 커진다.
남은 방법은 interrupt를 해당 thread에 notification 하는 것 뿐.">
<meta itemprop=wordCount content="399">
<meta itemprop=keywords content><meta name=twitter:card content="summary">
<meta name=twitter:title content>
<meta name=twitter:description content="Thread 기본적으로 main thread 존재(java launcher에 의해 실행되는 사용자 thread. public static void miain(String[]) 실행)
시작 creator thread에서 start() 호출하면 새로 thread 만들어서 해당 thread에서 run() 실행
종료 run() method가 종료되면 thread가 종료
다른 방식으로 thread를 제어하는 method는 모두 금지
 stop() destroy() suspend() resume()  why? 쓰레드가 임의의 lock을 잡은 상태에서 stop하거나 suspend 했을 때 답이 없다. JVM이 오버헤드가 너무 커진다.
남은 방법은 interrupt를 해당 thread에 notification 하는 것 뿐.">
</head>
<body class="ma0 avenir bg-near-white">
<header>
<div class=bg-black>
<nav class="pv3 ph3 ph4-ns" role=navigation>
<div class="flex-l justify-between items-center center">
<a href=/TIL/ class="f3 fw2 hover-white no-underline white-90 dib">
Sangmoon's TIL
</a>
<div class="flex-l items-center">
</div>
</div>
</nav>
</div>
</header>
<main class=pb7 role=main>
<article class="flex-l flex-wrap justify-between mw8 center ph3">
<header class="mt4 w-100">
<aside class="instapaper_ignoref b helvetica tracked">
POSTS
</aside>
<div id=sharing class=mt3>
<a href="https://www.facebook.com/sharer.php?u=https://sangmoon.github.io/TIL/posts/java/thread/" class="facebook no-underline" aria-label="share on Facebook"><svg height="32" style="enable-background:new 0 0 67 67" viewBox="0 0 67 67" width="32" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><path d="M28.765 50.32h6.744V33.998h4.499l.596-5.624h-5.095l.007-2.816c0-1.466.14-2.253 2.244-2.253h2.812V17.68h-4.5c-5.405.0-7.307 2.729-7.307 7.317v3.377h-3.369v5.625h3.369V50.32zM33 64C16.432 64 3 50.569 3 34S16.432 4 33 4s30 13.431 30 30S49.568 64 33 64z" style="fill-rule:evenodd;clip-rule:evenodd"/></svg>
</a>
<a href="https://twitter.com/share?url=https://sangmoon.github.io/TIL/posts/java/thread/&text=" class="twitter no-underline" aria-label="share on Twitter"><svg height="32" style="enable-background:new 0 0 67 67" viewBox="0 0 67 67" width="32" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><path d="M37.167 22.283c-2.619.953-4.274 3.411-4.086 6.101l.063 1.038-1.048-.127c-3.813-.487-7.145-2.139-9.974-4.915l-1.383-1.377-.356 1.017c-.754 2.267-.272 4.661 1.299 6.271.838.89.649 1.017-.796.487-.503-.169-.943-.296-.985-.233-.146.149.356 2.076.754 2.839.545 1.06 1.655 2.097 2.871 2.712l1.027.487-1.215.021c-1.173.0-1.215.021-1.089.467.419 1.377 2.074 2.839 3.918 3.475l1.299.444-1.131.678c-1.676.976-3.646 1.526-5.616 1.568C19.775 43.256 19 43.341 19 43.405c0 .211 2.557 1.397 4.044 1.864 4.463 1.377 9.765.783 13.746-1.568 2.829-1.673 5.657-5 6.978-8.221.713-1.716 1.425-4.851 1.425-6.354.0-.975.063-1.102 1.236-2.267.692-.678 1.341-1.419 1.467-1.631.21-.403.188-.403-.88-.043-1.781.636-2.033.551-1.152-.402.649-.678 1.425-1.907 1.425-2.267.0-.063-.314.042-.671.233-.377.212-1.215.53-1.844.72l-1.131.361-1.027-.7c-.566-.381-1.361-.805-1.781-.932C39.766 21.902 38.131 21.944 37.167 22.283zM33 64C16.432 64 3 50.569 3 34S16.432 4 33 4s30 13.431 30 30S49.568 64 33 64z" style="fill-rule:evenodd;clip-rule:evenodd;fill:"/></svg>
</a>
<a href="https://www.linkedin.com/shareArticle?mini=true&url=https://sangmoon.github.io/TIL/posts/java/thread/&title=" class="linkedin no-underline" aria-label="share on LinkedIn"><svg height="32" style="enable-background:new 0 0 65 65" viewBox="0 0 65 65" width="32" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><path d="M50.837 48.137V36.425c0-6.275-3.35-9.195-7.816-9.195-3.604.0-5.219 1.983-6.119 3.374V27.71h-6.79c.09 1.917.0 20.427.0 20.427h6.79V36.729c0-.609.044-1.219.224-1.655.49-1.22 1.607-2.483 3.482-2.483 2.458.0 3.44 1.873 3.44 4.618v10.929H50.837zM22.959 24.922c2.367.0 3.842-1.57 3.842-3.531-.044-2.003-1.475-3.528-3.797-3.528s-3.841 1.524-3.841 3.528c0 1.961 1.474 3.531 3.753 3.531H22.959zM34 64C17.432 64 4 50.568 4 34 4 17.431 17.432 4 34 4s30 13.431 30 30c0 16.568-13.432 30-30 30zM26.354 48.137V27.71h-6.789v20.427h6.789z" style="fill-rule:evenodd;clip-rule:evenodd;fill:"/></svg>
</a>
</div>
<h1 class="f1 athelas mt3 mb1"></h1>
</header>
<div class="nested-copy-line-height lh-copy serif f4 nested-links nested-img mid-gray pr4-l w-two-thirds-l"><h1 id=thread>Thread</h1>
<p>기본적으로 <code>main</code> thread 존재(java launcher에 의해 실행되는 사용자 thread. public static void miain(String[]) 실행)</p>
<p>시작
creator thread에서 start() 호출하면 새로 thread 만들어서 해당 thread에서 run() 실행</p>
<p>종료
run() method가 종료되면 thread가 종료</p>
<p>다른 방식으로 thread를 제어하는 method는 모두 금지</p>
<ul>
<li>stop()</li>
<li>destroy()</li>
<li>suspend()</li>
<li>resume()</li>
</ul>
<p>why?
쓰레드가 임의의 lock을 잡은 상태에서 stop하거나 suspend 했을 때 답이 없다.
JVM이 오버헤드가 너무 커진다.</p>
<p>남은 방법은 interrupt를 해당 thread에 notification 하는 것 뿐.
사용자 코드에서 flag를 활용하여 직접 종료/일시중지/재개 등을 구현해야 한다.</p>
<p>java interrupt는 Object.wait(), Thread.sleep(), Thread.join() 을 깨울 수 있다.
InterruptedException이 발생하면서 해당 thread의 interrupted flag가 <code>clear</code> 된다.
(thread는 내부적으로 interrupted 당했는지 알고 있다) 다른 blocking operation 진행 중이었다면
interrupted flag가 <code>set</code> 된다. interruptible channel은 interrupt 되면 바로 종료하면서
ClosedByInterruptedException을 리턴하지만, 그렇지 않으면 계속 block 되어 있다.(flag만 <code>set</code> 되고)</p>
<blockquote>
<p>주의사항 : thread 에서 loop를 돌면 매번 flag를 체크해서 interrupted를 체크해야 한다.</p>
</blockquote>
<p>interrupt 상태 체크</p>
<ul>
<li>public static boolean interrupted(); 현재 쓰레드의 interrupted flag를 알려주고 reset</li>
<li>public boolean isInterrupted(); Thread 객체가 가리키는 thread의 현재 interrupted flag를 알려줌</li>
</ul>
<p>Thread의 상태</p>
<ul>
<li>NEW (start 호출 전)</li>
<li>RUNNABLE (run 실행 상태)</li>
<li>BLOCKED (synchronized lock을 기다리는 상태)</li>
<li>WAITING (Object.join, Thread.join, LockSupport.park 를 실행 중인 상태)</li>
<li>TIMED_WAITING (time 인자를 줘서 wait, join, park를 실행하였거나 thread.sleep 인 상태)</li>
<li>TERMINATED (thread가 종료한 상태)</li>
</ul>
<p>ContextClassLoader
thread 별로 특별한 의미를 가진 classLoader를 지정함
쓰레드를 만들 때 creator thread로 부터 copy(상속) 받음
main thread의 context classloader는 null
thread pool 을 고려한 api</p>
<p>Lock and Conditions
monitor 객체: lock &n unlock의 대상
wait으로 기다리고, notify로 wait하고 있는 놈 중 하나를 깨운다.</p>
<ol>
<li>interrupt 발생한 경우</li>
<li>notify 받는 경우</li>
<li>wait_timeout 발생시</li>
<li><code>spurious wakeup</code></li>
</ol>
<p>Spurious wakeup
notify가 없어도 wait이 깨어날 수 있다&mldr; 이 것을 대비해서 코드를 짜야한다.</p>
<p>Hotspot JVM에서 lock 구현
2-word object header(array는 3word)
1st word: mark word (unsed by sync, gc, cache and hashCode)</p>
<p>park, unpark
1bit의 state 갖는다. 알 필요가 있는가..?</p>
<p>Java memory model</p>
<ul>
<li>Atomicity
<ul>
<li>java long과 double 제외한 모든 data field 에 대한 update는 atomic</li>
<li>volatile 로 선언되면 모든 field가 atomic</li>
</ul>
</li>
<li>Visibility
<ul>
<li>한 쓰레드에서 이루어진 data field update를 다른 쓰레드에서 보는 걸 보장하려면</li>
<li>두 쓰레드가 lock 공유하거나</li>
<li>해당 필드가 volatile로 선언되거나</li>
<li>읽는 쓰레드가 해당 필드를 처음 접근할 때</li>
<li>thread가 종료될 때는 flush 되므로 join을 통해 기다리는 thread는 종료 thread의 write를 모두 읽을 수 있다.</li>
</ul>
</li>
<li>Ordering
<ul>
<li>lock 혹은 volatile을 제외하면 컴파일러에 의한 어떤 reordering도 가능</li>
</ul>
</li>
</ul>
<p>volatile
Volatile 필드에 접근하는 서로 다른 쓰레드들 간에 happens-before 관계가 성립해야함</p>
<ul>
<li>volatile 필드에 write하면 해당 쓰레드의 모든 변수들을 flush하는 효과가 있어야 함</li>
<li>volatile 필드에 read할 때에도 cache 값이 invalidate 되어야 함</li>
</ul>
<ul class=pa0>
</ul>
<div class="mt6 instapaper_ignoref">
</div>
</div>
<aside class="w-30-l mt6-l">
</aside>
</article>
</main>
<footer class="bg-black bottom-0 w-100 pa3" role=contentinfo>
<div class="flex justify-between">
<a class="f4 fw4 hover-white no-underline white-70 dn dib-ns pv2 ph3" href=https://sangmoon.github.io/TIL>
&copy; Sangmoon's TIL 2021
</a>
<div>
</div>
</div>
</footer>
</body>
</html>