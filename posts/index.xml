<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Posts on Sangmoon's TIL</title><link>https://sangmoon.github.io/TIL/posts/</link><description>Recent content in Posts on Sangmoon's TIL</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><atom:link href="https://sangmoon.github.io/TIL/posts/index.xml" rel="self" type="application/rss+xml"/><item><title/><link>https://sangmoon.github.io/TIL/posts/concurrency/ch02_thread_safety/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://sangmoon.github.io/TIL/posts/concurrency/ch02_thread_safety/</guid><description>쓰레드 안전성 객체의 상태(object&amp;rsquo;s state) = 인스턴스나 static 변수 같은 상태 변수에 저장된 객체의 데이터
공유되었다(shared) = 여러 쓰레드가 특정 변수에 접근할 수 있다
변경할 수 있다(mutable) = 해당 변수 값이 변경될 수 있다
쓰레드 안전성(Thread safety) = 데이터에 제한 없이 동시에 접근하는걸 막으려는 것
하나 이상의 쓰레드가 상태 변수에 접근하고, 하나라도 변수에 값을 쓰면 해당 변수에 접근할 때 관련 쓰레드는 동기화 사용해야 함</description></item><item><title/><link>https://sangmoon.github.io/TIL/posts/concurrency/ch12_pararrel_program_test/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://sangmoon.github.io/TIL/posts/concurrency/ch12_pararrel_program_test/</guid><description>Ch12 병렬 프로그램 테스트 정확성 테스트
원하는 동작을 항상 한다. 원치 않는 동작을 항상 안한다. 활동성 테스트
데드락 처리량(throughput) 응답성(responseiveness) 확장성(scalability) 12.1 정확성 테스트 설계대로 작동하는지 테스트 /* * 간단한 큐 구현(LinkedBlockingQueue나 ArrayBlockingQueue 하위 호환) */ public class BoundedBuffer&amp;lt;E&amp;gt; { private final Semaphore availableItems, availableSpaces; private final E[] items; private int putPosition = 0, takePosition = 0; public BoundedBuffer(int capacity) { availableItems = new Semaphore(0); availableSpaces = new Semaphore(capacity); items = (E[]) new Object[capacity]; } public boolean isEmpty() { return availableItems.</description></item><item><title/><link>https://sangmoon.github.io/TIL/posts/concurrency/ch16_java_memory_model/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://sangmoon.github.io/TIL/posts/concurrency/ch16_java_memory_model/</guid><description>ch16 자바 메모리 모델 16.1 자바 메모리 모델은 무엇이며, 왜 사용해야 할까? //특정 쓰레드에서 변수에 값을 할당 aVailable = 3; 자바 메모리 모델: &amp;ldquo;쓰레드가 aVariable에 할당도니 3이란 값을 사용할 수 있으려면 어떤 조건이 돼야 하는가?&amp;rdquo; 동기화 기법을 사용하지 않으면, 영언히 3을 읽어가지 못하는 여러 상황 존재.
컴파일러에서 소스코드에 적힌 내용을 명확하게 구현하는 코드를 생성 못할 가능성 변수 값을 메모리가 아닌 CPU 레지스터에 보관할 수 있음 CPU 프로세서는 프로그램을 순차실행 하거나, 병렬 실행할 수 있고 따라서 사용하는 캐시 형태에 다라 할당된 값이 메모리에 보관되는 시점에 차이가 있을 수 있으며 CPU 내부 캐시 값이 다른 CPU에는 안 보일 수 있다.</description></item><item><title/><link>https://sangmoon.github.io/TIL/posts/designpattern/behavioralpatterns/chain-of-responsibility/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://sangmoon.github.io/TIL/posts/designpattern/behavioralpatterns/chain-of-responsibility/</guid><description>Chain of responsibility 어떤 프로세스가 일어 났을때 그 책임을 적당한 대상한테 넘겨주게 됩니다. 이 패턴은 하나의 클래스의 인스턴스들 간의 체인이라기보다는 여러 클래스 간에 걸쳐 이루어지는 일이기 때문에 구조가 다른 클래스에 대해서 낮은 결합도로 동일한 이벤트에 대한 핸들링을 가능하게 한다는 점에서 주목할 만합니다. 사슬에 들어가는 객체를 바꾸거나 순서를 바꿈으로써 역할을 동적으로 추가/제거 할 수 있습니다.
Intent 둘 이상의 오브젝트에 요청을 처리 할 수있는 기회를 주면 요청 송신자와 수신자를 연결하지 마십시오. 수신 객체를 연결하고 객체가 처리 할 때까지 체인을 따라 요청을 전달합니다.</description></item><item><title/><link>https://sangmoon.github.io/TIL/posts/designpattern/behavioralpatterns/command/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://sangmoon.github.io/TIL/posts/designpattern/behavioralpatterns/command/</guid><description>Command Intent Implementation Consequences</description></item><item><title/><link>https://sangmoon.github.io/TIL/posts/designpattern/behavioralpatterns/interpreter/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://sangmoon.github.io/TIL/posts/designpattern/behavioralpatterns/interpreter/</guid><description/></item><item><title/><link>https://sangmoon.github.io/TIL/posts/designpattern/behavioralpatterns/iterator/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://sangmoon.github.io/TIL/posts/designpattern/behavioralpatterns/iterator/</guid><description>Iterator Intent 여러 객체들 간의 상호작용 자체를 encapsulation하는 객체를 정의한다. 객체들끼리 직접 참조하는 것을 피함으로써 객체들 간의 연결 강도를 줄인다. 객체들과 독립적으로 상호작용을 변경할 수 있다.
Implementation Consequences</description></item><item><title/><link>https://sangmoon.github.io/TIL/posts/designpattern/behavioralpatterns/mediator/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://sangmoon.github.io/TIL/posts/designpattern/behavioralpatterns/mediator/</guid><description/></item><item><title/><link>https://sangmoon.github.io/TIL/posts/designpattern/behavioralpatterns/memento/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://sangmoon.github.io/TIL/posts/designpattern/behavioralpatterns/memento/</guid><description>memento pattern Intent 예전 상태를 기억하기 용이한 패턴. 주로 현재 상태를 기억했다가 롤백이 필요한 시점에서 쉽게 돌아가는 방식이다. 바둑 장기등의 되돌리기, editor의 undo, browser의 뒤로가기 등이 있다.
참가자 : memento, originator, careTaker
originator: 객체 본래의 기능에 출실 memento: 내부 상태를 저장 careTaker: memento 들을 관리 Implementation public class Memento{ private String state; public Memento(String state){ this.state = state; } public String getState(){ return this.</description></item><item><title/><link>https://sangmoon.github.io/TIL/posts/designpattern/behavioralpatterns/observer/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://sangmoon.github.io/TIL/posts/designpattern/behavioralpatterns/observer/</guid><description>Observer Pattern Intent 상태를 가지고 있는 subject 와 변경을 알아야하는 observer 가 존재하며 이들의 관계는 1:1, 1:N 이 될수 있다. publisher-subscriber 관계라 볼 수 있다.
한 객체가 다른 객체에 의존적일 때 한 객체의 변화가 다른 객체의 변화를 일으킬 때 한객체가 다른객체에게 notify 날리고 싶을 때 Implementation public interface Subject{ public void attach(Observer observer); public void detach(Observer observer); public void notify(); } public interface Observer{ public void update(); } Consequences</description></item><item><title/><link>https://sangmoon.github.io/TIL/posts/designpattern/behavioralpatterns/state/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://sangmoon.github.io/TIL/posts/designpattern/behavioralpatterns/state/</guid><description/></item><item><title/><link>https://sangmoon.github.io/TIL/posts/designpattern/behavioralpatterns/strategy/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://sangmoon.github.io/TIL/posts/designpattern/behavioralpatterns/strategy/</guid><description/></item><item><title/><link>https://sangmoon.github.io/TIL/posts/designpattern/behavioralpatterns/template-method/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://sangmoon.github.io/TIL/posts/designpattern/behavioralpatterns/template-method/</guid><description/></item><item><title/><link>https://sangmoon.github.io/TIL/posts/designpattern/behavioralpatterns/visitor/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://sangmoon.github.io/TIL/posts/designpattern/behavioralpatterns/visitor/</guid><description/></item><item><title/><link>https://sangmoon.github.io/TIL/posts/designpattern/creationalpatterns/abstract-factory/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://sangmoon.github.io/TIL/posts/designpattern/creationalpatterns/abstract-factory/</guid><description>Abstract Factory Pattern Intent 관련성 있는 어려 종류의 객체를 특정 그룹으로 묶어 한번에 일관된 방식으로 생성하고 교체할 수 있도록 만든 디자인 패턴이다.
Implementation // factory method 사용할 경우 public enum VenderID{LG, SAMSUNG, APPLE} public class ScreenFactory{ public static Screen createScreen(VendorID vendorID){ Screen screen = null; switch(vendorID){ case LG: screen = new LGScreen(); break; case SAMSUNG: screen = new SAMSUNGScreen(); break; case APPLE: screen = new APPLEScreen(); } return screen; } } public class FrameFactory{ public static Frame createFrame(VendorID vendorID){ Frame frame = null; switch(vendorID){ case LG: frame = new LGFrame(); break; case SAMSUNG: frame = new SAMSUNGFrame(); break; case APPLE: frame = new APPLEFrame(); break; } return frame; } } public class client{ public static void main(String[] args){ Frame frame = FrameFactory.</description></item><item><title/><link>https://sangmoon.github.io/TIL/posts/designpattern/creationalpatterns/builder/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://sangmoon.github.io/TIL/posts/designpattern/creationalpatterns/builder/</guid><description>Builder Pattern Intent 인스턴스를 생성할 때 생성자 만을 통해서 생성하는데에는 어려움이 있다. 생성자 인자가 너무 많은 경우 어떠한 인자가 어떠한 값을 나타내는지 확인하기 힘들다. 또 어떠한 인스턴스는 특정인자만으로 생성해야 하는 경우가 발생한다. telescoping constructor pattern은 클래스가 지저분해진다. java bean pattern은 일관성이 깨지고, immutable한 객체 생성이 불가능하다.
Implementation telescoping constructor pattern 과 java bean pattern을 조합한다. 앱들이를 만드는 클래스를 생성한다.
//AppleMan.java public class AppleMan{ private String name; private int age; private String phone; private String notebook; private String tablet; public student(){} public static class Builder { private String name; private int age; private String phone; private String notebook; private String tablet; public Builder(String name, int age){ this.</description></item><item><title/><link>https://sangmoon.github.io/TIL/posts/designpattern/creationalpatterns/factory-method/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://sangmoon.github.io/TIL/posts/designpattern/creationalpatterns/factory-method/</guid><description>Factory method pattern Intent 객체 생성을 캡슐화 한다. client는 new라는 키워드를 사용하지 않고, 팩토리의 메소드를 호출하는 방식으로 객체를 받는다.
Implementation Consquences sub-class 에 hook을 제공한다. 참조 매개변수 팩토리 메소드의 형안정성</description></item><item><title/><link>https://sangmoon.github.io/TIL/posts/designpattern/creationalpatterns/prototype/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://sangmoon.github.io/TIL/posts/designpattern/creationalpatterns/prototype/</guid><description>Prototype Pattern</description></item><item><title/><link>https://sangmoon.github.io/TIL/posts/designpattern/creationalpatterns/readme/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://sangmoon.github.io/TIL/posts/designpattern/creationalpatterns/readme/</guid><description>##Creational Patterns
Creational Patterns은 생성 과정을 추상화합니다.이 방식은 시스템이 객체 생성, 연동, 표현 하는 방법에 독립적이게 합니다. class creational pattern은 상속을 사용하여 인스터스화된 클래스를 다양화 합니다. 반면 object creational pattern은 다른 객체에 인스턴스화를 위임합니다.
Abstact Factory Builder Factory method Prototype Singleton</description></item><item><title/><link>https://sangmoon.github.io/TIL/posts/designpattern/creationalpatterns/singleton/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://sangmoon.github.io/TIL/posts/designpattern/creationalpatterns/singleton/</guid><description>Singleton Pattern Intent Class에 대해 하나의 instance만 가지고 싶을 때&amp;hellip;
Implementation 기본구현 getInstance 를 synchronized로 구현 인스턴스를 처음부터 만들어버림 DCL을 활용하여 volatile 로 싱클톤 인스턴스 선언을 하고 getInstance에서 싱글톤 클래스를 synchronized 해서 동기화 한다. inner class 이용한다 public class Singleton { private static class SingletonHolder { public static final Singleton instance = new Singleton(); } public static Singleton getInstance() { return SingletonHolder.instance; } } Consequences</description></item><item><title/><link>https://sangmoon.github.io/TIL/posts/designpattern/structualpatterns/decorator/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://sangmoon.github.io/TIL/posts/designpattern/structualpatterns/decorator/</guid><description>Decorator Pattern Intent 상속을 받아 기능성을 확장하는 것 말고, 다른 방식으로 객체에 추가적 기능을 부여한다. (상속의 단점 보완)Wapper라고도 불린다. 직장인 클래스를 기준으로 해보자&amp;hellip;
Implementation public interface Employee{ public int getSalary(); } public class Researcher implements Employee{ private int year; @Override public int getSalary(){ return 10 + year; } } abstract public class EmployeeDecorator implements Employee{ protected Emplyee decoratedEmployee; public EmplyeeDecorator(Employee decoratedEmployee){ this.decoratedEmplyee = decoratedEmployee; } public int getSalary(){ return decoratedEmployee.</description></item><item><title/><link>https://sangmoon.github.io/TIL/posts/designpattern/structualpatterns/proxy/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://sangmoon.github.io/TIL/posts/designpattern/structualpatterns/proxy/</guid><description>Proxy Pattern Intent 일반적으로 프록시는 다른 무언가와 이어지는 인터페이스의 역할을 하는 클래스이다. 프록시는 어떠한 것(이를테면 네트워크 연결, 메모리 안의 커다란 객체, 파일, 또 복제할 수 없거나 수요가 많은 리소스)과도 인터페이스의 역할을 수행 할 수 있다.
참가자 : client, subject, real subject, proxy
같은 인터페이스를 상속 받기 때문에 실제 client는 real subject와 proxy 를 구분하지 않는다.
proxy 는 real subject에 대한 reference를 가지고 있다.</description></item><item><title/><link>https://sangmoon.github.io/TIL/posts/django/django-urlconf/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://sangmoon.github.io/TIL/posts/django/django-urlconf/</guid><description>django2.0 부터 path, re_path 함수로 라우팅을 한다.
(django_docs_link)[https://docs.djangoproject.com/en/2.0/topics/http/urls/#how-django-processes-a-request]
from django.conf.urls import path, re_path from . import views urlpatterns = [ path(&amp;#39;index/&amp;lt;int:index_id&amp;gt;&amp;#39;, views.index, name=&amp;#39;index&amp;#39;), re_path(r&amp;#39;^index/(?P&amp;lt;index_id&amp;gt;\d+)/$&amp;#39;), ] 위의 path()와 re_path는 같은 url을 나타낸 것이다. path에서는 정규식을 명시적으로 사용하지 않고 &amp;lt;&amp;gt; 로 단순한 패턴들을 매칭한다. int, str,slug, uuid, path 가 default path converter 이다. custom conveter 도 등록 가능하다. re_path의 경우 기존 urls.url 함수의 이름이 바뀐 것이다. 정규식으로 패턴을 표현한다.</description></item><item><title/><link>https://sangmoon.github.io/TIL/posts/django/request-post/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://sangmoon.github.io/TIL/posts/django/request-post/</guid><description>view에서 user의 request를 보통 GET 과 POST로 받는다. browser에서 ajax POST request를 보낼 때 request.POST로 받으면 될 거라고 생각했는데, request.body로 바로 접근해야 한다. django에서 request.POST는 form data 같은 걸 받을 때 사용하는 것이다.</description></item><item><title/><link>https://sangmoon.github.io/TIL/posts/docker/docker-cmd/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://sangmoon.github.io/TIL/posts/docker/docker-cmd/</guid><description>docker의 기본 명령어를 정리하자 도커 이미지 빌드
docker build -t cholsoo22001/orly . container 실행
docker run \ --env AZURE_ACCOUNT_NAME=&amp;#34;&amp;#34; \ --env AZURE_ACCOUNT_KEY=&amp;#34;&amp;#34; \ -p 8080:8080 \ cholsoo22001/orly Docker Hub에 이미지 배포
docker push cholsoo22001/orly Docker images 확인
docker images Docker image 삭제
docker rmi [image id] 모든 Container 확인
docker ps -a Container 삭제
docker rm [container id | container name] Container shell로 들어가기
docker exec -it [container id| container name] /bin/bash</description></item><item><title/><link>https://sangmoon.github.io/TIL/posts/effectivejava/classesandinterfaces/item15/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://sangmoon.github.io/TIL/posts/effectivejava/classesandinterfaces/item15/</guid><description>Item 15: Minimize the accessibility of classess and members 잘 설계된 컴포넌트는 상세 구현을 숨기고 API와 완벽히 분리해야 한다. Information hiding or encapsulation 으로 알려진 이 생각은 소프트웨어 디자인의 기본이다.
캡슐화의 장점 병렬 개발을 통한 개발 속도 증가 독립적인 컴포넌트 분리로 인한 관리 비용 감소 성능 최적화에 도움 재사용성 증가 제작 난이도 감소 룰은 간단하다. 모든 클래스와 멤버의 접근성을 가능한 한 좁혀야 한다.
java에서 가능한 access level private: 멤버들은 오직 해당 클래스에서만 접근 가능하다 package-private: 멤버는 해당 클래스가 선언되어 있는 패키지에서 접근 가능하다(접근자를 안쓰면 되는데, interface는 기본 public 이라 예외) protected: 패키지 내와 상속받은 클래스에서만 접근 가능하다 public: 어디서든 접근 가능하다 total In the class Same package Extended class Another area private O X X X package-private O O X X protected O O O X public O O O O public class의 객체 필드는 public 이어선 안 된다.</description></item><item><title/><link>https://sangmoon.github.io/TIL/posts/effectivejava/classesandinterfaces/item16/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://sangmoon.github.io/TIL/posts/effectivejava/classesandinterfaces/item16/</guid><description>Item 16: In public classes, use accessor methods, not public fields 가끔 필드 조합의 모음 정도의 클래스를 쓸 때가 있다.
class Point { public double x; public double y; } 이 때 필드는 public 이어선 안된다. 필드에 직접 접근이 가능해서 캡슐화의 이점을 전혀 얻을 수 없다. API를 바꾸지 않고는 아무것도 변경할 수 없다. getter와 setter로 바꿔야 한다.
class Point { private double x; private double y; public Point(double x, double y) { this.</description></item><item><title/><link>https://sangmoon.github.io/TIL/posts/effectivejava/classesandinterfaces/item17/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://sangmoon.github.io/TIL/posts/effectivejava/classesandinterfaces/item17/</guid><description>Item 17: Minimize mutability immutable class 는 변경될 수 없는 인스턴스들의 클래스 이다. String, boxed primitive type, BigInteger 나 BigDecimal 등이 immutable class의 예이다. mutable class 보다 설계하기 쉽고 에러도 적고 더 안전하다.
immutable class 만들기 위한 규칙 객체의 상태를 바꾸는 메소드(Mutator)를 제공하지마라 클래스를 상속할 수 없게 만들어라 모든 필드를 final로 선언해라 모든 필드를 private로 만들어라. mutable object에 대한 접근 제한을 확실히 해라. 클래스가 mutable object 가지고 있으면 client는 절대 접근할 수 없게 해야 한다.</description></item><item><title/><link>https://sangmoon.github.io/TIL/posts/effectivejava/classesandinterfaces/item18/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://sangmoon.github.io/TIL/posts/effectivejava/classesandinterfaces/item18/</guid><description>Item 18: 상속보다는 컴포지션을 사용해라 상속은 캡슐화를 깨뜨린다. 상위 클래스 구현에 따라 하위 클래스의 동작이 이상해 질 수 있다.
상속 사용 public class InstrumentedHashSet&amp;lt;E&amp;gt; extends HashSet&amp;lt;E&amp;gt; { private int addCount = 0; public InstrumentedHashSet() {} public InstrumentedHashSet(int initCap, float loadFactor) { super(initCap, loadFactor); } @Override public boolean add(E e) { addCount++; return super.add(e); } @Override public boolean addAll(Collection&amp;lt;? extends E&amp;gt; c) { addCount += c.size(); return super.addAll(c); } public int getAddCount() { return addCount; } InstrumentedHashSet&amp;lt;Stirng&amp;gt; s = new InstrumentedHashSet&amp;lt;&amp;gt;(); s.</description></item><item><title/><link>https://sangmoon.github.io/TIL/posts/effectivejava/classesandinterfaces/item19/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://sangmoon.github.io/TIL/posts/effectivejava/classesandinterfaces/item19/</guid><description>Item 19: 상속을 고려해 설계하고 문서화해라. 그러지 않았다면 상속을 금지하라 상속용 클래스는 재정의할 수 있는 메서드들을 내부적으로 어덯게 이용하는지 문서로 남겨야 한다. 클래스를 안전하게 상속할 수 있도록 하려면 내부 구현 방식을 설명해야 한다.
상속용 클래스를 시험하는 방법은 직접 하위 클래스를 만들어보는 것이 &amp;lsquo;유일&amp;rsquo;하다.
상속용 클래스의 생성자는 재정의 가능 메서드를 호출해서는 안 된다 // 상속 시 문제 발생 가능한 클래스 public class Super { public Super() { overrideMe(); } public void overrideMe() {} } public final class Sub extendss Super { private final Instant instant; Sub() { instant = Instant.</description></item><item><title/><link>https://sangmoon.github.io/TIL/posts/effectivejava/classesandinterfaces/item20/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://sangmoon.github.io/TIL/posts/effectivejava/classesandinterfaces/item20/</guid><description>Item 20: 추상 클래스보다는 인터페이스를 우선하라 추상 클래스는 1개만 상속 가능하지만, 인터페이스는 여러개 구현할 수 있다.
기존 클래스에도 손쉽게 새로운 인터페이스를 구현해넣을 수 있다. 인터페이스는 Mixin 정의에 안성맞춤이다. 인터페이스는 계층 구조가 없는 타입 프레임워크를 만들 수 있다. public interface Singer { AutidoCLip sing(Song s); } public interface Songwriter { Song compose(int chartPosition); } public interface SingerSongWriter extends Singer, SongWriter { AudioCLip strum(); void actSensitive(); } Default Method Interface 의 default method 를 사용하려면, 꼭 @implSpec 을 붙여서 문서화해야 한다.</description></item><item><title/><link>https://sangmoon.github.io/TIL/posts/effectivejava/classesandinterfaces/item21/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://sangmoon.github.io/TIL/posts/effectivejava/classesandinterfaces/item21/</guid><description>Item21: 인터페이스는 구현하는 쪽을 생각해서 설계해라 모든 상황에서 불변식을 해치지 않은 default 메소드는 작성하기 어렵다 // Java8 에 추가된 Collection dml removeIf default boolean removeIf(Predicate&amp;lt;? super E&amp;gt; filter) { Objects.requireNonNull(filter); boolean result = false; for (Iterator&amp;lt;E&amp;gt; it = iterator(); it.hashNext();) { if (filter.test(it.next())) { it.remove(); result = true; } } return result; } 굉장히 범용적이지만 못 쓰는 경우도 있다. (ex) 아파치의 SynchronizedCollection)
컴파일 에러가 발생하지 않아도 런타임 에러가 발생할 수도 있다.</description></item><item><title/><link>https://sangmoon.github.io/TIL/posts/effectivejava/classesandinterfaces/item22/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://sangmoon.github.io/TIL/posts/effectivejava/classesandinterfaces/item22/</guid><description>Item22: 인터페이스는 타입을 정의하는 용도로만 사용하라 클래스가 인터페이스를 구현한다는 것은 자신의 인스턴스로 무엇을 할 수 있는지 클라이언트에게 알려주는 것.
Anti Pattern: 상수 인터페이스
public interface PhysicalConstants { static final double AVOGADROS_NUMBER = 6.022_140_857e23; } 상수는 외부 인터페이스가 아니고 내부 구현이다.
만약 클라이언트가 이런 상수들을 쓰고 있다면, 인터페이스에서 지우지도 못하게 된다.
이런 경우에는
클래스 자체에 추가한다(책에는 클래스나 인터페이스 자체에 추가한다&amp;hellip; 는데 번역 오류인가..?) ENUM 을 사용한다(Item 34) 인스턴스화 못하는 유틸 클래스를 사용한다 public class PhysicalConstants { private PhysicalConstants() {} public static final double AVOGADROS_NUMBER = 6.</description></item><item><title/><link>https://sangmoon.github.io/TIL/posts/effectivejava/classesandinterfaces/item23/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://sangmoon.github.io/TIL/posts/effectivejava/classesandinterfaces/item23/</guid><description>Item23: 태그 달린 클래스보다는 클래스 계층구조를 활용하라 태그 달린 클래스가 뭐야? -&amp;gt; 두가지 이상의 기능을 커버하는 클래스
안 좋은 이유
생성자 여러개 불필요한 필드 많음 객체 지향적이지 않음 반복코드 많음 메모리 낭비 가독성도 아웃 태그 달린 클래스는 클래스 계층구조를 어설프게 흉내낸 아류
태그에 따라 달라지는 동작은 추상 클래스의 추상 메소드로 선언 태그와 관계없이 같은 메소드는 추상 클래스의 일반 메소드로 선언
요약 태그 달린 클래스가 보이면 리팩토링을 고려하자</description></item><item><title/><link>https://sangmoon.github.io/TIL/posts/effectivejava/classesandinterfaces/item24/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://sangmoon.github.io/TIL/posts/effectivejava/classesandinterfaces/item24/</guid><description>Item24: 멤버 클래스는 되도록 static 으로 만들어라 중첩 클래스는 다음 4개가 존재
static member class member class anonymous class local class static Member Class 클래스 안에 선언되고, 바깥 클래스 private 멤버 접근 가능. 보통 public 도우미 클래스로 쓰임
(Non-static) Member Class 바깥 클래스 인스턴스와 암묵적으로 연결되어 있음. 정규화된 this 로 참조 가능.
class A { public class C { public void run() { System.out.println(&amp;#34;Run C: &amp;#34; + A.this.a); } } 어댑터 패턴에서 자주 쓰임</description></item><item><title/><link>https://sangmoon.github.io/TIL/posts/effectivejava/classesandinterfaces/item25/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://sangmoon.github.io/TIL/posts/effectivejava/classesandinterfaces/item25/</guid><description>Item25: 톱레벨 클래스는 한 파일에 하나만 담으라 한 파일에 여러 톱 클래스가 있으면 컴파일 순서에 따라 이상한 결과 초래 가능(IDE 에서 이미 경고 할 듯)
해결책은 하나 파일엔 하나의 톱 클래스만 정의하자. 굳이 하고 싶다면 static member class 써보자.</description></item><item><title/><link>https://sangmoon.github.io/TIL/posts/effectivejava/creatinhanddestoryinhobjects/item1/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://sangmoon.github.io/TIL/posts/effectivejava/creatinhanddestoryinhobjects/item1/</guid><description>Item 1: Consider static factory methods instead of constructors 기본적으로 클라이언트는 어떤 객체의 퍼블릭 생성자를 얻을 수 있다. 하지만 static factory method를 제공할 수도 있다.
// Boolean Class 에서 사용하는 static factory method 예제 public static Boolean vaoueOf(boolean b) { return b ? Boolean.TRUE: Boolean.FALSE; } static factory method와 Factory Method Pattern은 다르니 주의!
이제 클라이언트에게 퍼블릭 생성자를 주는 대신, 팩토리 메서드를 제공한다.
장점
생성자와 다르게 이름이 있다.</description></item><item><title/><link>https://sangmoon.github.io/TIL/posts/effectivejava/creatinhanddestoryinhobjects/item2/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://sangmoon.github.io/TIL/posts/effectivejava/creatinhanddestoryinhobjects/item2/</guid><description>Item 2 Consider a builder when faced with many constructor parameters Static factory 와 constructor 는 같은 문제를 공유한다 - 많은 수의 optional parameter를 처리 하기 힘들다. 전통적으로 많은 파라미터를 같는 경우 telescoping constructor 패턴이 사용된다.
// Telescoping constructor pattern - scale을 키우기 쉽지 않다 public class NutritionFacts { private final int servingSize; private final int servings; private final int calories; private final int fat; private final int sodium; private final int carbohydrate; public NutritionFacts(int servingSize, int servings) { this(servingSize, servings, 0); } public NutritionFacts(int servingSize, int servings, int calories) { this(servingSize, servings, calories, 0); } public NutritionFacts(int servingSize, int servings, int calories, int fat) { this(servingSize, servings, calories, fat, 0); } public NutritionFacts(int servingSize, int servings, int calories, int fat, int sodium) { this(servingSize, servings, calories, fat, sodium, 0); } public NutritionFacts(int servingSize, int servings, int calories, int fat, int sodium, int carbohydrate) { this.</description></item><item><title/><link>https://sangmoon.github.io/TIL/posts/effectivejava/creatinhanddestoryinhobjects/item3/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://sangmoon.github.io/TIL/posts/effectivejava/creatinhanddestoryinhobjects/item3/</guid><description>Item 3 Enforce the singleton property with a private constructor or an enum type 싱글톤은 오직 단 1번만 생성되는 객체이다. 상태가 없는 function(Item 24) 나 시스템 컴포넌트가 여기에 해당한다. 싱클톤은 Mock을 만들기 어렵기 때문에 테스트 하기에 어려운 점이 있다.
보통 2가지 방식이 존재한다. 둘 다 생성자를 private으로 보호하고, 접근자를 public하게 만들어 유일한 객체에 접근하도록 허용한다.
// 인스턴스를 final로 해 접근하는 방식 public class Elvis { public static final Elvis INSTANCE = new Elvis(); private Elvis() {} } protected나 public 생성자가 없기 때문에 elvis 객체는 오직 1번만 클래스가 초기화 될 때 생성됨을 보장한다.</description></item><item><title/><link>https://sangmoon.github.io/TIL/posts/effectivejava/creatinhanddestoryinhobjects/item4/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://sangmoon.github.io/TIL/posts/effectivejava/creatinhanddestoryinhobjects/item4/</guid><description>Item 4 Enforce noninstantiability with a private constructor 유틸 클래스들처럼 객체화 시키고 싶지 않은 클래스를 원할 때가 있다. 하지만 명시적 생성자가 없으면 컴파일러는 public default 생성자를 만들어준다. 따라서 private 생성자를 명시적으로 넣으므로써 이를 방지할 수 있다.
public class UtilityClass { private UtilityClass() { throw new AssertionError(); } } 부과 효과로 이런 방식은 상속을 불가능하게 만든다. 모든 생성자는 부모 생성자를 호출해야 하기 때문에, private 생성자에 접근할 방법이 없다.</description></item><item><title/><link>https://sangmoon.github.io/TIL/posts/effectivejava/creatinhanddestoryinhobjects/item5/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://sangmoon.github.io/TIL/posts/effectivejava/creatinhanddestoryinhobjects/item5/</guid><description>Item 5 Prefer dependency injection to hardwiring resources Static utility 클래스와 싱글톤은 리소스에 따라 달라져야하는 클래스에는 적합하지 않다. static utility 와 싱글톤은 테스트와도 어울리지 않는다. 바람직한 방식은 생성자에 인자로써 건내주는 것이다. 이는 Dependency Injection의 한 형태이다.
// static utility public class SpellChecker { private static final Lexicon dictionary = ...; private SpellChecker(){} } // singleton public class SpellChecker { private final Lexicon dictionary = ...; private SpellChecker(){} public static INSTANCE = new SpellChecker(.</description></item><item><title/><link>https://sangmoon.github.io/TIL/posts/effectivejava/creatinhanddestoryinhobjects/item6/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://sangmoon.github.io/TIL/posts/effectivejava/creatinhanddestoryinhobjects/item6/</guid><description>Item 6 Avoid creating unnecessary objects 기능적으로 동일한 객체를 매번 생성하는 것 보다 객체 하나를 재사용하는게 적절한 상황이 있다. 재사용은 더 빠르고 읽기 쉽다. immutable(Item 17) 해야만 재사용 할 수 있다.
String s = new String(&amp;#34;bikini&amp;#34;); //제발 이렇게 사용하지 말 것! 위 처럼 하게 되면 매번 새로운 String 객체를 생성하게 된다.
String s = &amp;#34;bikini&amp;#34;; 이 버전은 같은 string literal은 매번 같은 객체를 사용함을 JVM이 보장한다.
특히 다른 객체보다 만들 때 자원을 더 소모하는 녀석들을 expensive object 라고 한다.</description></item><item><title/><link>https://sangmoon.github.io/TIL/posts/effectivejava/creatinhanddestoryinhobjects/item7/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://sangmoon.github.io/TIL/posts/effectivejava/creatinhanddestoryinhobjects/item7/</guid><description>Eliminate obsolete object references pubic class Stack { private Object[] elements; private int size=0; private static final int DEFAULT_INITIAL_CAPACITY = 16; public Stack() { elements = new Object[DEFAULT_INITIAL_CAPACITY]; } public void push(Object e) { ensureCapacity(); elements[size++] = e; } public Object pop() { if(size == 0) { thorw new EmptyStackException(); } return elements[--size]; } private void ensureCapacity() { if(elements.length == size) { elements = Arrays.copyOf(elements, 2* size + 1); } } } 문제가 없어보이지만, pop 하고 난 후 내보낸 객체에 대한 reference를 stack이 갖고 있는게 문제다.</description></item><item><title/><link>https://sangmoon.github.io/TIL/posts/effectivejava/creatinhanddestoryinhobjects/item8/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://sangmoon.github.io/TIL/posts/effectivejava/creatinhanddestoryinhobjects/item8/</guid><description>Item 8: Avoid finalizers and cleaners Finalizer 와 Cleaner 쓰지 말자</description></item><item><title/><link>https://sangmoon.github.io/TIL/posts/effectivejava/creatinhanddestoryinhobjects/item9/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://sangmoon.github.io/TIL/posts/effectivejava/creatinhanddestoryinhobjects/item9/</guid><description>Item 9: Prefer try-with-resources to try-finally InputStream이나 sql.Connection 등은 close() 를 꼭 불러주어야 한다. 전통적으로는 try, catch 문이 이를 지원하였다.
static String firstLineOfFile(String path) throws IOException { BufferedReader br = new BufferedReader(new FileReader(path)); try { return br.readLine(); } finally { br.close(); } } 하지만 자원이 여러개가 되면 굉장히 이상해진다.
static void copy(String src, String dst) throws IOException { InputStream in = new FileStream(src); try { OutputStream out = new FileOutputStream(dst); try { byte[] buf = new byte[BUFFER_SIZE]; int n; while((n = in.</description></item><item><title/><link>https://sangmoon.github.io/TIL/posts/effectivejava/generalprogramming/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://sangmoon.github.io/TIL/posts/effectivejava/generalprogramming/</guid><description>일반적인 프로그래밍 원칙들 규칙 53 리플렉션 대신 인터페이스를 이용하라 java.lang.reflect 를 활용하면 클래스 정보를 런타임에 가져 올 수 있다.
Class 객체를 통해 생성자(Constructor), 메서드(Method), 필드(Field) 객체를 가져올 수 있다 멤버 이름, 필드 자료형, 메서드 시그니처 들을 알 수 있다. 객체를 생성할 수도 있고, 메서드를 호출할 수도 있으며 필드에 접근할 수도 있다. 단점도 많다.
컴파일 시점에서 자료형 검사함으로써 얻는 이점을 모두 포기해야 한다 (존재하지 않는, 접근 할 수 없는 method 호출하면 런타임 오류 발생) 리플렉션 코드는 보기 싫고 장황하다.</description></item><item><title/><link>https://sangmoon.github.io/TIL/posts/effectivejava/generic/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://sangmoon.github.io/TIL/posts/effectivejava/generic/</guid><description>Generics 2판의 경우 27, 28 ,29 로 되어 있음 Item 30: Favor generic methods 가능하면 제네릭 메서드로 만들 것 클래스가 generic 일 수 있는 것 처럼 method 도 generic 할 수 있음 예를 들어 collections 에 있는 알고리즘 관련 method(sort, binarysearch) 는 generic 하다.
// use raw types - 문제 있음 public static Set union(Set s1, Set s2) { // Warning! HashSet(Collection&amp;lt;? extends E&amp;gt;) Set result = new HashSet(s1); // Warning!</description></item><item><title/><link>https://sangmoon.github.io/TIL/posts/effectivejava/lambdasandstreams/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://sangmoon.github.io/TIL/posts/effectivejava/lambdasandstreams/</guid><description>Chapter 7 Lambdas and Streams 자바8에 함수형 인터페이스, 람다 메서드 참조 등이 추가됨. Stream API 또한 추가되어서 이러한 언어변화에 맞는 데이터 요소 처리를 돕는다.
규칙 42 익명 클래스 보다 람다를 쓰자 오래전부터 1개의 추상 메소드를 갖는 인터페이스는 function type 으로 쓰여옴. 이 인터페이스를 구현한 function objects 는 함수를 나타냄. JDK1.1 부터 함수 객체를 만드는 가장 대표적인 수단은 익명 클래스였음 // 글자 길이로 정렬하는 함수 객체 Collections.sort(words, new Comparator&amp;lt;String&amp;gt;() { public int compare(String s1, String s2) { return Integer.</description></item><item><title/><link>https://sangmoon.github.io/TIL/posts/effectivejava/methodscommontoallobjects/item10/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://sangmoon.github.io/TIL/posts/effectivejava/methodscommontoallobjects/item10/</guid><description>Item 10: Obey the general contract when overriding equals equals를 구현하는 건 쉽지 않다. 가장 쉬운 방법은 override 하지 않는 것이다. 다음 조건 중 하나라도 만족하면 구현하지 않는 것이 좋다.
Each instance of the class is inherently unique. Thread와 같은 객체는 값보다 엔티티 자체를 표현한다. Object에서 제공하는 equals로 충분하다 There is no need for he class to provide a logical equality test. Client가 해당 기능을 필요하지 않다고 생각한다면 굳이 구현할 필요가 없다.</description></item><item><title/><link>https://sangmoon.github.io/TIL/posts/effectivejava/methodscommontoallobjects/item11/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://sangmoon.github.io/TIL/posts/effectivejava/methodscommontoallobjects/item11/</guid><description>Item 11: Always override hashCode when you override equals equals를 구현한 클래스는 항상 hashcode 를 구현해야 한다. 그렇지 않으면 HashMap 이나 HashSet 같은 collection을 제대로 사용할 수 없다. 다음과 같은 규약이 있다.
한 객체에 반복적으로 hashcode 가 호출될 때, 항상 같은 값을 반환해야 한다. equals로 true로 판단되는 객체는 같은 hashcode를 반환해야 한다. equals로 false가 나올 때 다른 hashcode가 나올 필요는 없다. 하지만 다른 값 나오게 하는게 hashtable 성능을 향상 시킨다.</description></item><item><title/><link>https://sangmoon.github.io/TIL/posts/effectivejava/methodscommontoallobjects/item12/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://sangmoon.github.io/TIL/posts/effectivejava/methodscommontoallobjects/item12/</guid><description>Always override toString Object 가 default toString 메소드를 제공하지만 사람이 읽기에 충분치 한다. [해당 클래스이름]@[Hexa hashcode] 형태를 이루고 있다. 따라서 모든 하위 클래스에서 toString을 override 하는게 좋다. 그리고 특정 포멧을 결정하든 말든 주석으로 의도를 명확히 써놓아야 한다.</description></item><item><title/><link>https://sangmoon.github.io/TIL/posts/effectivejava/methodscommontoallobjects/item13/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://sangmoon.github.io/TIL/posts/effectivejava/methodscommontoallobjects/item13/</guid><description>Item 13: Override clone judiciusly Cloneable 인터페이스는 복사를 허용하기 위해 만들어졌다. 하지만 Object의 clone method를 쓸 수 없기 때문에 목적 달성에 실패했다.
public class Employee { private String name; public Employee(String name) { this.name = name; } public String getName() { return name; } public static void main(String[] args) { Employee emp = new Employee(&amp;#34;Abhi&amp;#34;); try { Employee emp2 = (Employee) emp.clone(); System.out.println(emp2.getName()); } catch (CloneNotSupportedException e) { e.printStackTrace(); } } } // return CloneNotSupportedException.</description></item><item><title/><link>https://sangmoon.github.io/TIL/posts/effectivejava/methodscommontoallobjects/item14/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://sangmoon.github.io/TIL/posts/effectivejava/methodscommontoallobjects/item14/</guid><description>Item 14: Consider implementing Comparable Comparable은 Object에 정의된 인터페이스가 아니고, 단독 인터페이스이다. equals와 비슷한데 순서를 정하게 해준다. Comparable을 구현한 객체 배열은 다음과 같이 정렬할 수 있다.
Arrays.sort(a); 기본적으로 java에서 값을 나타내는 클래스는 Comparable을 구현한다. 만약 알파벳 순서나, 수치 순서, 연대 순 등과 같은 natural ordering이 필요하다면 반드시 Comparable 인터페이스를 구현해야 한다.
public interface Comparable&amp;lt;T&amp;gt; { int compareTo(T t); } compareTo의 일반적인 규약은 equals와 비슷하다.
이 객체가 비교하고자 하는 녀석보다 작으면 음수를 반환, 같으면 0을 반환 크면 양수를 반환한다.</description></item><item><title/><link>https://sangmoon.github.io/TIL/posts/effectivejava/serialization/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://sangmoon.github.io/TIL/posts/effectivejava/serialization/</guid><description>Serialization 규칙 76 readObject 메서드는 방어적으로 구현하라 변경 불가능 클래스 조차, 직렬화를 통해 불변식이 깨질 수 있다.
불변식 깨짐 -&amp;gt; readObject 유효성 검사 악의적 객체 참조 -&amp;gt; readObject 에서 방어적 복사 immutable class // 규칙 39 Period 클래스 public final class Period { private final Date start; private final Date end; public Period(Date start, Date end) { this.start = new Date(start.getTime()); this.end = new Date(end.getTime()); // 방어적 규칙 if (this.</description></item><item><title/><link>https://sangmoon.github.io/TIL/posts/effectivepython/pythonicthinking/item1/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://sangmoon.github.io/TIL/posts/effectivepython/pythonicthinking/item1/</guid><description>Item 1: Know Which Version of Python You&amp;rsquo;re Using python 은 보통 python2.7 의 alias 이다. 가끔은 더 낮은 버전을 쓰는 곳도 있다. 이를 확실히 하기 위해선 &amp;ndash;version flag를 사용한다.
$ python --version Python 2.7.10 python3 는 보통 Python3를 사용하기위해 쓰인다.
$ python3 --version Python 3.8.0 runtime 에서도 sys module을 통해 호출 가능하다.
import sys print(sys.version_info) print(sys.version) # sys.version_info(major=3, minor=6, micro=9, releaselevel=&amp;#39;final&amp;#39;, serial=0) # 3.6.9 (default, Jan 15 2020, 10:45:58) [GCC 5.</description></item><item><title/><link>https://sangmoon.github.io/TIL/posts/effectivepython/pythonicthinking/item2/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://sangmoon.github.io/TIL/posts/effectivepython/pythonicthinking/item2/</guid><description>Item 2: Follow the PEP 8 Style Guide Python Enhancement Proposal #8, 다른 말로 PEP 8 은 파이썬 코드 스타일 가이드이다. 일관된 코딩 스타일을 갖는 것은 가독성을 높인다. 프로젝트에서 다른 팀원과 스타일을 공유하는 것이 협업의 기본이다. 물론 혼자 일하더라도 이 가이드를 따르는 게 추후 유지보수 비용을 줄여준다.
WhiteSpace</description></item><item><title/><link>https://sangmoon.github.io/TIL/posts/java/access-modifier/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://sangmoon.github.io/TIL/posts/java/access-modifier/</guid><description>Access modifier java 에는 4개의 access modifier 가 있다.
public () protected default(package private) private 위의 순서대로 public에 가까울 수록 제한이 적고, private에 갈수록 제한이 커진다.
| Class | Package | Subclass | Subclass | World | | |(same pkg)|(diff pkg)| ————————————+———————+—————————+——————————+——————————+———————— public | + | + | + | + | + ————————————+———————+—————————+——————————+——————————+———————— protected | + | + | + | + | ————————————+———————+—————————+——————————+——————————+———————— default | + | + | + | | ————————————+———————+—————————+——————————+——————————+———————— private | + | | | | + : accessible blank : not accessible https://stackoverflow.</description></item><item><title/><link>https://sangmoon.github.io/TIL/posts/java/annotation/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://sangmoon.github.io/TIL/posts/java/annotation/</guid><description>Annotation @ 골뱅이를 통해서 추가 정보를 전달하는 방식을 annotation 이라고 한다. class에 대한 meta data를 저장하는 방식이다. 과거에는 XML을 통해 meta data를 많이 저장하였으나, 더 java 스러운 방식으로 현재 annotation을 표준 명세에 정의하였다. java.lang의 reflection을 통해 runtime에 annotation 에 접근할 수 있다.
@Target() @Retention() public @interface MyAnnotation { int value(); int otherValue(); } Target 과 Retention은 annotation 을 위한 built-in annotation 이다. Target은 Type, Field, Method, Parameter, Constructor, Local variable, AnnotationType, Package, Type parameter, Type use로 할 수 있다.</description></item><item><title/><link>https://sangmoon.github.io/TIL/posts/java/atomic-volatile-synchronized/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://sangmoon.github.io/TIL/posts/java/atomic-volatile-synchronized/</guid><description>atomic volatile synchronized Atomic java 는 java.concurrent.atomic Class 가 있다. Lock이나 synchronized keyword가 없어도 병렬 수행의 안전성이 하드웨어에 의해 보장된다. 내부적으로 CAS(compare-and-swap) 을 활용한다. 한 method 인 incrementAndGet을 보면 다음과 같다.(JDK 7 기준)
public final long incrementAndGet(){ for(;;){ long current = get(); long next = current + 1; if (compareAndSet(current, next)) reutrn next; } } get() 으로 현재 val을 가져오고, 2줄 아래 if 문에서 다시 memory의 값과 비교하여서 변동이 없으면 next value를 set하고, 변동이 있다면 다시 for문을 도는 형태이다.</description></item><item><title/><link>https://sangmoon.github.io/TIL/posts/java/class-loader/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://sangmoon.github.io/TIL/posts/java/class-loader/</guid><description>Class loader 다음과 같은 test code를 돌려보자
public void printClassLoaders() throws ClassNotFoundException { System.out.println(&amp;#34;Classloader of this class:&amp;#34; + PrintClassLoader.class.getClassLoader()); System.out.println(&amp;#34;Classloader of Logging:&amp;#34; + Logging.class.getClassLoader()); System.out.println(&amp;#34;Classloader of ArrayList:&amp;#34; + ArrayList.class.getClassLoader()); // result // Class loader of this class:sun.misc.Launcher$AppClassLoader@18b4aac2 // Class loader of Logging:sun.misc.Launcher$ExtClassLoader@3caeaf62 // Class loader of ArrayList:null } Bootstrap class loader (c로 구현) jvm 구동 시킬 때 작동함 getClassLoader() 시에 null 로 나옴 Extension class loader Application class loader (system class loader) java 에서 class 들은 java.</description></item><item><title/><link>https://sangmoon.github.io/TIL/posts/java/collection/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://sangmoon.github.io/TIL/posts/java/collection/</guid><description>java.util.Collection List 중복 허용
Set, SortedSet, NavigableSet 중복 불가
Queue, Deque concurrency 위해서..
Map, SortedMap, NavigableMap
equals/hashCode Iterator(한 방향)/ListIterator(양 방향) Collections class(cf. Arrays class) Vector, Hashable, Enumeration =&amp;gt; legacy! 쓰지마셍&amp;hellip; Wrappers: unmodifiable, synchronized, checked
java.util.concurrent BlockingQueue 모든 큐 기반 동시 콜렉션의 기본에있는 인터페이스. BlockingQueue에 요소를 추가하는 동안, 공간이 없으면 사용 가능하게 될 때까지 기다릴 수 있고 검색 할 때 요소가 비어있을 때까지 사용할 수있을 때까지 대기합니다.</description></item><item><title/><link>https://sangmoon.github.io/TIL/posts/java/enum/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://sangmoon.github.io/TIL/posts/java/enum/</guid><description>enum 다음과 같은 enum class 가 있다고 하자.
public enum Season{ Spring(&amp;#34;March through May&amp;#34;), Summer(&amp;#34;Jun throuh August&amp;#34;), Fall(&amp;#34;September through November&amp;#34;), Winter(&amp;#34;Decomber through Febnruary&amp;#34;); private String span; Season(String months){ this.span = months; } public String getSpan() { return this.span; } } 이를 컴파일 할 경우
public final enum Season { public static final enum Season Spring; public static final enum Season Summer; public static final enum Season Fall; public static final enum Season Winter; private java.</description></item><item><title/><link>https://sangmoon.github.io/TIL/posts/java/garbage-collection/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://sangmoon.github.io/TIL/posts/java/garbage-collection/</guid><description>garbage-collection reachable finalized
live object가 아닌 dead object를 garbage
serial vs parallel vs cms vs G1 (찾아보자) concurrent vs stop-the-world compacting vs non-compacting vs copying (non-compacting releases object in-place and can cause fragmentation) Collector 종류
mark-seep-compact collector serial 혹은 parallel. young이든 old든 짦고 긴 STW pause가 필요 mark &amp;amp; sweep collector : pause time이 짧다 CMS(Concurrent Mark &amp;amp; Sweep) collector는 compaction을 하지 않는다. fagmentation 이슈가 발생 G1 collector CMS와 유사하지만 대부분 reclaimable한 region들에 대해서 compaction 수행</description></item><item><title/><link>https://sangmoon.github.io/TIL/posts/java/jvm-option/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://sangmoon.github.io/TIL/posts/java/jvm-option/</guid><description>JVM options class load log 보기 -verbose:class
direct momory 최대 크기 지정 VM -XX:MaxDirectMemorySize=&amp;lt;size&amp;gt;</description></item><item><title/><link>https://sangmoon.github.io/TIL/posts/java/lambda/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://sangmoon.github.io/TIL/posts/java/lambda/</guid><description>Lambda Expression Java 8 부터 람다 표현식을 지원한다. 핵심은 지울 수 있는 건 다 지우고 컴파일러에게 맡기자! 이다.
interface Flyable void fly() class Bird implements Flyable{ @Override public void fly(){ System.out.println(&amp;#34;I believe I can fly&amp;#34;); } } Flyable fly = new Flyable(){ @Override public void fly(){ System.out.println(&amp;#34;I believe I can fly&amp;#34;); } } Flyable 이라는 interface를 구현한다고 해보자. 이를 구현한 Bird라는 클래스를 만드는게 일반 방법이고, 재사용성이 없다면 아래 방식으로 익명 inner class를 활용할 수도 있다.</description></item><item><title/><link>https://sangmoon.github.io/TIL/posts/java/loading-linking-initialization/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://sangmoon.github.io/TIL/posts/java/loading-linking-initialization/</guid><description>loading/linking/initialization loading, linking 그리고 initialization은 .class 인 바이트 코드가 jvm으로 불리면서 시작하는 초기 프로세스 이다. (instantiation, GC, finalization은 중간 단계이고 unloading 을 끝 프로세스라고 볼 수 있다)
loading 이 단계 에서는 특정 이름을 가진 클래스나 인터페이스의 .class 파일을 찾고 이 것을 해석하여 JVM 내부 데이터 구조에 맞게 바꿉니다. class loader 가 이러한 역할을 수행한다. class loader는 기본적으로 .class 파일들을 cache하기 때문에 한 번만 load하면 됩니다. 요약하면 loading 단계에서는 다음과 같은 3가지 일을 합니다.</description></item><item><title/><link>https://sangmoon.github.io/TIL/posts/java/nested-class/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://sangmoon.github.io/TIL/posts/java/nested-class/</guid><description>nested-class class 내부에 class를 정의한 것을 nested class라고 한다.
inner class method local inner class anonymous inner class static nested class 4 종류가 있다. 1 ~ 3 은 non-static, 4는 static class 이다.
inner class(member inner class)의 경우 inner class를 private 로 선언하여도 outer class에서 inner에 접근이 가능하며, inner 에서도 outer의 private 멤버에 접근 가능하다.
class Outer{ //... class Inner{ //... } } LinkedList class 내의 ListItr class가 한 예이다.</description></item><item><title/><link>https://sangmoon.github.io/TIL/posts/java/optional/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://sangmoon.github.io/TIL/posts/java/optional/</guid><description>Optional API Java는 c나 c++에 있는 포인터를 대부분 숨겼다. 하지만 하나 못 숨긴게 있었으니 바로 null pointer 이다. null 인 변수에 접근하려고 하면 NPE(Null Pointer Exception) 이 여지없이 떨어지기 때문에 항상 방어적 코드를 작성해야 했다.
if( val == null){ return &amp;#34;&amp;#34;; } else { return val; } val이 단순히 객체면 상관없지만, 만약 reference를 계속 따라가는 형태라면?
Object4 obj4 = obj1.getObject2().getObject3().getObject4(); // 방어적 코드 if(obj1 != null){ if(obj1.getObject2() != null){ if(obj1.</description></item><item><title/><link>https://sangmoon.github.io/TIL/posts/java/static-initializer/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://sangmoon.github.io/TIL/posts/java/static-initializer/</guid><description>initializer enum을 조사하던 중 enum class를 컴파일 하면 static {}; block이 static 내부에 생기는 것을 발견하였다.
public class Abc{ static { // static initializer } { // instance initializer } Abc(){ // constructor } } class 에서 크게 3가지의 초기화 method를 생각할 수 있다. constructor, static initializer, instance initializer 이다. static initializer는 class가 불리는 시점 즉 class loader에서 불릴 때 호출 되는 method 이다. Final static 변수를 초기화 해줄 때 로직이 필요하다면 여기서 해주어야 한다.</description></item><item><title/><link>https://sangmoon.github.io/TIL/posts/java/streamio/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://sangmoon.github.io/TIL/posts/java/streamio/</guid><description>Stream IO java.io package 에 선언되어 있다.
ByteStream 은 말 그대로 Byte 단위의 입출력을 담당한다. InputStream/OutputStream
CharacterStream 은 Java char, 2Byte 단위로 작동한다.
Reader/Writer 가 두 Stream 간의 interface 역할을 한다.
ByteStream -&amp;gt; CharacterStream 해주는게 InputStreamReader CharacterStream -&amp;gt; ByteStream 해주는게 OutputStreamWriter
NIO stream IO 는 non-blocking IO가 없다. 다 blocking임. 대용량 처리 같은 거할 때 critical 하다. 그래서 java.nio package 사용. stream이 아니라 buffer 기본으로 사용.</description></item><item><title/><link>https://sangmoon.github.io/TIL/posts/java/streams/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://sangmoon.github.io/TIL/posts/java/streams/</guid><description>Stream stream은 java의 자료구조(List, Map, Set &amp;hellip;) 들을 선언적으로 다룬다. 자료 구조들은 util.collection에 대부분 있는데, stream과 collection의 차이는 collection의 경우 자료 구조의 구현체이고, stream은 collection 들이 보관하고 있는 data를 다루는 API 라는 것이다.
예를 들어 String List에서 h로 시작하는 문자열만 뽑아낸다고 하자. 기존 방식은 List 에서 1개 씩 get을 해온 후 문자열 체크를 할 것이다.
for (String str: inputList){ if(str.startWith(&amp;#34;h&amp;#34;)){ outputList.add(str); } } 대략 위와 같은 코드가 된다. collection은 data의 추가, 삭제, 순회 API만 제공하기 때문에 나머지를 직접 구현해야 한다.</description></item><item><title/><link>https://sangmoon.github.io/TIL/posts/java/thread/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://sangmoon.github.io/TIL/posts/java/thread/</guid><description>Thread 기본적으로 main thread 존재(java launcher에 의해 실행되는 사용자 thread. public static void miain(String[]) 실행)
시작 creator thread에서 start() 호출하면 새로 thread 만들어서 해당 thread에서 run() 실행
종료 run() method가 종료되면 thread가 종료
다른 방식으로 thread를 제어하는 method는 모두 금지
stop() destroy() suspend() resume() why? 쓰레드가 임의의 lock을 잡은 상태에서 stop하거나 suspend 했을 때 답이 없다. JVM이 오버헤드가 너무 커진다.
남은 방법은 interrupt를 해당 thread에 notification 하는 것 뿐.</description></item><item><title/><link>https://sangmoon.github.io/TIL/posts/java/threads-executors/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://sangmoon.github.io/TIL/posts/java/threads-executors/</guid><description>Thread Excecutor Executor는 thread 생성 및 관리를 해주는 클래스이다. thread 를 직접 생성 하고 제어 하는 데에서 나올 수 있는 복잡성을 줄여준다. Executors 라는 Factory class 를 활용하거나 또는 직접 생성해줄 수도 있다.
ExecutorService executor = Executors.newFixedThreadPool(10); // by Executors ExecutorService executor = new ThreadPoolExecutor(1, 1, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&amp;lt;Runnable&amp;gt;()); // directly ExecutorService 는 interface 이다.
newFixedThreadPool : 고정된 갯수의 thread를 유지하는 executor이다. newSingleThreadExecutor : 1개의 thread만 유지하는 executor이다.</description></item><item><title/><link>https://sangmoon.github.io/TIL/posts/js/babel/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://sangmoon.github.io/TIL/posts/js/babel/</guid><description>babel 은 es6/es7 를 es5로 트랜스컴파일 하기 위한 도구입니다. babel
babel-cli babel-core babel-polyfill 로 구성되어 있다.</description></item><item><title/><link>https://sangmoon.github.io/TIL/posts/js/ecmascript/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://sangmoon.github.io/TIL/posts/js/ecmascript/</guid><description>Constants Constants Scoping Block-Scoped Variables Block-Scoped Functions Arrow Functions Expression Bodies Statement Bodies Lexical this Extended Parameter Handling Default Parameter Values Rest Parameter Spread Operator Template Literals String Interpolation Custom Interpolation Raw String Access Extended Literals Binary &amp;amp; Octal Literal Unicode String &amp;amp; RegExp Literal Enhanced Regular Expression Regular Expression Sticky Matching Enhanced Object Properties Property Shorthand Computed Property Names Method Properties Destructuring Assignment Array Matching Object Matching, Shorthand Notation Object Matching, Deep Matching Object And Array Matching, Default Values Parameter Context Matching Fail-Soft Destructuring Modules Value Export/Import Default &amp;amp; Wildcard Classes Class Definition Class Inheritance Class Inheritance, From Expressions Base Class Access Static Members Getter/Setter Symbol Type Symbol Type Global Symbols Iterators Iterator &amp;amp; For-Of Operator Generators Generator Function, Iterator Protocol Generator Function, Direct Use Generator Matching Generator Control-Flow Generator Methods Map/Set &amp;amp; WeakMap/WeakSet Set Data-Structure Map Data-Structure Weak-Link Data-Structures Typed Arrays Typed Arrays New Built-In Methods Object Property Assignment Array Element Finding String Repeating String Searching Number Type Checking Number Safety Checking Number Comparison Number Truncation Number Sign Determination Promises Promise Usage Promise Combination Meta-Programming Proxying Reflection Internationalization &amp;amp; Localization Collation Number Formatting Currency Formatting Date/Time Formatting</description></item><item><title/><link>https://sangmoon.github.io/TIL/posts/js/webpack-babel-config/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://sangmoon.github.io/TIL/posts/js/webpack-babel-config/</guid><description>Webpack-Babel-Config Webpack is modular manager for js. Babel is transcompiler for ES+.These two library can join!We should check 3 files. package.json webpack.config.js .babelrc
{ &amp;#34;author&amp;#34;: &amp;#34;sangmoon&amp;#34;, &amp;#34;license&amp;#34;: &amp;#34;ISC&amp;#34;, &amp;#34;devDependencies&amp;#34;: { &amp;#34;babel-core&amp;#34;: &amp;#34;^6.26.0&amp;#34;, &amp;#34;babel-loader&amp;#34;: &amp;#34;^7.1.2&amp;#34;, &amp;#34;babel-plugin-transform-async-to-generator&amp;#34;: &amp;#34;^6.24.1&amp;#34;, &amp;#34;babel-polyfill&amp;#34;: &amp;#34;^6.26.0&amp;#34;, &amp;#34;babel-preset-es2015&amp;#34;: &amp;#34;^6.24.1&amp;#34;, &amp;#34;webpack&amp;#34;: &amp;#34;^3.10.0&amp;#34;, &amp;#34;webpack-dev-server&amp;#34;: &amp;#34;^2.11.1&amp;#34; }, &amp;#34;babel&amp;#34;: { &amp;#34;presets&amp;#34;: [ &amp;#34;es2015&amp;#34; ] } } var path = require(&amp;#39;path&amp;#39;); module.exports = { //.... module:{ rules: [ { test: /\.js$/, exclude: /(node_modules)/, loader: &amp;#39;babel-loader&amp;#39;, } ] }, resolve: { modules:[&amp;#39;node_modules&amp;#39;], extensions: [&amp;#39;.</description></item><item><title/><link>https://sangmoon.github.io/TIL/posts/linux/network-setting/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://sangmoon.github.io/TIL/posts/linux/network-setting/</guid><description>/etc/network/interfaces를 수정하도록 한다.
sudo vi /etc/network/interfaces # This file describes the network interfaces available on your system # and how to activate them. For more information, see interfaces(5). # The loopback network interface auto lo iface lo inet loopback # The primary network interface # auto eth0 # iface eth0 inet dhcp # menual auto eth0 iface eth0 inet static address 192.168.0.20 netmask 255.</description></item><item><title/><link>https://sangmoon.github.io/TIL/posts/linux/permission/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://sangmoon.github.io/TIL/posts/linux/permission/</guid><description>unix file permission 3 가지 permission 종류가 있다.
r - read w - write x - execute 그리고 file 일 때와 directory 일 때 다른 의미를 갖는다. File
read - you can open, read and copy the file. write - you can modify the file. execute - you can execute the file if it&amp;rsquo;s executable. directory
read - you can ls the directory and see the contents.</description></item><item><title/><link>https://sangmoon.github.io/TIL/posts/linux/ubuntu-env-setting/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://sangmoon.github.io/TIL/posts/linux/ubuntu-env-setting/</guid><description>/etc/environment 시스템 단계에서 설정하는 파일
모든 유저들에게 적용됨
왠만하면 건들지 말자.
~/.profile 각 사용자마다 개별적으로 가지고있는 스크립트 파일
/etc/profile 아니면 /etc/profile.d/*.sh ~/.profile과 유사하지만 전역 스크립트.
이게 먼저 실행되고 개별 ~/.profile이 실행된다.
( /etc/profile이 /etc/profile.d/ 안에 있는 모든 *.sh 스크립트들을 실행시킴)</description></item><item><title/><link>https://sangmoon.github.io/TIL/posts/mysql/mysql-user-privileges/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://sangmoon.github.io/TIL/posts/mysql/mysql-user-privileges/</guid><description>2018/01/29
이번에 컴퓨터 ip 변경으로 인해 새로운 작업 환경을 구축하던 중 mysql connection이 튕겨서 문제 발생. select user, host from mysql.users 를 통해 보니 user name과 host가 구분되어 있어 host ip가 달라지면 접속이 안되는 현상임을 알았다. 기존 유저에 변경하려다가 잘 안되서 그냥 현재 ip에 새로운 유저를 등록하고 권한을 주기로 함.
mysql -u root -p mysql&amp;gt; CREATE USER &amp;#39;username&amp;#39;@&amp;#39;host&amp;#39; IDENTIFIED BY &amp;#39;password&amp;#39;; -&amp;gt; GRANT ALL PRIVILEGES ON *.* TO &amp;#39;username&amp;#39;@&amp;#39;host&amp;#39; WITH GRANT OPTION; 참조 stackoverflow</description></item><item><title/><link>https://sangmoon.github.io/TIL/posts/os/write-through-vs-write-back/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://sangmoon.github.io/TIL/posts/os/write-through-vs-write-back/</guid><description>2018/01/18
OS에서 Cache 정책
읽기 정책은 둘다 같다. 가장 가까운 캐시에 있으면 hit, 없으면 miss로 아래 단계 cache 또는 memory에 접근하여 hit 할 때 까지 반복한다.
쓰기의 경우 다음 2가지 정책이 존재한다.
write-through cache에 write 하고, 다음 cache에 또 write하고 .. 메모리까지 한번에 write한다. 장점은 로직이 매우 단순하다. 반면 write 작업의 overhead가 커진다. 같은 메모리를 지속적으로 변경하는 작업을 수행한다면,
모든 level의 cache,memory를 write해야하기 때문에 불필요한 자원소모가 생긴다.
write-back 우선 cache에 write를 하고, dirty bit를 assgin한다.</description></item><item><title/><link>https://sangmoon.github.io/TIL/posts/python/asyncio/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://sangmoon.github.io/TIL/posts/python/asyncio/</guid><description/></item><item><title/><link>https://sangmoon.github.io/TIL/posts/python/concurrent-future/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://sangmoon.github.io/TIL/posts/python/concurrent-future/</guid><description/></item><item><title/><link>https://sangmoon.github.io/TIL/posts/spring/aop/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://sangmoon.github.io/TIL/posts/spring/aop/</guid><description>AOP 개발의 핵심적인 비즈니스 로직을 개발하는 데에만 집중하고, 나머지 부가적인 기능은 설정을 통해서 조정하라
관련 용어 Aspect: 공통 관심사에 대한 추상적 명칭. 로깅이나 보안, 트랜잭션 같은 기능 자체 Advice: 실제로 Aspect를 구현한 객체 Join points: Advice를 적용할 수 있는 대상. Spring에서는 각 객체의 method Pointcuts: 여러 메소드 중 실제 Adivce가 적용될 대상 메소드 target: pointcuts을 갖는 객체 Proxy: Advice가 적용될 때 만들어지는 객체 Introduction: target엔느 없는 새로운 메소드나 인스턴스 변수를 추가하는 기능 Weaving: Advicd와 target이 결합하여 프록시 객체를 만드는 과정 Advice의 종류 Before Advice: target의 메소드 호출 전에 사용 After returning: target의 메소두 호출 이후에 적용 After throwing: target의 예외 발생 후 적용 After: target의 메소드 호출 후 예외발생에 관계없이 적용 Around: target의 메소드 호출 이전 이후 모두 적용</description></item><item><title/><link>https://sangmoon.github.io/TIL/posts/spring/file-upload/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://sangmoon.github.io/TIL/posts/spring/file-upload/</guid><description>spring에서 파일 업로드는 2가지 방식을 택할 수 있다
HTML FORM 사용하기 다음과 같은 형식으로 파일 업로드를 실행 할 수 있다. &amp;lt;form action=&amp;#34;uploadfile&amp;#34; method=&amp;#34;post&amp;#34; enctype=&amp;#34;multipart/form-data&amp;#34;&amp;gt; &amp;lt;input type=&amp;#34;file&amp;#34; name=&amp;#34;file&amp;#34;&amp;gt;&amp;lt;input type=&amp;#34;submit&amp;#34;&amp;gt; &amp;lt;/form&amp;gt; ajax 사용하기 drag-drop을 구현하려면 ajax를 이용한다. 우선 기본적으로 브라우저에 image를 드래그 하면 창으로 보여주기 때문에 이를 preventDefault 함수로 막는다 &amp;lt;script&amp;gt; $(&amp;#34;.fileDrop&amp;#34;).on(&amp;#34;dragenter dragdover&amp;#34;, function(e){ e.preventDefault() }) $(&amp;#34;.fileDrop&amp;#34;).on(&amp;#34;drop&amp;#34;, function(e){ e.preventDefault() }) &amp;lt;/script&amp;gt;</description></item><item><title/><link>https://sangmoon.github.io/TIL/posts/spring/korean-encoding/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://sangmoon.github.io/TIL/posts/spring/korean-encoding/</guid><description>다음과 같은 내용을 web.xml에 추가한다.
&amp;lt;filter&amp;gt; &amp;lt;filter-name&amp;gt;encoding&amp;lt;/filter-name&amp;gt; &amp;lt;filter-class&amp;gt;org.springframework.web.filter.CharacterEncodingFilter&amp;lt;/filter-class&amp;gt; &amp;lt;init-param&amp;gt; &amp;lt;param-name&amp;gt;encoding&amp;lt;/param-name&amp;gt; &amp;lt;param-value&amp;gt;UTF-8&amp;lt;/param-value&amp;gt; &amp;lt;/init-param&amp;gt; &amp;lt;/filter&amp;gt; &amp;lt;filter-mapping&amp;gt; &amp;lt;filter-name&amp;gt;encoding&amp;lt;/filter-name&amp;gt; &amp;lt;url-pattern&amp;gt;/*&amp;lt;/url-pattern&amp;gt; &amp;lt;/filter-mapping&amp;gt;</description></item><item><title/><link>https://sangmoon.github.io/TIL/posts/spring/requestbody-responsebody/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://sangmoon.github.io/TIL/posts/spring/requestbody-responsebody/</guid><description>@RequestBody anotation 은 controller로 들어온 요청에서 request body의 내용물을 converting 할때 사용한다. 우선 request의 Content-type을 처리할 수 있는 HttpMessageConverter 구현체를 찾는다. 그리고 converting 처리를 통해 request body를 java object로 바꿔서 사용한다.
POST / HTTP/1.1 Host: localhost:8000 Connection: keep-alive Content-Type: application/json { &amp;#34;name&amp;#34;: &amp;#34;sangmoon&amp;#34;, &amp;#34;age&amp;#34;: &amp;#34;26&amp;#34; } Class Person{ String name; Integer age; } @RequestMapping(value=&amp;#34;/&amp;#34;, method=RequestMethod.POST) public String test(@requestBody Person person){ .... } @ResponseBody는 jsp를 return 해주지 않고 바로 http response를 return 해주기 위한 annotation 이다.</description></item><item><title/><link>https://sangmoon.github.io/TIL/posts/spring/root-config/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://sangmoon.github.io/TIL/posts/spring/root-config/</guid><description/></item><item><title/><link>https://sangmoon.github.io/TIL/posts/spring/spring-mvc-config/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://sangmoon.github.io/TIL/posts/spring/spring-mvc-config/</guid><description>2018/01/19
스프링은 기본적으로 xml 기반의 설정파일은 관리한다.라이브러리 dependency 및 예약어 들을 관리하는 pom.xml. 가 있고root-context.xml 은 모든 SERVICE나 DAO layer bean을 담고 있다. compunent-scan을 통해 해당 경로의 Bean들을 찾는다.web-context.xml 은 servlet 정보들을 담고 있는데, 해당 servlet이 담당할 resolver나 handler 정보를 가지고 있다.web.xml에는 위에 web-context.xml에 등록한 servlet들 정보와, root-config.xml에 등록한 정보를 등록해서 dispatcherServlet 을 생성한다.
하지만 xml파일은 가독성이 떨어지고 디버깅이 어려운 단점이 있다. 그래서 Spring3.1 이후로 java-based 설정이 추가되었다.
&amp;lt;!-- web-servlet.xml --&amp;gt; &amp;lt;?</description></item><item><title/><link>https://sangmoon.github.io/TIL/posts/spring/spring-security-custom-validator-pattern/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://sangmoon.github.io/TIL/posts/spring/spring-security-custom-validator-pattern/</guid><description>2018/10/17
Spring security에서의 custom validator pattern
// User.java @Entity(name=&amp;#34;user&amp;#34;) @PasswordMatches public class User { //중략.. @ValidEmail @NotNull @NotEmpty private String email; } PasswordMatches의 경우 confirm field와 password field를 비교하기에 User 만들 때 사용.. ValidEmail의 경우 Email 형식인지 확인 @Target({ElementType.TYPE, ElementType.ANNOTATION_TYPE}) @Retention(RetentionPolicy.RUNTIME) @Constraint(validatedBy = PasswordMatchesValidator.class) @Documented public @interface PasswordMatches { String message() default &amp;#34;Passwords don&amp;#39;t match&amp;#34;; Class&amp;lt;?&amp;gt;[] groups() default {}; Class&amp;lt;? extends Payload&amp;gt;[] payload() default {}; } //PasswordMatchesValidator public class PasswordMatchesValidator implements ConstraintValidator&amp;lt;PasswordMatches, Object&amp;gt;{ @Override public void initialize(PasswordMatches constrainAnnotation) {} @Override public boolean isValid(Object obj, ConstraintValidatorContext context) { User user = (User) obj; return user.</description></item><item><title/><link>https://sangmoon.github.io/TIL/posts/spring/spring-security-retrieve-user-info/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://sangmoon.github.io/TIL/posts/spring/spring-security-retrieve-user-info/</guid><description>2018/01/25
스프링 시큐리티로 유저 정보 얻기! Bean으로 부터 유저 정보 얻기 SecurityConytextHolder 로 부터 현재 인증된 principal을 얻을 수 있다. Authentication authentication = SecurityContextHolder.getContext().getAuthentication(); String currentPrincipalName = authentication.getName(); 체크하기 전에 유저가 있는지 체크할 수 있다.
Authentication authentication = SecurityContextHolder.getContext().getAuthentication(); if (!(authentication instanceof AnonymousAuthenticationToken)) { String currentUserName = authentication.getName(); return currentUserName; } 하지만 static call은 좋지 않다&amp;hellip;
컨트롤러에서는 (@Controller) 추가적인 방법이 가능하다. Principal 에 method argument로 접근이 가능하다. import java.</description></item><item><title/><link>https://sangmoon.github.io/TIL/posts/spring/transaction/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://sangmoon.github.io/TIL/posts/spring/transaction/</guid><description>transaction @Transactional annotation으로 처리 한다.
Propagation 속성 PROPAGATION_MADATORY PROPAGATION_NESTED PROPAGATION_NEVER PROPAGATION_NOT_SUPPORTED PROPAGATION_REQUIRED PROPAGATION_REQUIRED_NEW PROPAGATIN_SUPPORTS</description></item><item><title/><link>https://sangmoon.github.io/TIL/posts/spring/web-config/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://sangmoon.github.io/TIL/posts/spring/web-config/</guid><description>2018/01/19
WebConfig 설정을 알아보자. servlet.xml을 대체하는 java class이다. WebConfig가 상속받는 abstract class는 다음 WebMvcConfigurerAdapter 이다. 이 abstract class는 WebMvcConfigurer 라는 interface를 구현했는데 이는 원하는 method만 override하면 실행되도록 하기 위함이다. 해당 method가 어떤 설정에 해당하는지 알아보자. spring docs
public abstract class WebMvcConfigurerAdapter implements WebMvcConfigurer { @Override public void configurePathMatch(PathMatchConfigurer configurer) { } @Override public void configureContentNegotiation(ContentNegotiationConfigurer configurer) { } @Override public void configureAsyncSupport(AsyncSupportConfigurer configurer) { } @Override public void configureDefaultServletHandling(DefaultServletHandlerConfigurer configurer) { } @Override public void addFormatters(FormatterRegistry registry) { } @Override public void addInterceptors(InterceptorRegistry registry) { } @Override public void addResourceHandlers(ResourceHandlerRegistry registry) { } @Override public void addCorsMappings(CorsRegistry registry) { } @Override public void addViewControllers(ViewControllerRegistry registry) { } @Override public void configureViewResolvers(ViewResolverRegistry registry) { } @Override public void addArgumentResolvers(List&amp;lt;HandlerMethodArgumentResolver&amp;gt; argumentResolvers) { } @Override public void addReturnValueHandlers(List&amp;lt;HandlerMethodReturnValueHandler&amp;gt; returnValueHandlers) { } @Override public void configureMessageConverters(List&amp;lt;HttpMessageConverter&amp;lt;?</description></item><item><title/><link>https://sangmoon.github.io/TIL/posts/spring/webinitializer/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://sangmoon.github.io/TIL/posts/spring/webinitializer/</guid><description/></item><item><title/><link>https://sangmoon.github.io/TIL/posts/springstudy/reactive/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://sangmoon.github.io/TIL/posts/springstudy/reactive/</guid><description>Reactive Programming Reactive Programming이 어떤 것인지 rxJava(reactive java) 를 통해 설명 webflux 는 이것과 용어는 다르겠지만.. 핵심 개념이나 프로그래밍 방식은 유사할 것이라 생각 Reactive programmming with rxJava ch.4 까지 참조 public class Main { public static void main(String[] args) { Observable.just(&amp;#34;Hello world&amp;#34;).subscribe(System.out::println); } } 미리 알아야 할 것 Generic, lambda, method reference
what is Monad? rx 들어가기 전에 모나드가 무엇인지 알아보자. CompletableFuture니 Observable이니 Flux 니 다 모나드이기 때문에 알면 확실히 편하다!</description></item><item><title/><link>https://sangmoon.github.io/TIL/posts/springstudy/webflux/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://sangmoon.github.io/TIL/posts/springstudy/webflux/</guid><description>WebFlux 앞 부분은 이전 스터디와 겹치기 때문에 생략
레시피 5-9 리액티브 핸들러 함수 작성하기 @RequestMapping 대신 핸들러 함수로 작성할 수 있음 @FunctionalInterface public interface HandlerFunction&amp;lt;T extends ServerResponse&amp;gt; { Mono&amp;lt;T&amp;gt; handle(ServerRequest request); } ServerRequest, ServerResponse 를 통해 요청/응답의 다양한 파트들에 비동기적으로 접근 가능 핸들러 함수 작성 @Component //1 다른 어노테이션 없이 Component 만 선언해주면 됨 public class ReservationRestController { private final ReservationService reservationService; public ReservationRestController(ReservationService reservationService) { this.</description></item></channel></rss>