[{"id":0,"href":"/TIL/concurrency/ch16_java_memory_model/","title":"Java memory model","section":"Java Concurrency","content":"ch16 자바 메모리 모델 #  16.1 자바 메모리 모델은 무엇이며, 왜 사용해야 할까? #  //특정 쓰레드에서 변수에 값을 할당 aVailable = 3; 자바 메모리 모델: \u0026ldquo;쓰레드가 aVariable에 할당도니 3이란 값을 사용할 수 있으려면 어떤 조건이 돼야 하는가?\u0026rdquo; 동기화 기법을 사용하지 않으면, 영언히 3을 읽어가지 못하는 여러 상황 존재.\n 컴파일러에서 소스코드에 적힌 내용을 명확하게 구현하는 코드를 생성 못할 가능성 변수 값을 메모리가 아닌 CPU 레지스터에 보관할 수 있음 CPU 프로세서는 프로그램을 순차실행 하거나, 병렬 실행할 수 있고 따라서 사용하는 캐시 형태에 다라 할당된 값이 메모리에 보관되는 시점에 차이가 있을 수 있으며 CPU 내부 캐시 값이 다른 CPU에는 안 보일 수 있다.  싱글 쓰레드 일 때는 이런 현상이 가려져 보이지 않음. JVM 명세에 싱글 스레드 일 경우, 순차실행과 같은 결과를 보장하도록 하고 있음. 결과만 같으면 어떤 식으로 하든 상관없음.\n16.1.1 플랫폼 메모리 모델 #   메모리 공유 멀티 프로세서 시스템은 보통 프로세서 내에 캐시가 있음 캐시의 내용을 주기적으로 메인 메모리와 동기화 하드웨어 프로세서 아키텍처는 저마다 다른 캐시 일관성(cache coherence)를 지원 멀티 프로세서에서 모두 동기화처리하는 것은 부하가 큼. 대부분 성능을 위해 캐시 일관성을 일부 포기함. 시스템 구조의 메모리 모델은 기본 정보를 제공하고, 메모리 내용을 공유하고자 할 때 특별한 명령어(memory barrier나 fence) 를 어떻게 사용해야 하는지 제공 자바 개발자가 하드웨어 신경 쓰지 않도록 JVM은 JMM(java memory model) 을 통해 이를 추상화.  16.1.2 재배치 #   JMM은 서로 다른 쓰레드가 각자 상황에 맞게 명령어를 실행할 수 있도록 허용 동기화되지 않은 부분의 실행 순서 예측은 힘듬 특정 작업이 지연되거나 다른 순서로 실행되는 것처럼 보이는 문제는 재배치(reorder) 로 표현  //예제16.1 public class PossibleReordering { static int x = 0, y = 0; static int a = 0, b = 0; public static void main(String[] args) throws InterruptedException { Thread one = new Thread(new Runnable(){ public void run() { a = 1; x = b; } }); Thread other = new Thread(new Runnable() { public void run() { b = 1; y = a; } }); one.start(); other.start(); one.joint(); other.join(); System.out.println(x + \u0026#34; , \u0026#34; + y); } } 결과 예측은 어려움. (1,0) (0,1) (1,1) (0,0) 다 가능\n16.1.3 자바 메모리 모델을 간략히 설명한다면 #   JMM 은 프로그램 내부 모든 작업을 대상으로 미리 발생(happens-before) 라는 부분 재배치(partial reordering) 연산을 정의 작업 A가 실행된 결과를 작업B에서 볼수 있다는 점을 보장하기 위해(동일 쓰레드는 다른 쓰레드든) 작업 A와 작업B 사이에는 미리 발생 관계가 갖춰져야 한다 관계가 없아면 JVM은 지멋대로 작업을 재배치 하나의 변수를 2개이상 쓰레드가 읽고, 최소 하나 이상 쓰레드에서 쓰기 작업을 하는데 미리 발생 관계가 갖춰져 있지 않다면 데이터 경쟁(data race) 가 발생 이런 데이터 경쟁이 발생하지 않는 프로그램을 올바른 동기화 프로그램(correctly synchoronized program) 이라고 함.   미리 발생 현상 규칙\n 프로그램 순서 규칙: 특정 스레드를 놓고 봤을 때 프로그램된 순서에서 앞서 있는 작업은 동일 스레드에서 뒤에 실행되도록 프로그램된 작업보다 미리 발생한다\n모니터 잠금 규칙: 특정 모니터 잠금 작업이 뒤이어 오는 모든 모니터 잠근 작업보다 미리 발생한다\nvolatile 변수 규칙: volatile 변수에 대한 쓰기 작업은 이후에 따라오는 해당 변수에 대한 모든 읽기 작업보다 미리 발생한다\n쓰레드 시작 규칙: 특정 스레드에 대한 Thread.start 작업은 시작된 스레드가 갖고 있는 모든 작업보다 미리 발생한다\n스레드 완료 규칙: 스레드 내부의 모든 작업은 다른 스레드에서 해당 스레드가 완료됐다는점을 파악하는 시점보다 미리 발생한다. 특정 스레드가 완료됐는지 판단하는 것은 Thread.join 메소드가 리턴되거나 Thread.isAlive가 false를 리턴하는지 확인하는 방법을 말한다\n인터럽트 규칙: 다른 스레드를 대상으로 interrupt 메소드를 호출하는 작업은 인터럽트 당한 스레드에서 인터럽트를 당했다는 사실을 파악하는 일보다 미리 발생한다. 인터럽트를 당했다는 사실을 파악하려면 InterruptedException을 받거나 isInterrupted 메소드 또는 interrupted 메소드를 사용할 수 있다\n완료 메소드(finalizer) 규칙: 특정 객체에 대한 생성 메소드가 오나료되는 시점은 완료메소드가 시작하는 시점보다 미리 발생한다\n전이성(transitivity): A가 B보다 미리 발생하고, B가 C보다 미리 발생한다면, A는 C보다 미리 발생한다\n  ** 특정 Lock 객체 잠그거나 해제하는 연산은 암묵적락과 동일한 메모리 현상을 보여준다\n** 단일 연산 변수에 대한 읽기 쓰기 연산은 volatile 변수에 대한 작업과 동일한 메모리 현상을 보여준다.\n작업이 부분적으로만 순서가 정해져 있어도, 동기화 작업(락 확보 및 해제, vilatile 변수 읽기 쓰기 작업)은 항상 완전하게 순서가 정해져 있다.\n16.1.4 동기화 피기백 #    피기백(piggyback): 현재 사용 중인 동기화 기법의 가시성(visiblity)에 얹혀가는 방법 락으로 보호돼 있지 않은 변수에 모니터락이나 volatile 변수 규칙 같은 미리 발생 규칙을 함께 적용해 순서를 정의하는 방법. 오류가 나기 쉬워 성능 튜닝이 정말 중요할 때만 써야함\n  AQS는 FutureTask가 맡은 작업의 진행 상태(실행 중, 완료, 취소 여부를 정수형으로 보관) 및 결과 관리\n  외부에서는 set()으로 실행 결과를 보관하고, get()으로 결과 값을 가져옴\n  결과 값 보관 변수를 volatile로 선언해도 되겠지만, 기존 동기화 잘 이용하면 적은 자원으로 동일한 결과 얻을 수 있음\n  FutureTask 메소드에서 tryReleaseShared() 메소드가 tryAcquireShared() 보다 항상 먼저 실행되도록 되어 있음\u0026hellip;\n  // AbstractQueuedSynchronizer 내부 private volatile Thread runner; protected boolean tryReleaseShared(int ignore) { runner = null; return true; } protected int tryAcquireShared(int ignore) { return innerIsDone() ? 1 : -1; } boolean innerIsDone() { return ranOrCancelled(getState()) \u0026amp;\u0026amp; runner == null; } innerSet() 은 releaseShared() 하기 전에 결과를 set 하고 innerGet()은 acquireShared() 하고 결과 얻어오므로\u0026hellip; 락 없으나 result 쓰는 일이 result 읽는 것보다 먼저 일어나도록 조절하고 있음\n// FutureTask 내부의 AbstactQueuedSynchronizer class private final class Sync extends AbstactQueuedSynchorizer { private static final int RUNNING = 1, RAN = 2, CANCELLED = 4; private V result; private Exception exception; void innnerSet(V v) { while(true) { int s = getState(); if(RanOrCancelled(s)) return; if(compareAndSetState(s, RAN)) break; } result = v; releaseShared(0); done(); } V innerGet() throws InterruptedException, ExecutionException { acquireSharedInerruptibly(0); if(getState() == CANCELLED) throw new CancellationException(); if(exception != null) throw new ExecutionException(exception); return result; } } 이처럼 객체 값 공개할 미리 발생 규칙 따로 정의하지 않고, 다른 목적으로 만들어 놓은 미리 발생 순서를 가져다가 사용하는 것을 피기백이라고 함\n16.2 안전한 공개 #  16.2.1 안전하지 못한 공개 #  public class UnsafeLazyInitialization { private static Resource resource; public static Resource getInstance() { if(resource == null) { resource = new Resource(); } return resource; } }  경쟁 조건 생길 수 있음 심한 경우, 참조는 최신화되지만 내부 초기화는 재배치 될 수 있음  락을 쓰거나 volatile을 쓰면 미리 발생 관계가 보장됨..\n16.2.2 안전한 공개 #  16.2.3 안전한 초기화를 위한 구문 #   Syncronized Static (static 변수가 아니어도 static block에서 초기화하면 같은 효과)  // 스레드 안전 초기화 public class SafeLazyInitialization { private static Resource resource; public synchronized static Resource getInstance() { if(resource == null) { resource = new Resource(); } return resource; } } // 성질 급한 초기화 public class SafeLazyInitialization { private static Resource resource = new Resource(); public synchronized static Resource getInstance() { return resource; } } public class ResourceFactory { private static class ResourceHolder { public static Resource resource = new Resource(); } public static Resource getResource() { return ResourceHolder.resource; } } 16.2.4 Double Checked Lock #  public class DoubleCheckedLocking { private static Resource resource; public static Resource getInstance() { if(resource == null) { synchronized(DoubleCheckedLocking.class) { if(resource == null) { resource = new Resource(); } } } return resource; } }  가독성 떨어짐\u0026hellip; 부분 구성된 Resource 객체를 가져올 가능성 있음 volatile 쓸 것  16.3 초기화 안전성 #  초기화 안전성(initialization safety) : 올바르게 생성된 불변객체를 어떤 방법으로건 공개해도 별다른 동기화 구문 없이 안전하게 쓸 수 있다.\n final 로 선언된 변수를 갖고 있는 클래스는 초기화 안전성 조건 때문에 인스턴스 참조 최초 생성 때 재배치가 일어나지 않는다  public class SafeStates { private final Map\u0026lt;String, String\u0026gt; status; public SafeStates() { states = new HashMap\u0026lt;String, String\u0026gt;(); } public String getAbbreviation(String s) { return states.get(s); } } 이 클래스는 스레드 안전하지만..\n states 가 final이 아니거나 생성자가 아닌 곳에서 states를 변경하거나 SafeStates class에 final로 선언되지 않은 다른 변수가 더 있다면 해당 변수들은 다른 쓰레드에서는 올바르게 못 볼 수 있다. 생성자 완료되기 전에 객체를 외부에 노출하는 경우에도..  요약 #  JMM은 어렵다.\n"},{"id":1,"href":"/TIL/concurrency/ch12_pararrel_program_test/","title":"Test pararrel program","section":"Java Concurrency","content":"Ch12 병렬 프로그램 테스트 #    정확성 테스트\n 원하는 동작을 항상 한다. 원치 않는 동작을 항상 안한다.    활동성 테스트\n 데드락 처리량(throughput) 응답성(responseiveness) 확장성(scalability)    12.1 정확성 테스트 #   설계대로 작동하는지 테스트  /* * 간단한 큐 구현(LinkedBlockingQueue나 ArrayBlockingQueue 하위 호환) */ public class BoundedBuffer\u0026lt;E\u0026gt; { private final Semaphore availableItems, availableSpaces; private final E[] items; private int putPosition = 0, takePosition = 0; public BoundedBuffer(int capacity) { availableItems = new Semaphore(0); availableSpaces = new Semaphore(capacity); items = (E[]) new Object[capacity]; } public boolean isEmpty() { return availableItems.availablePermits() == 0; } public boolean isFull() { return availableSpaces.availablePermits() == 0; } public void put(E x) throws InterruptedException { availableSpaces.acquire(); doInsert(x); availableItems.release(); } public E take() throws InterruptedException { availableItems.acquire(); E item = doExtract(); availableSpaces.release(); return item; } private synchronized void doInsert(E x) { int i = putPosition; items[i] = x; putPosition = (++i == items.length) ? 0 : i; } private synchronized E doExtract() { int i = takePosition; E x = items[i]; items[i] = null; takePosition = (++i == items.length) ? 0 : i; return x; } } 12.1.1 가장 기본적인 단위 테스트 #  public class BoundedBufferTest { private static final long LOCKUP_DETECT_TIMEOUT = 10 * 1000; /*만들 때 비어있는지*/ void testIsEmptyWhenConstructed() { BoundedBuffer\u0026lt;Integer\u0026gt; bb = new BoundedBuffer\u0026lt;Integer\u0026gt;(10); assertTrue(bb.isEmpty()); assertFalse(bb.isFull()); } /*꽉 차는지*/ void testisFullAfterPuts() throws InterruptedException { BoundedBuffer\u0026lt;Integer\u0026gt; bb = new BoundedBuffer\u0026lt;Integer\u0026gt;(10); for(int i=0;i\u0026lt;10;i++) { bb.put(i); } assertTrue(bb.isFull()); assertFalse(bb.isEmpty()); } 12.1.2 블로킹 메소드 테스트 #   병렬 동작 테스트하려면 2개 이상 쓰레드 테스트해야함. 만약 특정 메소드가 반드시 대기상태로 들어가야만 한다면 해당 쓰레드는 더 이상 실행되지 않고 멈춰야 테스트 성공. 인터럽트를 거는 것이 가장 확실한 방법. 대기 메소드가 인터럽트 걸리면 리턴되거나, InterruptedException 을 던지는 행동하도록 만들어져야 한다. JOIN 쓰면 되기 때문에 Thread 상속받는게 편함. Thread.getState() 는 JVM 에 따라 구현이 달라서 믿을만하지 않음.  /*비어있을 때 못 빼내는지*/ void testTakeBlocksWhenEmpty() { final BoundedBuffer\u0026lt;Integer\u0026gt; bb = new BoundedBuffer\u0026lt;Integer\u0026gt;(10); Thread taker = new Thread() { public void run() { try { int unused = bb.take(); fail(); // 여기 들어오면 오류!  } catch(InterruptedException success) { } } }; try { taker.start(); Thread.sleep(LOCKUP_DETECT_TIMEOUT); taker.interrupt(); taker.join(LOCKUP_DETECT_TIMEOUT); assertFalse(taker.isAlive()); } catch(Exception unExpected) { fail(); } } } 12.1.3 안전성 테스트 #   위 테스트들은 공유 데이터 경쟁에서 나올 수 있는 오류는 테스트하지 못함 병렬처리 환경에서 높은 확률로 잘못된 속성을 찾음과 동시에 병렬성을 인위적으로 재현해서는 안 됨 BnoudedBuffer와 같이 프로듀서-컨슈머 패턴을 사용하는 클래스는 큐나 버퍼에 추가된 항목을 모두 그대로 뽑아낼 수 있는지 확인하는 방법이 좋음  아무 생각없이 만들면 input 리스트 만들고 queue에 넣을 때 output 리스트 에 넣고, 뺄 때 output 리스트에서 제거해서 마지막에 텅비었는지 확인  추가적인 동기화 작업이 필요하기 때문에 꼬여버릴 가능성 있음   들어가고 나오는 항목의 체크섬을 확인하는 방법  프로듀서 1개, 컨슈머 1개로 항상 순서가 유지되는 구조에서 효과가 좋음 여러 프로듀서, 컨슈머로 확장하려면 체크섬의 순서와 상관없이 최종 체크섬을 비교해야함 사용하는 체크섬이 랜덤한지도 봐야함. 적당히 규칙이 있다면, 컴파일러가 최적화해서 미리 계산해버릴 수 있음 이런 경우 난수발생기 사용하면 됨      // 싼 값에 중급의 품질을 제공하는 난수 발생기..  static int xorShift(int y) { y ^= (y\u0026lt;\u0026lt;6); y ^= (y\u0026gt;\u0026gt;\u0026gt;21); y ^= (y\u0026lt;\u0026lt;7); return y; }  쓰레드 생성하는 것에 부하가 있기 때문에, 최초 쓰레드가 대부분의 작업을 다 담당할 가능성 존재  CountDownLatch 나 CyclicBarrier 이용하면, 모든 쓰레드가 준비될 때까지 기다릴 수 있음   테스트가 끝났음을 쓰레드간 통신으로 하지말고 종료 조건을 정하면 동기화 안해도 되서 편함  public class PutTakeTest { private static final ExecutorService pool = Executors.newCachedThreadPool(); private final AtomicInteger putSum = new AtomicInteger(0); private final AtomicInteger takeSum = new AtomicInteger(0); private final CyclicBarrier barrier; private final BoundedBuffer\u0026lt;Integer\u0026gt; bb; private final int nTrials, nPairs; // 쓰레드당 시도 횟수, 쓰레드 수  public static void main(String[] args) { new PutTakeTest(10, 10, 100000).test(); pool.shutdown(); } PutTakeTest(int capacity, int npairs, int ntrials) { this.bb = new BoundedBuffer\u0026lt;Integer\u0026gt;(capacity); this.nTrials = ntrials; this.nPairs = npairs; this.barrier = new CyclicBarrier(npairs*2+1); } void test() { try { for(int i=0;i\u0026lt;nPairs;i++) { pool.execute(new Producer()); pool.execute(new Consumer()); } barrier.await(); barrier.await(); assertEquals(putSum.get(), takeSum.get()); } catch(Exception e) { throw new RuntimeException(e); } } class Producer implements Runnable { @Override public void run() { try { int seed = (this.hashCode() ^ (int)System.nanoTime()); int sum = 0; barrier.await(); for(int i = nTrials; i\u0026gt;0; --i) { bb.put(seed); sum+=seed; seed=xorShift(seed); } putSum.getAndAdd(sum); barrier.await(); } catch (Exception e) { throw new RuntimeException(e); } } } class Consumer implements Runnable { @Override public void run() { try { barrier.await(); int sum=0; for(int i =nTrials;i\u0026gt;0;--i) { sum += bb.take(); } takeSum.getAndAdd(sum); barrier.await(); } catch (Exception e) { throw new RuntimeException(e); } } } } 12.1.4 자원 관리 테스트 #   지금까지는 스펙에 맞게 동작하는지 확인하는 테스트 이번엔 하지말아야 할 일을 하지 않는지 테스트 ex) 자원 유출 HEAP inspection 을 사용해 볼만 함 크기가 제한된 버퍼에 상당한 메모리 객체를 추가하고, 추가된 객체를 제거. 그러면 버퍼는 비어있기에 힙 사용량 크게 변화 없어야함  class Big{double[] data = new double[100000];} static final int CAPACITY = 1000; static final int THREHOLD = /*경험적인 값*/; void testLeak() throws InterruptedException { BoundedBuffer\u0026lt;Big\u0026gt; bb = new BoundedBuffer\u0026lt;Big\u0026gt;(CAPACITY); int heapSize1 = /*HEAP SNAP SHOT*/; for(int i=0; i\u0026lt; CAPACITY; i++) { bb.put(new Big()); } for(int i=0; i\u0026lt;CAPACITY; i++) { bb.take(); } int heapSize2 = /*HEAP SNAP SHOT*/; assertTrue(Math.abs(heapSize1 - heapSize2) \u0026lt; THRESHOLD); } 12.1.5 콜백 사용 #   콜백 구조를 적용하면 테스트 케이스 구현에 도움이 됨 콜백 함수는 중요 시점마다 객체 내부값을 확인하는 좋은 기회 제공 모든 기능을 새로 만들지 말고 Java에서 제공하는 기존 클래스들 활용하라는 뜻인듯\u0026hellip; ThreadPool 예제  public class TestingThreadFactory implements ThreadFactory { public final AtomicInteger numCreated = new AtomicInteger(); // 생성한 쓰레드의 수  private final ThreadFactory factory = Executors.defaultThreadFactory(); // 쓰레드 팩토리  @Override public Thread newThread(Runnable r) { numCreated.incrementAndGet(); // 쓰레드 새로 만드는 시점에 증가시킴  return factory.newThread(r); } public void testPoolExpansion() throws InterruptedException { int MAX_SIZE = 10; TestingThreadFactory threadFactory = new TestingThreadFactory(); ExecutorService exec = Executors.newFixedThreadPool(MAX_SIZE, threadFactory); for(int i=0; i\u0026lt;10 * MAX_SIZE; i++) { exec.execute(new Runnable() { public void run() { try { Thread.sleep(Long.MAX_VALUE); } catch(InterruptedException e) { Thread.currentThread().interrupt(); } } }); } for (int i=0; i\u0026lt;20 \u0026amp;\u0026amp; threadFactory.numCreated.get() \u0026lt; MAX_SIZE; i++) { Thread.sleep(100); } assertEquals(threadFactory.numCreated.get(), MAX_SIZE); // 제대로 동작했다면 10개 쓰레드 생성되고 90개는 queueing 되었어야함  exec.shutdownNow(); } } 12.1.6 쓰레드 교차 실행량 확대 #   병렬프로그래밍의 오류는 concurrency 이슈가 많음. 이를 재현하기는 쉽지 않음 쓰레드의 컨택스트 스위칭을 의도적으로 높이면 이런 오류가 나올 확률을 높일 수 있음  Thread.yield() OS에 현재 Thread를 재 스케줄 해도 된다는 힌트를 줌. JVM에 따라 무시하기도 함 Thread.sleep() 강제로 현재 쓰레드를 sleep 상태로 빠지게함. 속도가 약간 느리지만 효과는 명확함 테스트에만 사용하고 제품에서 빼고 싶을 때는 AOP 활용    public synchronized void transferCredits(Account from, Account to, int amount) { from.setBalance(from.getBalance() - amount); if(random.nextInt(1000) \u0026gt; THRESHOLD) { Thread.yield(); } to.setBalance(to.getBalance() + amount); } 12.2 성능 테스트 #   성능테스트는 특정 사용환성 시나리오를 정하고, 시나리오를 통과하는데 얼마만큼의 시간이 걸리는지 측정 의미있는 사용환경을 가정해야함 하드웨어의 영향도 많이 받음(CPU의 수, 메모리 용량, CPU 종류)  12.2.1 PutTakeTest의 시간 측정 #   기존 PutTakeTest에 시간 측정을 넣으려 함 Barrier 적용 부분에 타이머 구현  public class BarrierTimer implements Runnable { private boolean started; private long startTime, endTime; @Override public void run() { long t = System.nanoTime(); if(!started) { started= true; startTime = t; } else { endTime = t; } } public synchronized void clear() { started = false; } public synchronized long getTime() { return endTime - startTime; } } public class TimedPutTakeTest { /*배리어 기반 타이머 사용 테스트*/ private static final ExecutorService pool = Executors.newCachedThreadPool(); private final AtomicInteger putSum = new AtomicInteger(0); private final AtomicInteger takeSum = new AtomicInteger(0); private final CyclicBarrier barrier; private final BoundedBuffer\u0026lt;Integer\u0026gt; bb; private final int nTrials, nPairs; private finnal BarrierTimer timer; public TimedPutTakeTest(int capacity, int npairs, int ntrials) { this.bb = new BoundedBuffer\u0026lt;Integer\u0026gt;(capacity); this.nTrials = ntrials; this.nPairs = npairs; this.timer = new BarrierTimer(); this.barrier = new CyclicBarrier(npairs*2+1, timer); // Runnable을 생성자에 넣어줌  } public void test() { try { timer.clear(); for(int i=0; i\u0026lt;nPairs; i++) { pool.execute(new Producer()); pool.execute(new Consumer()); } barrier.await(); barrier.await(); long nsPerItem = timer.getTime() / (nPairs * (long)nTrials); System.out.println(\u0026#34;Throughput: \u0026#34; + nsPerItem + \u0026#34; ns/item\u0026#34;); assertEquals(putSum.get(), takeSum.get()); }catch (Exception e) { throw new RuntimeException(e); } } public static void main(String[] args) throws Exception\t{ int tpt = 100000; //쓰레드별 실행횟수  for(int cap=1; cap\u0026lt;=1000; cap*=10) { //버퍼 용량  System.out.println(\u0026#34;Capacity: \u0026#34;+cap); for(int pairs=1; pairs\u0026lt;=128; pairs*=2) { // 쓰레드 수  TimedPutTakeTest t = new TimedPutTakeTest(cap, pairs, tpt); System.out.println(\u0026#34;Pairs: \u0026#34; + pairs); t.test(); System.out.println(\u0026#34;\u0026#34;); Thread.sleep(1000); t.test(); System.out.println(\u0026#34;\u0026#34;); Thread.sleep(1000); } } pool.shutdown(); } }  테스트 결과는 책 참조\u0026hellip; 버퍼가 크기가 크면 선능 증가 쓰레드 수는 오히려 성능 악화  12.2.2 다양한 알고리즘 비교\n ArrayBlockingQueue나 LinkedBlockingQueue 에 비하면 BoundedBuffer는 성능 떨어짐 가장 큰 이유는 put과 take 모두 쓰레드 경쟁하기 때문 잘 튜닝된 알고리즘은 큐의 처음과 끝에 동시에 접근 할 수 있음(put과 take가 별개의 락을 가짐)  12.2.3 응답성 측정 #   앞에서는 처리량을 봄 단일작업을 처리하는데 걸리는 시간 측정이 중요할 수도 있다. 또 분산도 측정해야 한다. 평균은 오래걸리지만 균일한 시간을 보장하는게 중요할 수도.. ex) \u0026ldquo;100ms 내에 끝나는 작업의 비율이 몇 %인가\u0026rdquo;, QOS 공정 세마포어, 불공정 세마포어 는 13.3절에서 다룸 PASS~  12.3 성능 측정의 함정 피하기 #  12.3.1 가비지 컬렉션 #   GC는 언제 실행될지 알 수 없음 테스트 동안 GC가 일어날 수 있다는 점을 감안해야 함  12.3.2 동적 컴파일 #   최근 JVM들은 바이트코드 인터프리트와 동적 컴파일을 혼용해 사용함 처음에는 클래스의 바이트코드를 이너프리터해서 실행하고, 해당 메소드 호출이 잦아지면 그 때 기계어로 동적 컴파일함 역시 언제 실행될지 알 수 없음 컴파일 과정에서 CPU 상당부분 소모 컴파일된 후에는 인터프리트 속도는 의미 없음 어떤 경우에는 컴파일된 코드를 다시 디컴파일해서 인터프리트하기도 함 간단한 해결책은 긴 시간(최소 몇분 이상) 프로그램을 실행시켜 미리 컴파일을 시켜놓는 것(워밍업 스테이지) Hotspot JVM은 --XX:=PrintCompilation 옵션으로 동적 컴파일시 메세지 출력하게 할 수 있음  12.3.3 비현실적인 코드 경로 샘플링 #   런타임 컴파일러는 자기 맘대로 최적화함. 그래서 문제 발생할 수 있음  12.3.4 비현실적인 경쟁 수준 #   병렬 어플리케이션은 두 종류의 작업을 번갈아 실행하는 구조(프로듀서, 컨슈머) 예를 들어 N개 쓰레드가 공유하는 작업 큐에서 작업을 가져다 실행한다 했을 때  각 작업이 CPU 중심이며 오래 걸리는 작업이라면 쓰레드 경쟁은 거의 발생하지 않음. 실행시간은 CPU 성능에 의존 개별 작업이 아주 빠르게 끝나는 작업이라면 쓰레드 경쟁이 높아지고 동기화 방법에 따라 실행시간 좌우   병목이 어디인지 파악하는게 중요. 쓰레드 경쟁 vs CPU 작업  12.3.5 의미없는 코드 제거 #   컴파일러는 의미없어 보이는 코드를 그냥 제거해버린다. 정적 컴파일언어는 기계어 코드 보면 되지만(?) 동적 컴파일 언어는 이런 정보 얻기 힘들다. 핫스팟 JVM 클라이언트 모드보다 서버 모드가 실행 결과 좋음(최적화 능력이 좋기 때문에) 예를 들어 PutTakeTest에서 체크썸 합하는 부분도 하는일이 없기 떄문에 최적화될 가능성 존재 해당 체크썸을 출력해서 사용값이라는 걸 알려줄 수 있음.. 하지만 IO 부하 들어감 그럴 땐 아래 처럼 거의 실행되지 않을 코드를 넣어서 최적화를 막아보자  if(foo.x.hashCode() == System.nanoTime()) System.out.print(checkSum);  매번 정적인 값들을 넣고 실행하는 경우 컴파일러가 최적화할 수도 있음  12.4 보조적인 테스트 방법 #  12.4.1 코드 리뷰 #   테스트 보다 좋을 때가 있음\u0026hellip;. 주석 자세히 달면서 유지보수 비용 낮출 수 있음  12.4.2 정적 분석 도구 #   대표적인 기능들  일관적이지 않은 동기화 Thread.run 호출 해제되지 않는 락 빈 Synchronized 블럭 더블 체크 락(16장 참조) 생성자에서 쓰레드 실행 조건부 대기 오류 Lock과 Condition의 오용 락 확보하고 대기상태 진입 스핀 반복분    12.4.3 관점 지향 테스트 방법 #   AOP 쓰자!  12.4.4 프로파일러 모니터링 도구 #   프로파일러 제품 써서 CPU나 쓰레드양 실시간 체크 하는 것도 좋은 방법  "},{"id":2,"href":"/TIL/concurrency/ch02_thread_safety/","title":"Thread Safety","section":"Java Concurrency","content":"쓰레드 안전성 #    객체의 상태(object\u0026rsquo;s state) = 인스턴스나 static 변수 같은 상태 변수에 저장된 객체의 데이터\n  공유되었다(shared) = 여러 쓰레드가 특정 변수에 접근할 수 있다\n  변경할 수 있다(mutable) = 해당 변수 값이 변경될 수 있다\n  쓰레드 안전성(Thread safety) = 데이터에 제한 없이 동시에 접근하는걸 막으려는 것\n  하나 이상의 쓰레드가 상태 변수에 접근하고, 하나라도 변수에 값을 쓰면 해당 변수에 접근할 때 관련 쓰레드는 동기화 사용해야 함\n  자바에서 동기화 수단: synchronized, volaitile, 명시적 락, atomic variable\n   여러 쓰레드가 동기화 없이 변경 가능한 하나의 상태 변수에 접근하면 잘못된 프로그램임.이를 고치려면 상태 변수를 쓰레드 간 공유하지 않거나(thread-local, single-threaded) 상태 변수를 변경 불가능하게 하거나(immutable)상태 변수를 접근할 땐 언제나 동기화 한다(synchronization)  쓰레드 안전한 클래스를 설계할 때 , 캡슐화, 불변 객체를 잘 활용하고 불변 조건을 명확히 기술해야 한다.\n 2.1 쓰레드 안전성(thread safety)이란 #   여러 쓰레드가 한 클래스에 접근할 때, 실행 환경(OS..?)이 해당 쓰레드들을 어떻게 스케줄하든 호출하는 쪽(Caller)에서 추가적인 동기화나 다른 조율 없이도 정확하게 동작하면 해당 클래스는 쓰레드 안전하다고 말한다. (\u0026lsquo;정확하게\u0026rsquo; 라는건 클래스가 명세대로 동작함을 의미한다.)\n  쓰레드 안전한 클래스는 클라이언트 쪽에서 별도로 동기화할 필요 없도록 동기화 기능이 캡슐화 되어 있다.\n 2.1.1 상태없는 서블릿 (stateless servlet) #  인수분해할 숫자를 request에서 가져와 인수분해하고 response에 담는다.\n@ThreadSafe public class StatelesFactorizer implments Servlet { public void service(ServletRequest req, ServletResponse resp) { BigInteger i = extractFromRequest(req); BigInteger[] factors = factor(i); encodeIntoResponse(resp, factors); } }  맴버 변수 없음 다른 클래스 맴버변수 참조 안함 일시적 상태는 local variable에 저장  따라서 stateless 하기 때문에 항상 thread-safe 하다.\n Stateless Objects 는 항상 Thread-safe 하다\n 2.2 단일 연산 (Atomicity) #  위 클래스에 요청 횟수를 기록하는 접속 카운터를 추가.\n@NotThreadSafe public class UnsafeCountingFactorizer implments Servlet { private long count = 0; public getCount(){ return count;} public void service(ServletRequest req, ServletResponse resp) { BigInteger i = extractFromRequest(req); BigInteger[] factors = factor(i); ++count; // critical section  encodeIntoResponse(resp, factors); }  ++ 연산은 내부적으로 3개의 단일 연산의 시퀀스로 구성( 현재 값 가져오기/1더하기/새 값 저장하기) (load, add, mov 아마도..?) 이 부분에서 여러 쓰레드가 접근하면 문제 발생 가능 경쟁 조건(race condition) 생김.  2.2.1 경쟁 조건 (race condition) #  UnsafeCountingFactorizer 는 경쟁 조건이 나타나기 때문에 결과를 신뢰할 수 없다. 경쟁 조건은 상대적인 시점이나, 런타임이 여러 쓰레드를 교차해서 실행하는 상황에 따라 계산의 정확성이 달라질 때 나타난다. 가장 일반적인 경쟁 조건 형태는 점검 후 행동(check-then-act) 이다. (점검 후 행동은 stale data가 다음 행동을 결정하는 형태)\n2.2.2 늦은 초기화 시 경쟁 조건 #  점검 후 행동하는 가장 흔한 예제는 늦은 초기화(lazy initialization) 가 있다. 늦은 초기화는 필요한 시점에 딱 한 번만 초기화 하기 위한 프로그래밍 기법.\n@NotThreadSafe public class LazyInitRace { private ExpensiveObject instance = null; public ExpensiveObject getInstance() { if(instance == null) { //critical seciton  instance = new ExpensiveObject(); } return instance; } } 쓰레드 A, B가 같은 LazyInitRace 객체에 접근해서 getInstance()를 호출하면 문제 발생할 수 있음 여러 쓰레드가 getInstance 메소드에 접근하면 경쟁 조건 발생함.\nUnsafeCountingFactoriezer 은 도 따른 형턔의 race-condition 이다. read-modify-write 는 이전 상태를 기준으로 객체 상태를 변경하는 동작이다.\nrace condition은 항상 실패하진 않는다. 하지만 치명적인 문제를 야기할 수 있다.\n2.2.3 복합 동작 (compound actions) #   작업 A를 실행 중인 쓰레드 관점에서 다른 쓰레드가 작업 B를 실행할 때 작업 B가 모두 수행됐거나 또는 전혀 수행되지 않은 두가지 state 로만 파악된다면 작업 A의 눈으로 볼 때 작업 B는 단일 연산이다. 단일 연산은 자신을 포함해 같은 state를 다루는 모든 작업이 단일 연산인 작업을 지칭한다.\n  UnsafeCountingFactorizer 에서 ++count 가 단일 연산이었다면? 경쟁 조건 생길 수 없음 점검 후 행동, 읽고 수정하고 쓰기 등과 같은 일련의 동작을 복합 동작이라고 함 쓰레드에 안전하기 위해선 단일 연산이 수반되어야 함  다음은 쓰레드 안전한 기존 클래스 이용해 Count 예제를 고친 것\n@ThreadSafe public class CountingFactorizer implements Servlet { private final AtomicLong count = new AtomicLong(0); public long getCount() {return count.get();} public void service(ServletRequest req, ServletResponse resp) { BigInteger i = extractFromRequest(req); BigInteger[] factors = factor(i); count.incrementAndGet(); encodeIntoResponse(resp, factors) } }  java.util.concurrent.atomic 패키지에는 숫자 및 객체 참조에 대해 상태를 단일 연산으로 변경할 수 있는 atomic variable class 가 있음 servlet 의 상태는 count 이고 이 count가 쓰레드 안전하므로 servlet도 쓰레드 안전하다.   가능하면 클래스 상태는 AtomicLong 처럼 이미 안전하게 만들어 둔 것을 사용하는 것이 좋다.\n concurrent.atomic 패키지 (jdk8) #  // AtomicBoolean, AtomicInteger, AtomicLong, AtomicReference\u0026lt;V\u0026gt;, AtomiStampedReference\u0026lt;V\u0026gt;, AtomicMarkableReference //A-B-A 문제 풀기위해... // AtomicIntegerArray, AtomicIntegerFieldUpdater\u0026lt;T\u0026gt;, AtomicLongArray, AtomicLongFieldUpdater\u0026lt;T\u0026gt;, AtomicReferenceArray, AtomicReferenceFieldUpdater\u0026lt;T,V\u0026gt; // DoubleAdder, LongAdder, DoubleAccumulator, LongAccumulator public class AtomicBoolean { boolean compareAndSet(boolean expected, boolean update); // expected와 맞아야지만 update 함  boolean get(); boolean getAndSet(boolean newValue); boolean lazySet(boolean newValue); // memory-model 에서 store-load 를 store-store 로 해서 퍼포먼스 향상... GC 위한 nullable 할 때 많이 쓴다고 함  boolean set(boolean newValue); boolean weakCompareAndSet(boolean expected, boolean update); // 거의 안 씀.. } //https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/atomic/package-summary.html The memory effects for accesses and updates of atomics generally follow the rules for volatiles, as stated in section 17.4 of The Java™ Language Specification. get has the memory effects of reading a volatile variable. set has the memory effects of writing (assigning) a volatile variable. lazySet has the memory effects of writing (assigning) a volatile variable except that it permits reorderings with subsequent (but not previous) memory actions that do not themselves impose reordering constraints with ordinary non-volatile writes. Among other usage contexts, lazySet may apply when nulling out, for the sake of garbage collection, a reference that is never accessed again. weakCompareAndSet atomically reads and conditionally writes a variable but does not create any happens-before orderings, so provides no guarantees with respect to previous or subsequent reads and writes of any variables other than the target of the weakCompareAndSet. compareAndSet and all other read-and-update operations such as getAndIncrement have the memory effects of both reading and writing volatile variables. 2.3 락 #   인수분해 결과를 캐시하려함 가장 마지막 인수분해한 숫자를 lastNumber, 그 결과를 lastFactors 에 담는다.  @NotThreadSafe public class UnsafeCachingFactorizer implements Servlet { private final AtomicReference\u0026lt;BigInteger\u0026gt; lastNumber = new AtomicReference\u0026lt;\u0026gt;(); private final AtomicReference\u0026lt;BigInteger[]\u0026gt; lastFactors = new AtomicReference\u0026lt;\u0026gt;(); public void service(ServletRequest req, ServletResponse resp) { BigInteger i = extractFromRequest(req); // 첫번째 취약점  if (i.equals(lastNumber.get())) { encodeIntoResponse(resp, lastFactors.get()); } else { BigInteger[] factors = factor(i); // 두번째 취약점  lastNumber.set(i); lastFactors.set(factors); encodeIntoResponse(resp, factors); } } }  참조 자체는 쓰레드 안전하지만 결과는 틀릴 수 있다. set() 과 get() 이 2개의 메소드이기 때문에 Atomic하지 않다.   상태를 일관성 있게 유지하려면 관련 있는 변수들을 하나의 단일 연산으로 갱신해야 한다.\n 2.3.1 암묵적인 락(intrinsic lock) #   자바에서는 단일 연산 보장 위해 synchronized 키워드 제공 락으로 사용될 객체의 참조와 락으로 보호하려는 코드 블록으로 구성 메소드 선언에 synchronized 를 지정하면 매소드 내부 전체를 포함하며 메소드가 포함된 클래스의 인스턴스를 락으로 사용(static method는 클래스 객체를 락으로 사용)  synchronized (lock) { // lock으로 보호된 영역 }  모든 자바 객체는 락으로 사용 가능 락은 thread 가 synchronized 블록 들어가기 전에 자동으로 확보되어 해당 블록 벗어날 때 자동으로 해제됨 자바의 경우 mutex로 구현  @Threadsafe public class SnchronizedFactorizer implements Servlet { @GuardedBy(\u0026#34;this\u0026#34;) private BigInteger lastNumber; @GuardedBy(\u0026#34;this\u0026#34;) private BigInteger[] lastFactors; public synchronized void service(ServletRequest req, ServletResponse resp) { BigInteger i = extractFromRequest(req); if (i.equals(lastNumber.get())) { encodeIntoResponse(resp, lastFactors.get()); } else { BigInteger[] factors = factor(i); lastNumber.set(i); lastFactors.set(factors); encodeIntoResponse(resp, factors); } } }  메소드에 synchronized 달아서 쉽게 고칠 수 있음. 성능 매우 떨어질 수 있음  2.3.2 재진입성(reentrant) #   암묵적인락은 재진입 가능하기 때문에 자기가 이미 획득한 락을 다시 확보할 수 있음 락 동작을 쉽게 캡슐화 가능 재진입성 없으면 자식 class 에서 override 한 후 부모 class 메소드 호출하면 데드락 걸릴 수 있음  public class Widget { public synchronized void doSomething(){} } public class LoggingWidget extents Widget { pbulic synchronized void doSomething() { super.doSomething(); } } 2.4 락으로 상태 보호하기 #   여러 쓰레드에서 접근할 수 있고 변경 가능한 모든 변수를 대상으로 해당 변수에 접근할 때는 항상 동일한 락을 먼저 확보한 상태여야 한다. 이 경우 해당 변수는 확보된 락에 의해 보호된다고 한다.\n  객체의 암묵적인 락과 그 객체의 상태에는 특별한 관계는 없음 쓰기 쉬워서 default로 해놓은 것일 뿐임 공유 상태에 안전하게 접근할 수 있도록 락 규칙이나 동기화 정책을 만들고 프로그램 내에서 규칙과 정책을 일관성 있게 따르는 건순전히 개발자에게 달림   모든 변경할 수 있는 공유 변수는 정확하게 단 하나의 락으로 보호해야 한다. 유지 보수하는 사람이 알 수 있게 어느 락으로 보호하고 있는지를 명확하게 표시하라(@GuardedBy)\n  synchronized 동기화의 해법은 아님 Vector 는 모든 메소드가 단순 동기화되어 있음. 여러 메소드를 섞으면 또 다른 락이 필요함  if (!vector.contains(element)) { vector.add(elements); }  동기화를 통해 메소드 각각을 단일 연산화 시킬 수 있지만,여러 메소드를 복합으로 사용하려면 추가 동기화 필요. 모든 메소드를 동기화 하면 성능에 문제 생길 수 있음  2.5 활동성과 성능 #   동기화를 단순하고 큰 단위로 접근하면 안전하지만 성능 감소가 매우 큼 SynchronizedFactorizer 예제의 경우 service 실행을 한번에 한 쓰레드만 할 수 있음 병렬처리 능력이 떨어지게 됨  @ThreadSafe public class CachedFactorizer implements Servlet { @GuardedBy(\u0026#34;this\u0026#34;) private BigInteger lastNumber; @GuardedBy(\u0026#34;this\u0026#34;) private BigInteger[] lastFactors; @GuardedBy(\u0026#34;this\u0026#34;) private long hits; @GuardedBy(\u0026#34;this\u0026#34;) private long cacheHits; public synchronized long getHits() {return hits;} public synchronized double getCacheHitRatio() { return (double) cacheHits / (double) hits; } public void service(ServletRequest req, ServletResponse resp) { BigInteger i = extractFromRequest(req); BigInteger[] factors = null; synchronized (this) { ++hits; if (i.equals(lastNumber)) { ++cacheHits; factors = lastFactors.clone(); } } if (factors == null) { factors = factor(i); synchronized(this) { lastNumber = i; lastFactors = factors.clone(); } } encodeIntoResponse(resp, factors); } }  접속카운터(hits) 를 AtomicLong 대신 long으로 사용. 이미 synchronized 블럭 내에서 처리하기 때문에 성능이나 안전성 측면에서 이득이 없음 단순성(전체 메소드 동기화) 병렬 처리 능력(짧은 부분만 동기화) 사이에 균형을 맞춤 락을 잡고 놓는 것 자체도 부하가 있음. 너무 짧게 sync 블럭을 나누는 것도 좋지 않음 위의 경우 오래 걸릴 가능성이 높은 인수분해 시에는 락을 놓는다. 이렇게 하므로써 병렬 처리 능력에 영향을 주지 않으면서 쓰레드 안전성 확보. 각 sync block 은 충분히 짧다(어떻게 계산하지..?)   종종 단순성과 성능이 서로 상출할 때가 있다. 동기화 정책을 구현할 때는 성능을 위해 조급하게 단순성(잠재적으로 안전성을 훼손하면서)을 희생하고픈 유혹을 버려야 한다.\n  락을 사용할 땐 블록 안 코드가 수행하는 일과 수행 예측 시간을 파악해야 함. 계산량이 많거나 쓰레드가 잠들 수 있는 작업을 하느라 락을 오래 잡고 있으면 성능 문제가 야기 될 수 있다.   복잡하고 오래 걸리는 계산 작업, 네트워크 작업, 사용자 입출력 작업과 같이 빨리 끝나지 않을 수 있는 작업을 하는 부분에서는 가능한 락을 잡지 마라\n "},{"id":3,"href":"/TIL/designpattern/behavioralpatterns/chain-of-responsibility/","title":"Design Pattern","section":"Design Pattern","content":"Chain of responsibility #  어떤 프로세스가 일어 났을때 그 책임을 적당한 대상한테 넘겨주게 됩니다. 이 패턴은 하나의 클래스의 인스턴스들 간의 체인이라기보다는 여러 클래스 간에 걸쳐 이루어지는 일이기 때문에 구조가 다른 클래스에 대해서 낮은 결합도로 동일한 이벤트에 대한 핸들링을 가능하게 한다는 점에서 주목할 만합니다. 사슬에 들어가는 객체를 바꾸거나 순서를 바꿈으로써 역할을 동적으로 추가/제거 할 수 있습니다.\nIntent #  둘 이상의 오브젝트에 요청을 처리 할 수있는 기회를 주면 요청 송신자와 수신자를 연결하지 마십시오. 수신 객체를 연결하고 객체가 처리 할 때까지 체인을 따라 요청을 전달합니다.\nImplementation #  class Handler{ private int id; private Handler nextChain;\npublic Handler add(Handler next) { if (!nextChain){ nextChain = next; } else { nextChain.add(next); } }  } // main(client) 에서는 handler의 종류를 알 필요가 없으므로 // manager class를 두어 chain을 생성하거나, 맨 앞 chain만 외부로 노출시킨다. // 하지만 여기선 복잡해져서 그런건 생각하지 않았다\nConsequences #   결합도를 감소시킨다. 이 패턴은 어떤 object가 request를 처리하는지 몰라도 된다. 모든 object에 대한 참조를 갖지 않고, 하나의 successor에 대한 참조만 하면 된다. 객체에 책임을 주는데 유연성이 생긴다. 요청이 수행된다는 보장이 없다. 처리하는데 걸리는 시간을 정확히 예측할 수 없다.  "},{"id":4,"href":"/TIL/designpattern/behavioralpatterns/command/","title":"Design Pattern","section":"Design Pattern","content":"Command #  Intent #  Implementation #  Consequences #  "},{"id":5,"href":"/TIL/designpattern/behavioralpatterns/iterator/","title":"Design Pattern","section":"Design Pattern","content":"Iterator #  Intent #  여러 객체들 간의 상호작용 자체를 encapsulation하는 객체를 정의한다. 객체들끼리 직접 참조하는 것을 피함으로써 객체들 간의 연결 강도를 줄인다. 객체들과 독립적으로 상호작용을 변경할 수 있다.\nImplementation #  Consequences #  "},{"id":6,"href":"/TIL/designpattern/behavioralpatterns/memento/","title":"Design Pattern","section":"Design Pattern","content":"memento pattern #  Intent #    예전 상태를 기억하기 용이한 패턴. 주로 현재 상태를 기억했다가 롤백이 필요한 시점에서 쉽게 돌아가는 방식이다. 바둑 장기등의 되돌리기, editor의 undo, browser의 뒤로가기 등이 있다.\n  참가자 : memento, originator, careTaker\n originator: 객체 본래의 기능에 출실 memento: 내부 상태를 저장 careTaker: memento 들을 관리  Implementation #  public class Memento{ private String state; public Memento(String state){ this.state = state; } public String getState(){ return this.state; } } public class CareTaker{ private List mementoList = new ArrayList(); public void add(Memento memento){ this.mementoList.add(memento); } public Memento get(int idx){ return this.mementoList.get(idx); } } public class Originator{ private String state; public void setState(String state){ this.state = state; } public String getState(){ return this.state; } public Memento saveStateToMemento(){ return new Memento(this.state); } public void getStateFromMemento(Memento memento){ setState(memento.getState()); } } public class MementoMain{ public static void main(String[] args){ Originator originator = new Originator(); CareTaker careTaker = new CareTaker(); originator.setState(\u0026#34;state 1\u0026#34;); careTaker.add(originator.saveStateToMemento()); // state 1 저장 \toriginator.setState(\u0026#34;state 2\u0026#34;); originator.getStateFromMemento(careTaker.get(0)); //state 1 불러오기 \t} } Consequences #   상태정보와 관리를 기능과 분리해서 독립적으로 관리할 수 있다. 오리지널 객체는 상태 관리의 부담을 덜면서 본래 기능에 충실 할 수 있다. 메멘토 클래스로 들어오는 상태가 커지면 메멘토 클래스의 부담이 커진다.  "},{"id":7,"href":"/TIL/designpattern/behavioralpatterns/observer/","title":"Design Pattern","section":"Design Pattern","content":"Observer Pattern #  Intent #    상태를 가지고 있는 subject 와 변경을 알아야하는 observer 가 존재하며 이들의 관계는 1:1, 1:N 이 될수 있다. publisher-subscriber 관계라 볼 수 있다.\n   한 객체가 다른 객체에 의존적일 때 한 객체의 변화가 다른 객체의 변화를 일으킬 때 한객체가 다른객체에게 notify 날리고 싶을 때  Implementation #  public interface Subject{ public void attach(Observer observer); public void detach(Observer observer); public void notify(); } public interface Observer{ public void update(); } Consequences #  "},{"id":8,"href":"/TIL/designpattern/creationalpatterns/abstract-factory/","title":"Design Pattern","section":"Design Pattern","content":"Abstract Factory Pattern #  Intent #  관련성 있는 어려 종류의 객체를 특정 그룹으로 묶어 한번에 일관된 방식으로 생성하고 교체할 수 있도록 만든 디자인 패턴이다.\nImplementation #  // factory method 사용할 경우 public enum VenderID{LG, SAMSUNG, APPLE} public class ScreenFactory{ public static Screen createScreen(VendorID vendorID){ Screen screen = null; switch(vendorID){ case LG: screen = new LGScreen(); break; case SAMSUNG: screen = new SAMSUNGScreen(); break; case APPLE: screen = new APPLEScreen(); } return screen; } } public class FrameFactory{ public static Frame createFrame(VendorID vendorID){ Frame frame = null; switch(vendorID){ case LG: frame = new LGFrame(); break; case SAMSUNG: frame = new SAMSUNGFrame(); break; case APPLE: frame = new APPLEFrame(); break; } return frame; } } public class client{ public static void main(String[] args){ Frame frame = FrameFactory.createFrame(VendorID.APPLE); Screen screen = ScreenFactory.createScreen(VendorID.APPLE); Phone phone = new PhoneBuilder().setFrame(frame).setScreen(screen).build(); //... \t} } 문제: 제조사에 화웨이나 소니 등 다른 업체가 추가되면 각각 팩토리의 switch 문을 수정해야 한다.\n어차피 객체 사이에 연관성이 있기 때문에 모아서 만들자!\npublic enum VenderID{LG, SAMSUNG, APPLE} public interface PhoneFactory{ public Frame createFrame(); public Screen createScreen(); } public class LGPhoneFactory implements PhoneFactory{ public Frame createFrame(){ return new LGFrame(); } public Screen createScreen(){ return new LGScreen(); } } public class SAMSUNGPhoneFactory implements PhoneFactory{ public Frame createFrame(){ return new SAMSUNGFrame(); } public Screen createScreen(){ return new SAMSUNGScreen(); } } public class APPLEPhoneFactory implements PhoneFactory{ public Frame createFrame(){ return new APPLEFrame(); } public Screen createScreen(){ return new APPLEScreen(); } } public class client{ public static void main(String[] args){ PhnoeFactory aPPLEPhoneFactory = new APPLEPhoneFactory(); Frame frame = aPPLEPhoneFactory.createFrame(); Screen screen = aPPLEPhoneFactory.createScreen(); Phone phone = new PhoneBuilder(VendorID.APPLE).setFrame(frame).setScreen(screen).build(); //... \t} } 만약 화웨이 폰이 추가된다면? 화웨이폰factory implements PhoneFactory 만 구현하면 된다.\npublic class APPLEPhoneFactory implements PhoneFactory{ public Frame createFrame(){ return new APPLEFrame(); } public Screen createScreen(){ return new APPLEScreen(); } public Phone createPhone(){ return new IPhone().setFrame(this.createFrame()).setScreen(this.createScreen()); } } public class client{ public static void main(String[] args){ PhnoeFactory aPPLEPhoneFactory = new APPLEPhoneFactory(); Phone phone = aPPLEPhoneFactory.createPhone(); phone.call(); //... \t} } Consequences #   concrete classes 들을 숨긴다. product families 교환을 쉽게 한다. 같은 상속을 받는 product 간 consistency를 증가시킨다. 새로운 product의 추가는 어려워진다.  "},{"id":9,"href":"/TIL/designpattern/creationalpatterns/builder/","title":"Design Pattern","section":"Design Pattern","content":"Builder Pattern #  Intent #  인스턴스를 생성할 때 생성자 만을 통해서 생성하는데에는 어려움이 있다. 생성자 인자가 너무 많은 경우 어떠한 인자가 어떠한 값을 나타내는지 확인하기 힘들다. 또 어떠한 인스턴스는 특정인자만으로 생성해야 하는 경우가 발생한다. telescoping constructor pattern은 클래스가 지저분해진다. java bean pattern은 일관성이 깨지고, immutable한 객체 생성이 불가능하다.\nImplementation #  telescoping constructor pattern 과 java bean pattern을 조합한다. 앱들이를 만드는 클래스를 생성한다.\n//AppleMan.java public class AppleMan{ private String name; private int age; private String phone; private String notebook; private String tablet; public student(){} public static class Builder { private String name; private int age; private String phone; private String notebook; private String tablet; public Builder(String name, int age){ this.name = name; this.age = age; } public Builder phone(String phone){ this.phone = phone; return this; } public Builder notebook(String notebook){ this.notebook = notebook; return this; } public Builder tablet(String tablet){ this.tablet = tablet; return this; } public AppleMan build(){ return new AppleMan(this); } private Appleman(Builder builder){ this.name = builder.name; this.age = builder.age; this.phone = builder.phone; this.notebook = builder.notebook; this.tablet = builder.tablet; } } } //main.java AppleMan man = new AppleMan.Builder(\u0026#34;sangmoon\u0026#34;, 26) .phone(\u0026#34;iphone se\u0026#34;) .notebook(\u0026#34;macbook pro\u0026#34;) .tablet(\u0026#34;ipad pro\u0026#34;) .build(); Consequences #   클래스 내부 표현을 다양화 할 수 있다. 객체 생성과 표현을 분리할 수 있다. 객체 생성에 대해 더 멋지게 조절 할 수 있다.  "},{"id":10,"href":"/TIL/designpattern/creationalpatterns/factory-method/","title":"Design Pattern","section":"Design Pattern","content":"Factory method pattern #  Intent #  객체 생성을 캡슐화 한다. client는 new라는 키워드를 사용하지 않고, 팩토리의 메소드를 호출하는 방식으로 객체를 받는다.\nImplementation #  Consquences #   sub-class 에 hook을 제공한다.   참조 #   매개변수 팩토리 메소드의 형안정성  "},{"id":11,"href":"/TIL/designpattern/creationalpatterns/prototype/","title":"Design Pattern","section":"Design Pattern","content":"Prototype Pattern #  "},{"id":12,"href":"/TIL/designpattern/creationalpatterns/readme/","title":"Design Pattern","section":"Design Pattern","content":"##Creational Patterns\nCreational Patterns은 생성 과정을 추상화합니다.이 방식은 시스템이 객체 생성, 연동, 표현 하는 방법에 독립적이게 합니다. class creational pattern은 상속을 사용하여 인스터스화된 클래스를 다양화 합니다. 반면 object creational pattern은 다른 객체에 인스턴스화를 위임합니다.\n Abstact Factory Builder Factory method Prototype Singleton  "},{"id":13,"href":"/TIL/designpattern/creationalpatterns/singleton/","title":"Design Pattern","section":"Design Pattern","content":"Singleton Pattern #  Intent #  Class에 대해 하나의 instance만 가지고 싶을 때\u0026hellip;\nImplementation #   기본구현 getInstance 를 synchronized로 구현 인스턴스를 처음부터 만들어버림 DCL을 활용하여 volatile 로 싱클톤 인스턴스 선언을 하고 getInstance에서 싱글톤 클래스를 synchronized 해서 동기화 한다. inner class 이용한다  public class Singleton { private static class SingletonHolder { public static final Singleton instance = new Singleton(); } public static Singleton getInstance() { return SingletonHolder.instance; } } Consequences #  "},{"id":14,"href":"/TIL/designpattern/structualpatterns/decorator/","title":"Design Pattern","section":"Design Pattern","content":"Decorator Pattern #  Intent #  상속을 받아 기능성을 확장하는 것 말고, 다른 방식으로 객체에 추가적 기능을 부여한다. (상속의 단점 보완)Wapper라고도 불린다. 직장인 클래스를 기준으로 해보자\u0026hellip;\nImplementation #  public interface Employee{ public int getSalary();\t} public class Researcher implements Employee{ private int year; @Override public int getSalary(){ return 10 + year; } } abstract public class EmployeeDecorator implements Employee{ protected Emplyee decoratedEmployee; public EmplyeeDecorator(Employee decoratedEmployee){ this.decoratedEmplyee = decoratedEmployee; } public int getSalary(){ return decoratedEmployee.getSalary(); } } public class 팀장 extends EmployeeDecorator{ public 팀장(Employee decoratedEmployee){ super(decoratedEmployee); } public int getSalary(){ return super.getSalary() + 1; } } public class 실장 extends EmployeeDecorator{ public 실장(Employee decoratedEmployee){ super(decoratedEmployee); } public int getSalary(){ return super.getSalary() + 5; } } public class 세자녀부모 exntends EmployeeDecorator{ public 세자녀부모(Employee decoratedEmployee){ super(decoratedEmployee); } public int getSalary(){ return super.getSalary() + 10; } } Consequences #   단순 상속보다 더 유연하다. 단순 기능 추가를 위해 클래스 설계를 쉽게 할 수 있다. decorator와 component 는 같지 않다.(object 관점에서) 작은 오브젝트들이 매우 많이 생성된다\u0026hellip;  "},{"id":15,"href":"/TIL/designpattern/structualpatterns/proxy/","title":"Design Pattern","section":"Design Pattern","content":"Proxy Pattern #  Intent #    일반적으로 프록시는 다른 무언가와 이어지는 인터페이스의 역할을 하는 클래스이다. 프록시는 어떠한 것(이를테면 네트워크 연결, 메모리 안의 커다란 객체, 파일, 또 복제할 수 없거나 수요가 많은 리소스)과도 인터페이스의 역할을 수행 할 수 있다.\n  참가자 : client, subject, real subject, proxy\n  같은 인터페이스를 상속 받기 때문에 실제 client는 real subject와 proxy 를 구분하지 않는다.\n  proxy 는 real subject에 대한 reference를 가지고 있다.\n  proxy 는 real subject에 대한 접근을 통제하고 생성,제거할 책임이 있다.\n  remote proxy: 다른 주소 공간에 있는 real subject로 request를 중계한다.\n  virtual proxy: real subject에 대한 추가 정보를 cache 해서 real object 생성을 최대한 연기한다.\n  protection proxy: caller가 권한이 있는지 체크한다.\n  real subject는 기능에만 충실\nImplementation #  interface Image { public void displayImage(); } // On System A class RealImage implements Image { private String filename = null; /** * Constructor * @param filename */ public RealImage(final String filename) { this.filename = filename; loadImageFromDisk(); } /** * Loads the image from the disk */ private void loadImageFromDisk() { System.out.println(\u0026#34;Loading \u0026#34; + filename); } /** * Displays the image */ public void displayImage() { System.out.println(\u0026#34;Displaying \u0026#34; + filename); } } // On System B class ProxyImage implements Image { private RealImage image = null; private String filename = null; /** * Constructor * @param filename */ public ProxyImage(final String filename) { this.filename = filename; } /** * Displays the image */ public void displayImage() { if (image == null) { image = new RealImage(filename); } image.displayImage(); } } class ProxyExample { /** * Test method */ public static void main(final String[] arguments) { final Image image1 = new ProxyImage(\u0026#34;HiRes_10MB_Photo1\u0026#34;); final Image image2 = new ProxyImage(\u0026#34;HiRes_10MB_Photo2\u0026#34;); image1.displayImage(); // loading necessary  image1.displayImage(); // loading unnecessary  image2.displayImage(); // loading necessary  image2.displayImage(); // loading unnecessary  image1.displayImage(); // loading unnecessary  } } Consequences #   remote proxy는 real object가 다른 address space에 있다는 것을 숨긴다. virtual proxy는 객체 생성을 최적화 할 수 있다.(on demand) real object에 접근할 때 추가적인 작업을 할 수 있게 해준다.  "},{"id":16,"href":"/TIL/django/django-urlconf/","title":"Django","section":"Django","content":"django2.0 부터 path, re_path 함수로 라우팅을 한다.\n(django_docs_link)[https://docs.djangoproject.com/en/2.0/topics/http/urls/#how-django-processes-a-request]\nfrom django.conf.urls import path, re_path from . import views urlpatterns = [ path(\u0026#39;index/\u0026lt;int:index_id\u0026gt;\u0026#39;, views.index, name=\u0026#39;index\u0026#39;), re_path(r\u0026#39;^index/(?P\u0026lt;index_id\u0026gt;\\d+)/$\u0026#39;), ] 위의 path()와 re_path는 같은 url을 나타낸 것이다. path에서는 정규식을 명시적으로 사용하지 않고 \u0026lt;\u0026gt; 로 단순한 패턴들을 매칭한다. int, str,slug, uuid, path 가 default path converter 이다. custom conveter 도 등록 가능하다. re_path의 경우 기존 urls.url 함수의 이름이 바뀐 것이다. 정규식으로 패턴을 표현한다.\n"},{"id":17,"href":"/TIL/django/request-post/","title":"Django","section":"Django","content":"view에서 user의 request를 보통 GET 과 POST로 받는다. browser에서 ajax POST request를 보낼 때 request.POST로 받으면 될 거라고 생각했는데, request.body로 바로 접근해야 한다. django에서 request.POST는 form data 같은 걸 받을 때 사용하는 것이다.\n"},{"id":18,"href":"/TIL/docker/docker-cmd/","title":"Docker","section":"Docker","content":"docker의 기본 명령어를 정리하자 #  도커 이미지 빌드\ndocker build -t cholsoo22001/orly . container 실행\ndocker run \\  --env AZURE_ACCOUNT_NAME=\u0026#34;\u0026#34; \\  --env AZURE_ACCOUNT_KEY=\u0026#34;\u0026#34; \\  -p 8080:8080 \\  cholsoo22001/orly Docker Hub에 이미지 배포\ndocker push cholsoo22001/orly Docker images 확인\ndocker images Docker image 삭제\ndocker rmi [image id] 모든 Container 확인\ndocker ps -a Container 삭제\ndocker rm [container id | container name] Container shell로 들어가기\ndocker exec -it [container id| container name] /bin/bash "},{"id":19,"href":"/TIL/effectivejava/classesandinterfaces/item15/","title":"Effective Java","section":"Effective Java","content":"Item 15: Minimize the accessibility of classess and members #  잘 설계된 컴포넌트는 상세 구현을 숨기고 API와 완벽히 분리해야 한다. Information hiding or encapsulation 으로 알려진 이 생각은 소프트웨어 디자인의 기본이다.\n캡슐화의 장점 #   병렬 개발을 통한 개발 속도 증가 독립적인 컴포넌트 분리로 인한 관리 비용 감소 성능 최적화에 도움 재사용성 증가 제작 난이도 감소  룰은 간단하다. 모든 클래스와 멤버의 접근성을 가능한 한 좁혀야 한다.\njava에서 가능한 access level #   private: 멤버들은 오직 해당 클래스에서만 접근 가능하다 package-private: 멤버는 해당 클래스가 선언되어 있는 패키지에서 접근 가능하다(접근자를 안쓰면 되는데, interface는 기본 public 이라 예외) protected: 패키지 내와 상속받은 클래스에서만 접근 가능하다 public: 어디서든 접근 가능하다     total In the class Same package Extended class Another area     private O X X X   package-private O O X X   protected O O O X   public O O O O    public class의 객체 필드는 public 이어선 안 된다.\npubic array 의 허점 #  public static final Thing[] VALUES = {...}; // client 가 배열 필드 참조를 받아서 수정할 수 있다. 해결책 1. immutable list #  private static final Thing[] PRIVATE_VALUES = {...}; public static final List\u0026lt;Thing\u0026gt; VALUES = Collections.unmodifiableList(Arrays.asList(PRIVATE_VALUES)); 해결책 2. array copy #  private static final Thing[] PRIVATE_VALUES = {...}; public static final Thing[] values() { return PRIAVTE_VALUES.clone(); } Java9 부터 나온 Module system #  class 모음은 packages, packages 의 모음이 module\n외부에 노출할 패키지는 명시적으로 export 해주어야 함. 외부 패키지에서 참조할 패키지는 명시적으로 require 해주어야 함. (java script 의 모듈화 방식과 유사하다..?)\nJDK 에서는 많이 쓰이고 있는데 실제 어플리케이션에는 아직 시기상조라고\u0026hellip;\n요약 #   API 설계 시 public 은 최소화 하자. public class 는 public static final 외 에는 public 필드를 가져서는 안 된다. public static final 필드도 immutable 인지 확인하자.\n "},{"id":20,"href":"/TIL/effectivejava/classesandinterfaces/item16/","title":"Effective Java","section":"Effective Java","content":"Item 16: In public classes, use accessor methods, not public fields #  가끔 필드 조합의 모음 정도의 클래스를 쓸 때가 있다.\nclass Point { public double x; public double y; } 이 때 필드는 public 이어선 안된다. 필드에 직접 접근이 가능해서 캡슐화의 이점을 전혀 얻을 수 없다. API를 바꾸지 않고는 아무것도 변경할 수 없다. getter와 setter로 바꿔야 한다.\nclass Point { private double x; private double y; public Point(double x, double y) { this.x = x; this.y = y; } public double getX() {return x;} public double getY() {return y;} public void setX(double x) {this.x = x;} public void setY(double y) {this.y = y;} } immutable 한 필드도 public 은 좋지 않다. #  public final class Time { public final int hour; public final int minute; } 불변성은 유지하겠지만, 추후 해당 필드 읽을 때 부수 작업을 할 수 없다.\n요약 #   public 클래스는 mutable field를 외부에 노출해선 안된다. immutable field 도 노출 하지 말자.\n "},{"id":21,"href":"/TIL/effectivejava/classesandinterfaces/item17/","title":"Effective Java","section":"Effective Java","content":"Item 17: Minimize mutability #  immutable class 는 변경될 수 없는 인스턴스들의 클래스 이다. String, boxed primitive type, BigInteger 나 BigDecimal 등이 immutable class의 예이다. mutable class 보다 설계하기 쉽고 에러도 적고 더 안전하다.\nimmutable class 만들기 위한 규칙 #   객체의 상태를 바꾸는 메소드(Mutator)를 제공하지마라 클래스를 상속할 수 없게 만들어라 모든 필드를 final로 선언해라 모든 필드를 private로 만들어라. mutable object에 대한 접근 제한을 확실히 해라. 클래스가 mutable object 가지고 있으면 client는 절대 접근할 수 없게 해야 한다. client 가 제공하는 객체로 초기화하지말고, field 를 반환해서도 안된다. 생성자나 accesor, readObject(Item 88)에서 defensive copy(Item 50)를 사용하자.  // Immutable complex number class public final class Complex { private final double re; private final double im; pubic Complex(double re, double im) { this.re = re; this.im = im; } public double realPart() {return re;} public double imaginaryPart() {return im;} public Complex plus(Complex c) { return new Complex(re + c.re, im + c.im); } public Complex minus(Complex c) { return new Complex(re - c.re, im - c.im); } public Complex times(Complex c) { return new Complex(re * c.re - im * c.im, re * c.im + im * c.re); } public Complex dividedBy(Complex c) { double tmp = c.re * c.re + c.im * c.im; return new Complex((re * c.re + im * c.im) / tmp (im * c.re - re * c.im) / tmp); } @Override public boolean equals(Object o) { if(o == this) return true; if(!(o instanceof Complex)) return true; Complex c = (Complex) o; return Double.compare(c.re, re) == 0 \u0026amp;\u0026amp; Double.compare(c.im, im) == 0 } @Override public int hashCode() { return 31 * Double.hashCode(re) + Double.hashCode(im); } @Override public String toString() { return \u0026#34;(\u0026#34; + re + \u0026#34; + \u0026#34; + im + \u0026#34;i)\u0026#34; ; } } Immutable Object 장점 #  Immutable Object는 기본적으로 thread-safe 하다. 멀티 쓰레드가 동시에 접근해 state를 오염시킬 수 없다. 이게 thread 안전성을 확보하는 가장 쉬운 방법이다.\nImmutable Objects는 자유롭게 공유할 수 있다. 따라서 클라이언트가 가능한한 갖고 있는 객체를 재사용하도록 해야 한다. 가장 쉬운 방법은 public static final constants 를 제공하는 것이다. 예를 들어 Complex class는 다음 과 과 같은 상수를 제공할 수 있다.\npublic static final Complex ZERO = new Complex(0, 0); public static final Complex ONE = new Complex(1, 0); public static final Complex I = new Complex(0, 1); 여기서 한 걸음 더 나아가면 immutable class는 static factory 를 사용해 자주 사용하는 instance를 캐시함으로써 존재하는 객체를 새로 만드는 것을 피할 수 있다. 모든 boxed primitive class와 BigInteger는 이 방식을 사용한다. 이 방식을 통해 client 메모리 사용량과 GC 부하를 줄일 수 있다. public 생성자 대신에 static factory method를 사용하는 방식은 cache를 나중에 추가할 수 있는 유연성을 준다.\n자유롭게 공유가능한 immutable Object의 특징은 결과적으로 depensive copy(Item 50) 을 하지 않아도 되게 만든다. 따라서 clone method 나 copy 생성자를 만들 필요가 없다.\nimmuatble 객체 자체를 공유할 수 있을 뿐 아니라 내부 객체도 공유 할 수 있다. 예를 들어 BigInteger의 경우 부호를 나타내는 int 와 크기를 나타내는 int[] 로 구성되는데 negate method는 크기는 같고 부호만 다른 BigInteger를 반환한다. 이 때 array를 copy 할 필요 없다. 새로운 BigInteger 객체는 original과 같은 array를 갖고 있어도 된다.\nImmutable Object 단점 #  immutable objects의 가장 큰 문제는 값이 다르면 별도의 객체를 생성해야 한다는 점이다. 객체 생성이 충분히 비쌀 수 있기에 이는 성능 저하로 이어질 수 있다. 거기에 생성 과정에서 여러 step을 밟는 다면 치명적인 속도 저하로 이어질 수 있다.\nimmutability를 만족하기 위해서 subclass가 없도록 강제했었다. 하지만 좀 더 유연한 다른 방식이 있다. 바로 생성자를 모두 private 나 package-private로 만들고 public static factory를 사용하는 것이다.\npublic class Complex { private final double re; private final double im; private Complex(double re, double im) { this.re = re; this.im = im; } public static Complex valueOf(double re, double im) { return new Complex(re, im); } } 이렇게 하면 client에겐 immutable class는 효과적인 final이다(같은 패키지가 아니므로). 여러 구현체를 쓸 수 있는 유연함과 더불어 이 방식으로 추후 성능 튜닝(cache 등을 통해)이 무리 없이 제공될 수 있다.\n요약 #  요약 하면 setter를 모두 만드려고 하지 마라. 클래스는 가능한 한 immutable 해야 한다. 만약 immutable 하게 할 수 없다면 최대한 변경할 수 없도록 제한해라. 생성자는 모든 불변 변수를 초기화 할 수 있게 잘 설계해야 한다.\nOMA 예제 #  OrderModificationResultMessage\n"},{"id":22,"href":"/TIL/effectivejava/classesandinterfaces/item18/","title":"Effective Java","section":"Effective Java","content":"Item 18: 상속보다는 컴포지션을 사용해라 #  상속은 캡슐화를 깨뜨린다. 상위 클래스 구현에 따라 하위 클래스의 동작이 이상해 질 수 있다.\n상속 사용 #  public class InstrumentedHashSet\u0026lt;E\u0026gt; extends HashSet\u0026lt;E\u0026gt; { private int addCount = 0; public InstrumentedHashSet() {} public InstrumentedHashSet(int initCap, float loadFactor) { super(initCap, loadFactor); } @Override public boolean add(E e) { addCount++; return super.add(e); } @Override public boolean addAll(Collection\u0026lt;? extends E\u0026gt; c) { addCount += c.size(); return super.addAll(c); } public int getAddCount() { return addCount; } InstrumentedHashSet\u0026lt;Stirng\u0026gt; s = new InstrumentedHashSet\u0026lt;\u0026gt;(); s.addAll(List.of(\u0026#34;일\u0026#34;, \u0026#34;이\u0026#34;, \u0026#34;삼\u0026#34;)); print(s.getAddCount()); // 6 (?!)  // 3 이 아니다. } 원인은 HashSet 의 addAll 이 add 를 사용해 구현되어 있기 때문이다.\n InstrumentedHashSet.addAll 에서 3이 추가됨 HashSet.addAll 이 각각 인자에 대해 add 호출 Override 된 InstrumentedHashSet.add 가 3번 호출되어 3이 또 더해짐 결론적으로 원소 당 2씩 추가됨  이 문제는 결국 메소드 재정의 때문에 발생했다.\ncomposition 사용 #  // Wrapper class public class InstrumentedSet\u0026lt;E\u0026gt; extends ForawrdingSet\u0026lt;E\u0026gt; { private int addCount = 0; public InstrumentedSet(Set\u0026lt;E\u0026gt; s) { super(e); } @Override public boolean add(E e) { addCount++; return super.add(e); } @Override public boolean addAll(Collection\u0026lt;? extends E\u0026gt; c) { addCount += c.size(); return super.addAll(c); } } // Forwarding class public class ForwardingSet\u0026lt;E\u0026gt; implements Set\u0026lt;E\u0026gt; { private final Set\u0026lt;E\u0026gt; s; public ForwardingSet(Set\u0026lt;E\u0026gt; s) {this.s = s;} public void clear() {s.clear();} public boolean contains(Object o) {return s.contains(o);} public boolean isEmpty() {return s.isEmpty();} public int size() {return s.size();} public Iterator\u0026lt;E\u0026gt; iterator() {return s.iterator();} public boolean add(E e) {return s.add(e);} public boolean remove(Object o) {return s.remove(o)}; public boolean containsAll(Collection\u0026lt;?\u0026gt; c) { return s.containsAll(c); } public boolean addAll(Collection\u0026lt;? extends E\u0026gt; c) { return s.addAll(c); } // 후략  } 이러면 기존 Set 에 영향을 주지 않고 기능을 확장할 수 있다. 디자인 패턴으로 보면 Decorator pattern 으로 볼 수 있다. Composition 과 Forwarding 은 넓은 의미로 Deligation 이라고 부른다.\nwrapper class 의 단점은 거의 없는데, callback 프레임워크와 어울리지 않는다. callback framework 에서는 this 를 넘겨서 callback 호출 시 사용하도록 한다. 그런데 내부 객체는 wrapper 를 모르므로 wrapper 가 아닌 내부 객체 자신을 넘기게 된다(SELF problem).\n요약 #   상속은 강력하지만 캡슐화를 해친다. 상속 대신 composition 과 forwarding 을 사용하자.\n "},{"id":23,"href":"/TIL/effectivejava/classesandinterfaces/item19/","title":"Effective Java","section":"Effective Java","content":"Item 19: 상속을 고려해 설계하고 문서화해라. 그러지 않았다면 상속을 금지하라 #  상속용 클래스는 재정의할 수 있는 메서드들을 내부적으로 어덯게 이용하는지 문서로 남겨야 한다. 클래스를 안전하게 상속할 수 있도록 하려면 내부 구현 방식을 설명해야 한다.\n상속용 클래스를 시험하는 방법은 직접 하위 클래스를 만들어보는 것이 \u0026lsquo;유일\u0026rsquo;하다.\n상속용 클래스의 생성자는 재정의 가능 메서드를 호출해서는 안 된다 #  // 상속 시 문제 발생 가능한 클래스 public class Super { public Super() { overrideMe(); } public void overrideMe() {} } public final class Sub extendss Super { private final Instant instant; Sub() { instant = Instant.now(); } @Override pubic void overrideMe() { System.out.println(instant); }  private, final, static method 는 재정의가 불가능하니 안심하고 호출해도 된다.\n Cloneable, Serializable 을 구현한 클래스는 상속하기 어렵다. #   clone, readObject 모두 재정의 가능 메소드를 호출해서는 안 된다. Serializable 구현한 상속용 클래스가 readResolve 나 writeReplace 를 구현했다면 이 메소드는 private 가 아니라 protected 로 구현되어야 한다.  상속용으로 설계하지 않은 클래스는 상속을 금지 #   class 를 final 로 선언 모든 생성자를 private 나 packge-private 로 선언하고 public 정적 팩토리를 만들어주는 방법  요약 #   상속용 클래스는 자기사용 패턴을 모두 문서로 남겨두어야 한다. 효율적으로 하위 클래스를 만들 수 있도록 일부 메소드는 protected 로 제공해야 할 수도 있다. 명확한 이유가 없다면 상속을 금지해야 한다.\n 예제 #  OrderStateTransitionException\n"},{"id":24,"href":"/TIL/effectivejava/classesandinterfaces/item20/","title":"Effective Java","section":"Effective Java","content":"Item 20: 추상 클래스보다는 인터페이스를 우선하라 #   추상 클래스는 1개만 상속 가능하지만, 인터페이스는 여러개 구현할 수 있다.\n  기존 클래스에도 손쉽게 새로운 인터페이스를 구현해넣을 수 있다. 인터페이스는 Mixin 정의에 안성맞춤이다. 인터페이스는 계층 구조가 없는 타입 프레임워크를 만들 수 있다.  public interface Singer { AutidoCLip sing(Song s); } public interface Songwriter { Song compose(int chartPosition); } public interface SingerSongWriter extends Singer, SongWriter { AudioCLip strum(); void actSensitive(); } Default Method #  Interface 의 default method 를 사용하려면, 꼭 @implSpec 을 붙여서 문서화해야 한다.\ndefault method 의 제약 사항\n Object의 메소드는 제공해선 안 된다 필드를 가질 수 없어 functional 한 기능만 수행  인터페이스와 추상 클래스 #  둘을 함께 쓰면 장점만 추릴 수 있음. 이러한 것을 템플릿 메서드 패턴이라고 함\n네이밍 컨밴션 #  관례상 인터페이스 이름이 Interface 라면 추상클래스는 AbstractInterface 로 짓는다.\n요약 #   인터페이스는 정말 좋음 너무 복잡해지면 골격 구현 클래스를 고려  예제: AbstractDynamoDBJacksonConverter\n"},{"id":25,"href":"/TIL/effectivejava/classesandinterfaces/item21/","title":"Effective Java","section":"Effective Java","content":"Item21: 인터페이스는 구현하는 쪽을 생각해서 설계해라 #  모든 상황에서 불변식을 해치지 않은 default 메소드는 작성하기 어렵다 #  // Java8 에 추가된 Collection dml removeIf  default boolean removeIf(Predicate\u0026lt;? super E\u0026gt; filter) { Objects.requireNonNull(filter); boolean result = false; for (Iterator\u0026lt;E\u0026gt; it = iterator(); it.hashNext();) { if (filter.test(it.next())) { it.remove(); result = true; } } return result; } 굉장히 범용적이지만 못 쓰는 경우도 있다. (ex) 아파치의 SynchronizedCollection)\n컴파일 에러가 발생하지 않아도 런타임 에러가 발생할 수도 있다.\n기존 인터페이스에 default method 를 추가하는 건 최대한 자제하자.\n"},{"id":26,"href":"/TIL/effectivejava/classesandinterfaces/item22/","title":"Effective Java","section":"Effective Java","content":"Item22: 인터페이스는 타입을 정의하는 용도로만 사용하라 #  클래스가 인터페이스를 구현한다는 것은 자신의 인스턴스로 무엇을 할 수 있는지 클라이언트에게 알려주는 것.\nAnti Pattern: 상수 인터페이스\npublic interface PhysicalConstants { static final double AVOGADROS_NUMBER = 6.022_140_857e23; } 상수는 외부 인터페이스가 아니고 내부 구현이다.\n만약 클라이언트가 이런 상수들을 쓰고 있다면, 인터페이스에서 지우지도 못하게 된다.\n이런 경우에는\n 클래스 자체에 추가한다(책에는 클래스나 인터페이스 자체에 추가한다\u0026hellip; 는데 번역 오류인가..?) ENUM 을 사용한다(Item 34) 인스턴스화 못하는 유틸 클래스를 사용한다  public class PhysicalConstants { private PhysicalConstants() {} public static final double AVOGADROS_NUMBER = 6.022_140_857e23; } 예제: MetricConstants\n"},{"id":27,"href":"/TIL/effectivejava/classesandinterfaces/item23/","title":"Effective Java","section":"Effective Java","content":"Item23: 태그 달린 클래스보다는 클래스 계층구조를 활용하라 #  태그 달린 클래스가 뭐야? -\u0026gt; 두가지 이상의 기능을 커버하는 클래스\n안 좋은 이유\n 생성자 여러개 불필요한 필드 많음 객체 지향적이지 않음 반복코드 많음 메모리 낭비 가독성도 아웃   태그 달린 클래스는 클래스 계층구조를 어설프게 흉내낸 아류\n 태그에 따라 달라지는 동작은 추상 클래스의 추상 메소드로 선언 태그와 관계없이 같은 메소드는 추상 클래스의 일반 메소드로 선언\n요약 #   태그 달린 클래스가 보이면 리팩토링을 고려하자\n "},{"id":28,"href":"/TIL/effectivejava/classesandinterfaces/item24/","title":"Effective Java","section":"Effective Java","content":"Item24: 멤버 클래스는 되도록 static 으로 만들어라 #  중첩 클래스는 다음 4개가 존재\n static member class member class anonymous class local class  static Member Class #  클래스 안에 선언되고, 바깥 클래스 private 멤버 접근 가능. 보통 public 도우미 클래스로 쓰임\n(Non-static) Member Class #  바깥 클래스 인스턴스와 암묵적으로 연결되어 있음. 정규화된 this 로 참조 가능.\nclass A { public class C { public void run() { System.out.println(\u0026#34;Run C: \u0026#34; + A.this.a); } } 어댑터 패턴에서 자주 쓰임\n왠만하면 static member class #  멤버 클래스가 바깥 인스턴스에 접근하지 않는다면 무조건 static 을 붙여 static member 클래스가 되게 하자. 그냥 member class 는 외부 인스턴스로의 숨은 참조를 갖게 되고 이는 시간과 공간을 소비함. GC 가 안될 수도 있음\n"},{"id":29,"href":"/TIL/effectivejava/classesandinterfaces/item25/","title":"Effective Java","section":"Effective Java","content":"Item25: 톱레벨 클래스는 한 파일에 하나만 담으라 #  한 파일에 여러 톱 클래스가 있으면 컴파일 순서에 따라 이상한 결과 초래 가능(IDE 에서 이미 경고 할 듯)\n해결책은 하나 파일엔 하나의 톱 클래스만 정의하자. 굳이 하고 싶다면 static member class 써보자.\n"},{"id":30,"href":"/TIL/effectivejava/creatinhanddestoryinhobjects/item1/","title":"Effective Java","section":"Effective Java","content":"Item 1: Consider static factory methods instead of constructors #  기본적으로 클라이언트는 어떤 객체의 퍼블릭 생성자를 얻을 수 있다. 하지만 static factory method를 제공할 수도 있다.\n// Boolean Class 에서 사용하는 static factory method 예제 public static Boolean vaoueOf(boolean b) { return b ? Boolean.TRUE: Boolean.FALSE; }  static factory method와 Factory Method Pattern은 다르니 주의!\n 이제 클라이언트에게 퍼블릭 생성자를 주는 대신, 팩토리 메서드를 제공한다.\n장점\n 생성자와 다르게 이름이 있다.  BigInteger(int, int, Random); // 퍼블릭 생성자 BigInteger.probablePrime(int, int, Random) // 스태틱 팩토리 생성자 위와 같이 이름을 명시함으로 써 직관적으로 이해할 수 있다. 클래스는 생성자 이름을 하나 밖에 할 수 없다. 여러 생성자가 필요한 경우 static factory method를 써서 이름간 차이를 둘 수 있다.\n호출될 때마다 새로운 객체를 생성할 필요가 없다.  이 방식으로 immutable class(Item 17) 가 미리 만들어 놓은 객체를 사용하거나, 객체를 미리 캐시해두어서 여러번 소비할 수 있도록 한다.\nBoolean.valueOf(boolean); 위의 메소드는 절대 객체를 만들지 않는다. 디자인 패턴의 Flyweight Pattern과 유사하다. 같은 객체가 자주 사용될 때 성능을 높이고 비용을 절감할 수 있다. 이렇게 불릴 때마다 같은 객체를 돌려주어 언제나 객체를 엄격히 제어 하는 클래스를 instance-controlled 되어있다고 한다. 이 instance-controlled 방식은 해당 클래스가 Singleton(Item 3) 이거나 noninstantiable(Item 4) 함을 보장한다. 또한 immutable value class (Item 17) 에서 동일한 2개의 객체가 존재하지 않음을 가능케 한다(a.equals(b) if and only if a == b). 이것이 Flyweight pattern의 기초이고 Enum type(Item 34) 가 이것을 제공한다.\n반환 타입의 어떤 자식 클래스도 반환할 수 있다.  API가 public 하지 않은 객체를 제공하게 할 수 있다. 이런 기술은 interface-based framework(Item 20) 을 만들 수 있다. 더 나아가 사용자가 구상 객체가 아닌 인터페이스로 작업하게 강제할 수 있다(Item 64)\n반환 타입으로 여러 객체를 섞어 쓸 수 있다.  위의 3번에서 확장된 의미로, 상황에 따라 interface를 구현한 여러 객체를 알맞게 제공할 수 있다.\n팩토리 메소드를 작성할 때 리턴 객체가 존재할 필요가 없다.  이런 장점은 JDBC같은 Service provider framework를 가능케 해준다. 실제 DB에 따른 구현체는 reflection(Item 65)을 통해 사용자가 설정한 내용에 따라 채워지게 된다.\n단점\n 퍼블릭 또는 프로텍티드 생성자가 없는 클래스는 상속될 수 없다.  팩토리 메소드 내에서 해당 생성자를 호출해 주어야 하기 때문에 불가능하다. 하지만 이 때문에 오히려 상속보다 composition을 사용케 하고(Item 18), Immutable type 도 강제하는 효과가 있다(Item 17).\n개발자가 찾기 힘들다.  팩토리 메서드는 찾기가 어렵다. 직접 문서를 뒤져야 하기 때문에. 그래서 다음과 같은 네이밍 컨벤션을 통해 API 를 만들도록 한다.\n  from : 1개의 parameter를 받아 해당 객체를 반환한다.\n Date d = Date.from(instant);\n  of : 여러 parameter를 받아 해당하는 객체를 반환한다.\n Set\u0026lt;Rank\u0026gt; faceCards = EnumSet.of(JACK, QUEEN, KING);\n  valueOf : from이나 of의 장황한 버전\n BigInteger prime = BigInteger.valueOf(Intger.MAX_VALUE);\n  instance or getInstance : 매개변수로 설명되어있으나 동일한 값을 가질 수 없는 객체를 반환한다.\n StackWalker luke = Stackwalker.getInstance(options);\n  create or newInstance : 매번 새로운 객체를 반환함을 보장하는 것 말고는 instance와 같다.\n Object newArray = Array.newInstance(classObject, arrayLen);\n  getType : getInstance와 같으나 팩토리 메소드와 클래스가 다른 경우 사용한다. Type은 반환되는 클래스를 지칭한다.\nFileStore fs = Files.getFileStore(path);\n  newType : newInstance와 같으나 팩토리 메소드와 클래스가 다른 경우 사용한다. Type은 반환되는 클래스를 지칭한다.\nBufferedReaderbr = Files.newBufferedReader(path);\n  type : getType과 newType의 간편형\nList\u0026lt;Complaint\u0026gt; litany = Collections.list(legacyLitany);\n  요약하자면, 스태틱 팩토리 메소드와 퍼블릭 생성자는 함께 쓰이며 상대적으로 장점이 있다. 대부분 스태틱 팩토리 메소드가 좋으므로, 단순하게 퍼블릭 생성자를 만들지 않도록 하자.\n"},{"id":31,"href":"/TIL/effectivejava/creatinhanddestoryinhobjects/item2/","title":"Effective Java","section":"Effective Java","content":"Item 2 Consider a builder when faced with many constructor parameters #  Static factory 와 constructor 는 같은 문제를 공유한다 - 많은 수의 optional parameter를 처리 하기 힘들다. 전통적으로 많은 파라미터를 같는 경우 telescoping constructor 패턴이 사용된다.\n// Telescoping constructor pattern - scale을 키우기 쉽지 않다 public class NutritionFacts { private final int servingSize; private final int servings; private final int calories; private final int fat; private final int sodium; private final int carbohydrate; public NutritionFacts(int servingSize, int servings) { this(servingSize, servings, 0); } public NutritionFacts(int servingSize, int servings, int calories) { this(servingSize, servings, calories, 0); } public NutritionFacts(int servingSize, int servings, int calories, int fat) { this(servingSize, servings, calories, fat, 0); } public NutritionFacts(int servingSize, int servings, int calories, int fat, int sodium) { this(servingSize, servings, calories, fat, sodium, 0); } public NutritionFacts(int servingSize, int servings, int calories, int fat, int sodium, int carbohydrate) { this.servingSize = servingSize; this.servings = servings; this.scalories = calories; this.fat = fat; this.sodium = sodium; this.carbohydrate = carbohydrate; } } 새롭게 객체를 만들고 싶으면 다음과 같이 만든다.\nNutritionFacts cocaCola = new NutritionFacts(240, 8, 100, 0, 35, 27); parameter가 6개면 위처럼 할 수 있지만 더 많아지면 생성자가 너무 많아진다. 또한 코드를 읽기도 어렵다. 같은 type의 변수를 여러개 나열하면 client가 사용시 순서를 뒤집어 런타임 오류를 발생 시킬 수도 있다.\n두번째 방법은 JavaBeans Patten 이다. 파라미터 없는 생성자를 호출한 후 setter를 호출해 파라미터를 채워준다.\npublic class NutritionFacts { private final int servingSize; private final int servings; private final int calories; private final int fat; private final int sodium; private final int carbohydrate; public NutritionFacts(){}; public void setServingSize(int val) { servingSize = val } public void setServings(int val) { servings = val } public void setCalories(int val) { calories = val} public void setFat(int val) { fat = val } public void setSodium(int val) { sodium = val } public void setCarbohydrate(int val) { carbohydrate = val } } 이 패턴의 경우 텔레스코핑 패턴의 단점은 없다. 생성자는 단순 하나이며 원하는 값만 채워주면 된다. 그러나 심각한 단점은 객체 생성과 setter 호출 사이에 비정상적인 state가 존재한다는 것이다. Javabean 패턴은 imutable 한 class 를 만들 수 있는 가능성을 배제한다(Item 17) 에서 볼 수 있듯 쓰레드 세이프한 클래스를 위해선 별도의 작업이 필요하다.\n이러한 단점들을 보완한 Builder Pattern이 있다. 보통 해당 클래스의 static member class로 만든다.\npublic class NutritionFacts { private final int servingSize; private final int servings; private final int calories; private final int fat; private final int sodium; private final int carbohydrate; public static class Builder() { private final int servingSize; private final int servings; private final int calories; private final int fat; private final int sodium; private final int carbohydrate; public Builder(int servingSize, int servings) { this.servingSize = servingSize; this.servings = servings; } public Builder calories(int val) { calroies = val; return this; } public Builder fat(int val) { fat = val return this; } public Builder sodium(int val) { sodium = val; return this; } pubic Builder carbohydrate(int val) { carbohydrate = val; return this; } public NutritionFacts build() { return new NutritionFacts(this); } } private NutritionFacts(Builder builder){ servingSize = builder.servingSize; servings = builder.servings; calories = builder.calories; fat = builder.fat; sodium = builder.sodium; carbohydrate = builder.carbohydrate; }; } 이러한 빌더 패턴은 읽기 쉽다. 파이썬이나 스칼라의 optional named parameter와 유사하다. 또한 클래스 상속에서도 장점이 있다.\npublic abstract class Pizza { public enum Topping { HAM, MUSHROOM, ONION, PEPPER, SAUSAGE } final Set\u0026lt;Topping\u0026gt; toppings; abstract static class Builder\u0026lt;T extends Builder\u0026lt;T\u0026gt;\u0026gt; { EnumSet\u0026lt;Topping\u0026gt; toppings = EnumSet.noneOf(Topping.class); public T addTopping(Topping topping) { toppings.add(Objects.requireNonNull(topping)); return self(); } abstract Pizza build(); // Subclass는 자기 자신을 돌려주기 위해 반드시 이 메소드를 오버라이딩 해야 한다.  protected abstract T self(); } Pizza(Builder\u0026lt;?\u0026gt; builder) { toppings = builder.toppings.clone(); // See Item 50  } } public class NyPizza extends Pizza { public enum Size { SMALL, MEDIUM, LARGE } private final Size size; public static class Builder extends Pizza.Bulder\u0026lt;Builder\u0026gt; { private final Size size; public Builder(Size size) { this.size = Objects.requireNonNull(size); } @Overide public NyPizza() { return new NyPizza(this); } @Override protected Builder self() {return this;} } private NyPizza(Builder builder) { super(builder); size = builder.size; } } public class Calzone extends Pizza { private final boolean sauceInside; public static class Builder extends Pizza.Builder\u0026lt;Builder\u0026gt; { private boolean sauceInside = false; public Builder sauceInside() { sauceInside = true; return this; } @Override public Calzone build() { return new Calzone(this); } @Override protected Builder self() { return this; } } private Calzone(Builder builder) { super(builder); sacueInside = buider.sauceInsde; } } Pizza.Builder 는 recursive type parameter인 generic type(ITEM 30) 임을 기억하자. 이를 통해 캐스팅 없이 체이닝이 가능하다.(안한다면 다 Pizza의 Builder이므로 사용이 제한됨\u0026hellip;)\n빌더 패턴의 단점 중 나나느 빌더 객체를 꼭 만들어야 한다는 점이다. 퍼포먼스가 중요한 곳에선 문제를 야기할 수 있다. 텔레스코핑 만큼 verbose 하므로 최소 생성자 인자가 4개 이상인 상황에서 써야 한다.\n요약하면 빌더 패턴은 생성자나 스태틱 팩토리의 인자가 많을 때 쓸 수 있는 좋은 방식이다.\n"},{"id":32,"href":"/TIL/effectivejava/creatinhanddestoryinhobjects/item3/","title":"Effective Java","section":"Effective Java","content":"Item 3 Enforce the singleton property with a private constructor or an enum type #  싱글톤은 오직 단 1번만 생성되는 객체이다. 상태가 없는 function(Item 24) 나 시스템 컴포넌트가 여기에 해당한다. 싱클톤은 Mock을 만들기 어렵기 때문에 테스트 하기에 어려운 점이 있다.\n보통 2가지 방식이 존재한다. 둘 다 생성자를 private으로 보호하고, 접근자를 public하게 만들어 유일한 객체에 접근하도록 허용한다.\n// 인스턴스를 final로 해 접근하는 방식 public class Elvis { public static final Elvis INSTANCE = new Elvis(); private Elvis() {} } protected나 public 생성자가 없기 때문에 elvis 객체는 오직 1번만 클래스가 초기화 될 때 생성됨을 보장한다.\nreflection을 통해 우회할 수 있는데, 이를 막기 위해선 생성자내에서 이미 생성 됐다면 Error를 throw하게 하면 된다.\n2번째 방법은 INSTANCE도 private로 하고 접근메소드를 정의하는 것이다.\npublic clas Elvis { private static final Elvis INSTANCE = new Elvis(); private Elvis(){} public static Elvis getInstance() { return INSTANCE}; } 이 방식의 장점은 API가 해당 클래스가 싱글톤이란 것을 단순히 보여준다는 점이다. 2번째 방식이 팩토리 메소드를 사용해 좀 더 좋다. 첫번째 장점은 메소드로 추상화시킴으로써 추후 변경에 용이하다는 점이다. 두번째는 필요하다면 Generic singleton factory 로 사용할 수 있다는 점이다. 마지막으로는 method reference를 이용해 supplier를 사용할 수 있다는 점이다. 예를 들어 Elvis::instance 는 Supplier\u0026lt;Elivis\u0026gt; 가 될 수 있다. 이런 것과 관계없으면 public field가 간편하다.\nserializable(Chapter 12) 를 생각해보면 이것만으로는 충분하지 않다. 모든 필드를 transient로 바꾸고 readResolve method를 제공해야 한다.(Item 89) 그렇지 않으면 디시리얼라이즈할 때마다 새로운 객체가 만들어 질 것이다.\nprivate Object readResolve() { return INSTANCE; } 3번째 방식은 Enum으로 싱글톤 클래스를 생성하는 것이다.\npublic enum Elvis { INSTANCE; } 이 방식은 public field와 유사하지만 더 간결하고, serialization에 대해서도 자유로우며 reflection에도 대응할 수 있다. 다만 상속을 해야한다면 이 방식은 사용할 수 없다.\n"},{"id":33,"href":"/TIL/effectivejava/creatinhanddestoryinhobjects/item4/","title":"Effective Java","section":"Effective Java","content":"Item 4 Enforce noninstantiability with a private constructor #  유틸 클래스들처럼 객체화 시키고 싶지 않은 클래스를 원할 때가 있다. 하지만 명시적 생성자가 없으면 컴파일러는 public default 생성자를 만들어준다. 따라서 private 생성자를 명시적으로 넣으므로써 이를 방지할 수 있다.\npublic class UtilityClass { private UtilityClass() { throw new AssertionError(); } } 부과 효과로 이런 방식은 상속을 불가능하게 만든다. 모든 생성자는 부모 생성자를 호출해야 하기 때문에, private 생성자에 접근할 방법이 없다.\n"},{"id":34,"href":"/TIL/effectivejava/creatinhanddestoryinhobjects/item5/","title":"Effective Java","section":"Effective Java","content":"Item 5 Prefer dependency injection to hardwiring resources #  Static utility 클래스와 싱글톤은 리소스에 따라 달라져야하는 클래스에는 적합하지 않다. static utility 와 싱글톤은 테스트와도 어울리지 않는다. 바람직한 방식은 생성자에 인자로써 건내주는 것이다. 이는 Dependency Injection의 한 형태이다.\n// static utility public class SpellChecker { private static final Lexicon dictionary = ...; private SpellChecker(){} } // singleton public class SpellChecker { private final Lexicon dictionary = ...; private SpellChecker(){} public static INSTANCE = new SpellChecker(...); } // DI gives flexibility and testability public class SpellChecker { private final Lexicon dictionary = ...; public SpellChecker(Lexicon dictionary){ this.dictionary = Objects.requireNonNull(dictionary); } } Depenency Injection은 Immutability(Item 17) 도 만족하기에 client가 같은 객체를 공유할 수 있다. 도한 생성자, static factories(Item 1), builder(Item 2) 에도 적용할 만하다.\n이 패턴의 또 다른 사용 방식은 생성자에 resource factory 를 넘기는 것이다. java8의 Supplier\u0026lt;T\u0026gt; 를 사용하면 딱 좋다. 보통 API에서는 parameterized Type으로 bounded wild card(Item 31) 를 사용하는데, 이는 사용자가 해당 T type을 상속해서 사용할 수 있게 하기 위함이다.\nMosaic create(Supplier\u0026lt;? extends Tile\u0026gt; tileFactory){} Dependency Injection이 유연성과 테스트성을 엄청 좋게 하긴하는데, 프로젝트가 커지면 어수선해질 수가 있습니다. 이런 경우 DI framework를 사용하면 모두 제거할 수 있습니다. Dagger, Guice, Spring 같은 녀석이 Framework의 예시입니다.\n요약하면 다른 resource나 클래스의 영향을 받는 녀석들은 Static Util이나 싱글톤으로 만들지 말고 생성자에 인자를 넘기는 방식으로 하는게 좋습니다.\n"},{"id":35,"href":"/TIL/effectivejava/creatinhanddestoryinhobjects/item6/","title":"Effective Java","section":"Effective Java","content":"Item 6 Avoid creating unnecessary objects #  기능적으로 동일한 객체를 매번 생성하는 것 보다 객체 하나를 재사용하는게 적절한 상황이 있다. 재사용은 더 빠르고 읽기 쉽다. immutable(Item 17) 해야만 재사용 할 수 있다.\nString s = new String(\u0026#34;bikini\u0026#34;); //제발 이렇게 사용하지 말 것! 위 처럼 하게 되면 매번 새로운 String 객체를 생성하게 된다.\nString s = \u0026#34;bikini\u0026#34;; 이 버전은 같은 string literal은 매번 같은 객체를 사용함을 JVM이 보장한다.\n특히 다른 객체보다 만들 때 자원을 더 소모하는 녀석들을 expensive object 라고 한다. String.matches(String pattern) 메소드는 Pattern 객체를 내부적으로 만들고, pattern은 정규식을 FSM으로 바꿔야 해서 굉장히 expensive 한 객체이다.\nstatic boolean isRomanNumeral(String s) { return s.matches(\u0026#34;^(?=.)M*(C[MD]|D?C{0,3})\u0026#34; + \u0026#34;(X[CL]|L?X{0,3})(I[XV]|V?I{0,3})$\u0026#34;); } 성능 개선을 위해 미리 Pattern 객체를 만들어 놓고 cache 해서 재사용할 수 있다.\npublic class RomanNumerals { private static final pattern ROMAN = Pattern.compile(\u0026#34;^(?=.)M*(C[MD]|D?C{0,3})\u0026#34; + \u0026#34;(X[CL]|L?X{0,3})(I[XV]|V?I{0,3})$\u0026#34;); static boolean isRomanNumeral(String s) { return ROMAN.matcher(s).matches(); } } 유사한 경우는 Map.keySet() 에서도 볼 수 있다. 항상 같은 객체를 반환해서, 한군데에서만 바꾸면 다른 곳들도 영향을 받는다. 또한 사례는 Autoboxing을 들 수 있다. primitive 대신 boxed primitive를 쓰면 객체 생성을 해야해서 속도면에서 느려질 수 있다.\n반면 private Object Pool을 구성하는 건 위험하다. 현대 JVM은 GC에 최적화되어있기 때문에 차라리 새로 생성하는게 나을 수 있다. Item 50에 지금 이야기와는 반대로 \u0026ldquo;새로 만들어야 할 땐 재사용하지 말자\u0026rdquo; 라고 말한다. 이는 security와 버그 를 유발할 가능성을 막기 위함이다. 단순히 성능면에선 객체 생성을 할 필요가 없다.\n"},{"id":36,"href":"/TIL/effectivejava/creatinhanddestoryinhobjects/item7/","title":"Effective Java","section":"Effective Java","content":"Eliminate obsolete object references #  pubic class Stack { private Object[] elements; private int size=0; private static final int DEFAULT_INITIAL_CAPACITY = 16; public Stack() { elements = new Object[DEFAULT_INITIAL_CAPACITY]; } public void push(Object e) { ensureCapacity(); elements[size++] = e; } public Object pop() { if(size == 0) { thorw new EmptyStackException(); } return elements[--size]; } private void ensureCapacity() { if(elements.length == size) { elements = Arrays.copyOf(elements, 2* size + 1); } } } 문제가 없어보이지만, pop 하고 난 후 내보낸 객체에 대한 reference를 stack이 갖고 있는게 문제다. 이러면 GC 가 되지 않아 메모리 누수가 발생한다.\npublic Object pop() { if (size == 0) { trow new EmptyStackExecption(); } Object result = elements[--size]; elements[size] = null; return result; } 근데 null 하는게 정상적인 프로그래밍 방식은 아니다. 그럼 언제 해야할까? 스택은 자신만의 메모리 공간을 관리하기 때문이다. 즉 클래스가 자신만의 메모리 공간을 관리하면, 프로그래머는 메모리 누수를 항상 염두해야 한다. 또 다른 흔한 메모리 누수 경우는 캐시이다. 이 경우 WeakHashMap이 좋은 대안이 된다.\n3번째 요인은 listener \u0026amp;\u0026amp; callback의 경우 발생한다. callback이 언제 실행될지 모르기에 항상 메모리에 올려두고 있으며 이는 메모리 누수로 이어진다. 하나의 해결책은 해당 callback을 WeakHashMap에 넣는 것이다.\n"},{"id":37,"href":"/TIL/effectivejava/creatinhanddestoryinhobjects/item8/","title":"Effective Java","section":"Effective Java","content":"Item 8: Avoid finalizers and cleaners #  Finalizer 와 Cleaner 쓰지 말자\n"},{"id":38,"href":"/TIL/effectivejava/creatinhanddestoryinhobjects/item9/","title":"Effective Java","section":"Effective Java","content":"Item 9: Prefer try-with-resources to try-finally #  InputStream이나 sql.Connection 등은 close() 를 꼭 불러주어야 한다. 전통적으로는 try, catch 문이 이를 지원하였다.\nstatic String firstLineOfFile(String path) throws IOException { BufferedReader br = new BufferedReader(new FileReader(path)); try { return br.readLine(); } finally { br.close(); } } 하지만 자원이 여러개가 되면 굉장히 이상해진다.\nstatic void copy(String src, String dst) throws IOException { InputStream in = new FileStream(src); try { OutputStream out = new FileOutputStream(dst); try { byte[] buf = new byte[BUFFER_SIZE]; int n; while((n = in.read(buf) \u0026gt;= 0)) { out.write(buf, 0, n); } } finally { out.close(); } } finally { in.close(); } } 위 예제에서 device 문제로 Exception이 발생하면 첫번째 Exception은 먹히게 된다. in.read()에서 발생한 익셉션은 out.close() 에서 발생한 익셉션에 의해 먹히게 된다\u0026hellip;\njava7에 나온 try-with-resources 를 이용하면 이 문제는 해결된다. 이를 위해 해당 자원은 AutoCloseable 인터페이스를 구현해야 한다.\nstatic void copy(String src, String dst) throws IOException { try (InputStream in = new FileInputStream(in); OutputStream out = new FileOutputStream(dst)) { byte[] buf = new byte[BUFFER_SIZE]; int n; while((n = in.read(buf) \u0026gt;= 0)) { out.write(buf, 0, n); } } } 더 간결하고 읽기 쉬워졌다.\n"},{"id":39,"href":"/TIL/effectivejava/generalprogramming/","title":"Effective Java","section":"Effective Java","content":"일반적인 프로그래밍 원칙들 #  규칙 53 리플렉션 대신 인터페이스를 이용하라 #  java.lang.reflect 를 활용하면 클래스 정보를 런타임에 가져 올 수 있다.\n Class 객체를 통해 생성자(Constructor), 메서드(Method), 필드(Field) 객체를 가져올 수 있다 멤버 이름, 필드 자료형, 메서드 시그니처 들을 알 수 있다. 객체를 생성할 수도 있고, 메서드를 호출할 수도 있으며 필드에 접근할 수도 있다.  단점도 많다.\n 컴파일 시점에서 자료형 검사함으로써 얻는 이점을 모두 포기해야 한다 (존재하지 않는, 접근 할 수 없는 method 호출하면 런타임 오류 발생) 리플렉션 코드는 보기 싫고 장황하다. 가독성 떨어진다 성능이 낮다 (저자 컴퓨터에서는 2 ~ 50 배 가량 느렸다)  일반적인 프로그램은 프로그램 실행 중 리플렉션을 통해 객체를 이용하려 하면 안 된다 #  리플렉션이 필요한 복잡한 프로그램 예시 (여기에 포함 안 되면 리플렉션 사용 ㄴㄴ)\n 클래스 브라우저 객체 검사도구 코드 분석 도구 해석적 내장형 시스템(interpretive embedded system) ??? 스텁 컴파일러가 없는 원격 프로시저 호출(???)  리플렉션을 아주 제한적으로 사용하면 오버헤드는 피하면서 리플렉션의 장점을 누릴 수 있다. #   객체 생성은 리플렉션으로, 참조는 인터페이스나 상위 클래스로  // command line으로 받은 첫번째 인자의 클래스를 이용해 Set\u0026lt;String\u0026gt; 을 만드는 프로그램. 나머지 인자는 해당 Set에 집어 넣음 // 생성은 리플렉션, 참조와 사용은 인터페이스  public static void main(String[] args) { Class\u0026lt;? extends Set\u0026lt;String\u0026gt;\u0026gt; cl = null; try { cl = (Class\u0026lt;? extends Set\u0026lt;String\u0026gt;\u0026gt;) Class.forName(args[0]); // unchecked cast  } catch (ClassNotFoundException e) { System.err.println(\u0026#34;Class not found.\u0026#34;); System.exit(1); } // get constructor  Constructor\u0026lt;? extends Set\u0026lt;String\u0026gt;\u0026gt; cons = null; try { cons = cl.getDeclaredConstructor(); } catch (NoSuchMethodException e) { System.err.println(\u0026#34;No parameterless constructor.\u0026#34;); System.exit(1); } // Instantiate the set  Set\u0026lt;String\u0026gt; s = null; // Set으로 참조  try { // cl.newInstance() 를 안쓰고 굳이 생성자 호출하는 이유는?  s = cons.newInstance(); } catch (IllegalAccessException e) { System.err.println(\u0026#34;Class not accessible.\u0026#34;); System.exit(1); } catch (InstantiationException e) { System.err.println(\u0026#34;Class not instantiable\u0026#34;); System.exit(1); } catch (InvocationTargetException e) { System.err.println(\u0026#34;Constructor threw \u0026#34; + e.getCause()); System.exit(1); } catch (ClassCastException e) { System.err.println(\u0026#34;Class doesn\u0026#39;t implements Set\u0026#34;); System.exit(1); } s.addAll(Arrays.asList(args).subList(1, args.length)); System.out.println(s); /// etc }  어떤 클래스가 Set을 구현했는지 검증하는 검사도구로 사용 가능 (generic set tester) 일반적 집합 성능 분석 도구 (generic performance analysis tool) 로도 사용 가능  2개의 단점 존재\n 6 가지 런타임 오류 발생. 리플렉션 안 썼으면 컴파일 시점에서 다 감지 가능 클래스 객체 생성 위해 코드 엄청 많이 씀. 생성자 호출로 했으면 한 줄로 가능  하지만 객체 생성 부분에서만 나타나는 문제로 일단 객체 생성 후에는 Set\u0026lt;\u0026gt;으로 참조하기 때문에 아무 영향 없다.\n리플렉션은 실행 시점에 존재하지 않는 클래스나 메서드, 필드에 대한 종속성 관리에 적합. 어떤 패키지의 버전이 여러가지 이고, 그 전부를 지원하는 또 다른 패키지를 구현해야 할 때 모든 버전을 지원하는 최소한의 환경만 컴파일하고, 새로운 클래스나 메서드는 리플렉션을 통해 접근\n요약 #   리플렉션은 특정 종류의 복잡한 시스템 프로그래밍에 필요한 강력한 도구 단점 매우 많음 사용하고 싶다면 객체를 만들 때만 사용하고 참조할 때는 컴파일 시에 알고 있는 인터페이스나 상위 클래스만 사용할 것  규칙 54 네이티브 메서드는 신중히 사용하라 #  JNI(java native interface) 는 C나 C++로 작성된 native method 호출하는 데 이용되는 기능.\n3가지 용도로 쓰임\n 레지스트리나 파일락 같은 특정 플랫폼에 고유한 기능을 이용 이미 구현되있는 라이브러리를 이용할 수 있음 성능 상 중요한 부분을 네이티브 언어에 맡길 수 있음  네이티브 메서드를 통해 성능을 개선하는 것을 추천 안함 #   현재 JVM은 네이티브에 필적하는 성능을 낸다. 네이티브 메서드는 심각한 문제 1. 안전하지 않다. memory corruption error 발생 가능 플랫폼 종속적 디버깅 어려움 네이티브와 jvm 넘나드는 코드 때문에 오히려 성능 떨어질 수 있음 이해하기 어렵고 작성하기 난감한 접착 코드 작성해야 함  요약 #   네이티브 메서드 쓰지 마라 퍼포먼스 향상 될 일 거의 없다 굳이 써야 한다면 네이티브 코드를 최소화 하고 전체를 다 테스트 해야한다. 작은 버그가 어플리케이션을 다 망침.  규칙 55 신중하게 최적화하라 #  최적화 관련 명언 3개가 있다.\n 맹목적인 어리석음을 비롯한 다른 어떤 이유보다도, 효율성이라는 이름으로 저질러지는 죄악이 더 많다. - 윌리엄 울프\n  작은 효율성에 대해서는, 말하자면 97% 정도에 대해서는, 잊어버려라. 섣부른 최적화는 모든 악의 근원이다. - 도널드 커누스\n  최적화 할 때는 아래 두 규칙을 따르라. 규칙 1: 하지 마라 규칙 2: (전문가들만 따를 것) 아직은 하지 마라 - 완벽히 명료한, 최적화되지 않은 해답을 얻을 때까지는 - M.A. 잭슨 M\n 중간 요약 #  최적화 하지마라\n  성능 때문에 구조적인 원칙을 희생하지 마라. 빠른 프로그램이 아닌, 좋은 프로그램을 만드려 노력하라. 좋은 프로그램이라면 좋은 구조를 갖추었기 때문에 최적화의 여지도 충분.\n  설계 할 때는 성능을 제약할 가능성이 있는 결정들은 피하라. 가장 까다로운 부분은 모듈간의 상호작용이나 외부와의 상호작용을 명시하는 부분, 즉 API, 통신 프로토콜, 지속성 데이터 형식 등 이다. 이런 부분은 성능 문제가 발견된 후 수정이 어렵다.\n  API를 설계할 때 내리는 결정들이 성능에 어떤 영향을 끼칠지 생각하라.\n public 자료형을 변경 가능하게 만들면 방어적 복사를 많이 해야한다. composition이 적절할 public class에 상속을 적용하면 해당 클래스는 영원히 상위 클래스에 묶이게 되서 하위 클래스 성능에 제약 가해질 수 있다. 인터페이스가 적당한 API 에 구현자료형 사용하면 해당 API가 특정 구현에 종속되어 나중에 더 빠른 구현이 나와도 개선할 수 없다.    성능을 위해 API를 급진적으로 바꾸는 건 바람직하지 않다.\n 너무 많이 변경된 API를 지원하는건 개발자가 너무 힘들다.    최적화를 시도할 때마다 전후 성능을 측정하고 비교하라\n JVM 마다, 릴리스 마다, 프로세서 마다 차이가 크다.    요약 #   빠른 프로그램 만들고자 애쓰지 마라 대신 좋은 프로그램 짜기 위해 노력하면 성능은 따라 온다 시스템 설계할 때 API, 통신 프로토콜, 지속성 데이터 형식을 성계할 때 성능 문제를 따져봐라. 성능 문제 있을 때 처음 해야 할건 구현에 쓰인 알고리즘 검토. 이게 잘못되면 저수준 최적화 의미없음.  규칙 56 일반적으로 통용되는 작명 관습을 따르라 #   철자에 관한 것    package\n 마침표를 구분자로 하는 계층적 이름 소문자 사용 숫자 거의 사용 X 앞에 2개는 조직의 인터넷 도메인을 따온다 (com.tmax) 나머지 부분은 어떤 패키지 인지 설명하는 하나이상의 컴포넌트로 구성 의미가 확실한 약어면 좋음(utilities 보다 util)    enum, class, interface\n 첫 글자는 대문자 널리 쓰이는 약어(max, min)을 제외하면 약어는 피한다    메서드, 필드\n 첫 글자는 소문자 상수 필드의 경우 모두 대문자로 쓰며 _ 로 구분한다.    지역 변수\n 메서드, 필드와 같은 규칙 약어를 많이 사용    자료형 인자\n 보통 하나의 대문자 임의 자료형 T 컬렉션의 요소 자료형 E 맵의 키와 값은 K, V 예외인 경우 X 임의 자료형의 연속은 T, U, V or T1, T2, T3       식별자 자료형 예제     패키지 com.tmax.proobject   클래스나 인터페이스 ChannelEventHandler, BodyParser   메서드나 필드 remove, ensureCapacity   상수 필드 MIN_VALUE, NEGETIVE_INFINITY   지역 변수 i, xref, houseNumber   자료형 인자 T, E, K, V, X, T1, T2    문법에 관한 것  철자 관습보다 가변적이고 논쟁 여지가 많다.\n 패키지는 문법 관습 없음 클래스나 enum 은 단수형 명자나 명사구 붙는다 (Timer, BuffedWriter, ChessPiece) 인터페이스도 클래스와 비슷하며 able이나 ible 같은 형용사격 어미가 붙기도 한다 (Collection, Comparator, Runnable, Iterable, Accessible) 어노테이션은 쓰임새가 너무 다양해 지배적인 규칙이 없다. 명사, 동사, 전치사, 형용사 다 쓰인다 (BindingAnnotation, Inject, ImplementedBy, Singleton) 어떤 동작을 수행하는 메서드는 동사나 동사구를 이름으로 한다(append, add) boolean 값을 반환하는 method는 보통 is, 가끔 has 로 시작한다 (isDigit, isEmpty, hasSiblings) boolean 이외의 속성을 반환하는 메서드는 보통 명사나 명사구, get으로 시작한다 (size, hashCode, getTime) bean 클래스에 속한 메서드이름은 반드시 get으로 시작해야 한다. 속성을 설정하는 건 set으로 시작해야 한다. 객체의 자료형을 변환하는 메서드, 다른 자료형의 독립적 객체를 반환하는 메서드는 보통 toType 형태를 붙인다 (toString, toArray) 인자로 전달받은 객체와 다른 자료형의 View 객체를 반환하는 메서드는 asType 형태의 이름을 붙인다 (asList) 호출 객체와 동일한 기본 자료형 값을 반환하는 경우 typeValue 로 붙인다 (intValue) 정적 팩토리 메서드는 valueOf, of, getInstance, newInstance, getType, newType 등을 붙인다 필드는 특별한 관습 없고 별로 중요하지 않다 (잘 설계된 API는 외부로 필드를 거의 공개 안하기 때문) boolean field는 메서드와 같은 이름을 붙이거나 is를 생략한다 (initialized, composite) 다른 필드는 보통 명사나 명사구를 쓴다 (height, digits, bodyStyle) 지역 변수는 더 중요하지 않다.  요약 #   표준 작명 관습을 내면화 시켜서 제2의 천성인 것 처럼 사용하자 철자 관습은 직관적이며 모호한 부분이 없다 문법 관습은 좀 더 복잡하고 느슨하다  "},{"id":40,"href":"/TIL/effectivejava/generic/","title":"Effective Java","section":"Effective Java","content":"Generics #  2판의 경우 27, 28 ,29 로 되어 있음 #  Item 30: Favor generic methods 가능하면 제네릭 메서드로 만들 것 #  클래스가 generic 일 수 있는 것 처럼 method 도 generic 할 수 있음 예를 들어 collections 에 있는 알고리즘 관련 method(sort, binarysearch) 는 generic 하다.\n// use raw types - 문제 있음 public static Set union(Set s1, Set s2) { // Warning! HashSet(Collection\u0026lt;? extends E\u0026gt;)  Set result = new HashSet(s1); // Warning! result.addAll(Collections\u0026lt;? extends E\u0026gt;)  result.addAll(s2); return result; }  형인자 목록(type parameter list) 는 접근 제어자와 return type 사이에 위치  public static \u0026lt;T\u0026gt; Set\u0026lt;T\u0026gt; union(Set\u0026lt;T\u0026gt; s1, Set\u0026lt;T\u0026gt; s2) { Set\u0026lt;T\u0026gt; result = new HashSet(s1); result.addAll(s2); return result; } // client 잘 동작함! public static void main(String[] args){ Set\u0026lt;String\u0026gt; guys = new HashSet\u0026lt;\u0026gt;(Arrays.asList(\u0026#34;Tom\u0026#34;, \u0026#34;Dean\u0026#34;, \u0026#34;Harry\u0026#34;)); Set\u0026lt;String\u0026gt; stooges = new HashSet\u0026lt;\u0026gt;(Arrays.asList(\u0026#34;Larry\u0026#34;, \u0026#34;Moe\u0026#34;, \u0026#34;Curly\u0026#34;)); Set\u0026lt;String\u0026gt; aflCio = union(guys, stooges); System.out.println(aflCio); } 위의 union의 단점은 input set 2개와 output이 정확히 같은 타입이라는 것(T) bounded wildcard type 을 사용해서 좀 더 유연하게 구연 가능 뒤에 나옴\ntype parameter에 대한 convention #   T (임의의 타입) E (collection의 element) K,V (key, value) X (exception) R (function의 return type) T, U, V || T1, T2, T3 (연속된 임의의 타입)  제너릭 싱클톤 패턴 #  변경이 불가능하지만 많은 자료형에 적용 가능한 객체를 만들어야 할 때가 있다. 모든 필요한 형인자화 과정에서 동일 객체를 활용할 수 있는데, 그러려면 우선 필요한 형인자화 과정 마다 같은 객체를 나눠주는 정적 팩토리 메서드 필요 private static UnaryOperator\u0026lt;Object\u0026gt; IDENTITY_FN = t -\u0026gt; t; //IDENTITY_FN 은 stateless 객체이고 형인자는 unbounded 이므로 모든 자료형이 같은 객체를 공유해도 된다. // 팩토리 메소드 @SuppressWarnings(\u0026#34;unchecked\u0026#34;) public static \u0026lt;T\u0026gt; UnaryOperator\u0026lt;T\u0026gt; identityFunction() { return (UnaryOperator\u0026lt;T\u0026gt;) IDENTITY_FN; } UnaryOperator\u0026lt;Object\u0026gt; 를 UnaryOperator\u0026lt;T\u0026gt; 로 캐스팅 하는 부분에서 warning 발생하지만 항등함수는 특별히 인자를 수정없이 반환하므로 형 안정성이 보장\npublic static void main(String[] args) { String [] strings = {\u0026#34;jute\u0026#34;, \u0026#34;hemp\u0026#34;, \u0026#34;nylon\u0026#34;}; UnaryOperator\u0026lt;String\u0026gt; sameString = identityFunction(); //같은 IDENTITY_FN 객체 사용  for(String s: strings){ System.out.println(sameString.apply(s)); } Number[] numbers = {1, 2.0, 3l}; UnaryOperator\u0026lt;Number\u0026gt; sameNumber = identityFunction(); for(Number n: numbers) { System.out.println(sameNumber.apply(n)); } } 이 패턴은 함수객체 구현에 많이 쓰임\n//Collections.java // 예시 Arrays.sort(a, Collections.reverseOrder()); @SuppressWarnings(\u0026#34;unchecked\u0026#34;) public static \u0026lt;T\u0026gt; Comparator\u0026lt;T\u0026gt; reverseOrder() { return (Comparator\u0026lt;T\u0026gt;) ReverseComparator.REVERSE_ORDER; } /// 중략 ...  private static class ReverseComparator implements Comparator\u0026lt;Comparable\u0026lt;Object\u0026gt;\u0026gt;, Serializable { private static final long serialVersionUID = 7207038068494060240L; static final ReverseComparator REVERSE_ORDER = new ReverseComparator(); public int compare(Comparable\u0026lt;Object\u0026gt; c1, Comparable\u0026lt;Object\u0026gt; c2) { return c2.compareTo(c1); } private Object readResolve() { return Collections.reverseOrder(); } @Override public Comparator\u0026lt;Comparable\u0026lt;Object\u0026gt;\u0026gt; reversed() { return Comparator.naturalOrder(); } } 재귀적 자료형 한정(rescursive type bound) #  형인자가 포함된 표현식으로 형인자를 한정할 수 있다. Comparable 인터페이스와 흔히 쓰인다\npublic interface Comparable\u0026lt;T\u0026gt; { int compareTo(T o); } 정렬, 탐색, 최대 최소값 method 들은 컬렉션 내 원소들이 서로 비교 가능해야 한다. 이러한 작업이 가능하려면 Comparable을 구현한 원소들의 컬랙션을 인자로 받아야 한다. 아래 표현은 \u0026ldquo;자기 자신과 비교가능한 모든 자료형 T\u0026rdquo; 를 나타낸다.\npublic static \u0026lt;E extends Comparable\u0026lt;E\u0026gt;\u0026gt; E max(Collection\u0026lt;E\u0026gt; c){...}  E 는 compareTo(E o) 를 구현했음을 보장한다.\n public static \u0026lt;E extends Comparable\u0026lt;E\u0026gt;\u0026gt; E max(Collection\u0026lt;E\u0026gt; c) { if (c.isEmpty()) throw new IllegalArgumentException(\u0026#34;Empty collection\u0026#34;); E result = null; for (E e : c){ if(result == null || e.compareTo(result) \u0026gt; 0) { result = e; } } return result; } 이 보다 복잡한 건 뒤에서\u0026hellip;\n요약 #   제네릭 자료형과 마찬가지로 제네릭 메서드는 클라이언트가 직접 형변환 해야하는 메서드 보다 사용하기 쉽고 안정성 높음 새로운 메서드 고안할 때는 형변환 없이도 사용할 수 있는지 판단해라 시간 날 때 기존 메서드 제네릭하게 바꾸면 기존 클라이언트와 호환되면서 더 좋은 API 제공 가능  Item 31: Use bounded wildcards to increase API flexibility 한정적 와일드카드를 써서 API의 유연성을 높여라 #  앞에서 했다시피 형인자 자료형(prameterized types) 는 불변형. 때로는 불변 자료형 보다 유연한 자료형이 필요 할 수 있다. 이때 와일드 카드를 사용하자.\n한정적 와일드카드 #  // 스택 API public class Stack\u0026lt;E\u0026gt; { public Stack(); public void push(E e); public E pop(); public boolean isEmpty(); } 엘리먼트 집합 받아서 다 stack 에 넣는 pushAll 을 생각해보자\n생산자 문제 #  // producer.. 문제! public void pushAll(Iterable\u0026lt;E\u0026gt; src){ for(E e: src){ push(e); } } 실제 하려고 하면 컴파일 에러\u0026hellip;\npublic static void main(String[] args) { WildcardStack\u0026lt;Number\u0026gt; ws = new WildcardStack\u0026lt;\u0026gt;(); Iterable\u0026lt;Integer\u0026gt; integers = Arrays.asList(1,2,3,4,5); ws.push(1); //OK  ws.pushAll(integers); //compile error incompatible types..  // Iterable\u0026lt;Integer\u0026gt; is not subtype of Iterable\u0026lt;Number\u0026gt; ... } Integer 는 Number의 하위 타입이지만 Iterable는 Iterable의 하위 타입(subtype)이 아니기 때문 한정적 와일드카드 자료형 (bounded wildcard type) 을 활용하면 해결\n Iterable\u0026lt;E\u0026gt; -\u0026gt; E 의 Iterable Iterable\u0026lt;? exends E\u0026gt; -\u0026gt; E 의 하위 자료형의 Iterable  public void pushAll(Iterable\u0026lt;? extends E\u0026gt; src){ for(E e: src){ push(e); } } 소비자 문제 #  // consumer... 문제! public void popAll(Collection\u0026lt;E\u0026gt; dst) { while(!isEmpty()) { dst.add(pop()); } } public static void main(String[] args) { WildcardStack\u0026lt;Number\u0026gt; ws = new WildcardStack\u0026lt;\u0026gt;(); Iterable\u0026lt;Integer\u0026gt; integers = Arrays.asList(1,2,3,4,5); Collection\u0026lt;Object\u0026gt; objects = new ArrayList\u0026lt;\u0026gt;(); ws.popAll(objects); // 컴파일 에러  // Collection\u0026lt;Object\u0026gt; is not subtype of Collection\u0026lt;Number\u0026gt; } 이 때는 E의 컬렉션이 아니라 E의 상위 자료형(supertpye) 컬렉션 이라고 해야 한다.\n Collection\u0026lt;E\u0026gt; -\u0026gt; E의 컬렉션 Collection\u0026lt;? super E\u0026gt; -\u0026gt; E의 상위 타입의 컬렉션  public void popAll(Collection\u0026lt;? super E\u0026gt; dst) { while(!isEmpty()) { dst.add(pop()); } }  객체의 생산자나 소비자 역할을 하는 메서드 인자의 자료형은 와일드카드로 해라 둘을 동시에 하는 메서드 인자는 와일드 카드 무쓸모 자료형이 정확히 일치해야 하기 때문  PECS (Produce - Extends, Consumer - Super) #   인자가 T 생산자 라면 \u0026lt;? extends T\u0026gt;, T 소비자라면 \u0026lt;? super T\u0026gt;  Stack 예를 들자면 pushAll의 인자 src 는 스택에 사용될 E 형의 객체 만드는 생산자이므로 extends public void pushAll(Iterable\u0026lt;? extends E\u0026gt; src) E a = ? producer; popAll 의 인자 dst 는 스택 내의 객체를 소비하므로 super.. public void popAll(Collection\u0026lt;? super E\u0026gt; dst) ? consumer = E a; 앞서 했던 union(Set\u0026lt;E\u0026gt; e1, Set\u0026lt;E\u0026gt; e2) method 는 producer 이므로 union(Set\u0026lt;? extends E\u0026gt; e1, Set\u0026lt;? extends E\u0026gt; e2) 로 하는게 좋다.\nreturn type 으로 와일드 카드를 쓰지 말 것 #  반환형으로 와일드카드가 나가면 사용자가 명시적 형변환을 해주어야 한다. 적절히만 쓰면 와일드 카드 자료형이 쓰인 것은 사용자에게 거의 노출되지 않음.\n 사용자가 와일드카드에 대해 고민한다면 클래스 API 설계가 잘못된 것이다.\n 명시적 형인자 #  위의 union 함수를 실제로 쓰면 컴파일 에러 발생 (java8 부턴 컴파일러 똑똑해져서 됨)\nSet\u0026lt;Integer\u0026gt; integers = ...; Set\u0026lt;Double\u0026gt; doubles = ...; Set\u0026lt;Number\u0026gt; numbers = union(integers, doubles); // return type 추측을 못함...  Set\u0026lt;Number\u0026gt; numbers = Uniom.\u0026lt;Number\u0026gt;union(integers, doubles); // 명시적 형인자 전달 앞서 했던 max 는 다음과 같이 고칠 수 있다.\npublic static \u0026lt;T extends Comparable\u0026lt;? super T\u0026gt;\u0026gt; T max(Collection\u0026lt;? extends T\u0026gt; c) { if (c.isEmpty()) throw new IllegalArgumentException(\u0026#34;Empty collection\u0026#34;); T result = null; for (T t : c){ if(result == null || t.compareTo(result) \u0026gt; 0) { result = t; } } return result; } 2번 PECS 적용\n argument c에 적용한 것은 직관적. T 객체의 생산자 이므로 Comparable\u0026lt;T\u0026gt; 는 언제나 T 인자를 소비해서 int 값을 반환함 따라서 consumer 니까 super 로 해야 함 . Comparable 과 Comparator는 모두 comsumer! 책의 예시로는 ScheduledFuture\u0026lt;?\u0026gt; 나옴. 이 인터페이스는 Future와 Delayed 인터페이스를 상속받는데 Delayed 인터페이스가 Comparable 을 extends 하고 있음. 즉 \u0026lt;T extends Comparable\u0026lt;T\u0026gt;\u0026gt; 이거로는 \u0026lt;ScheduledFuture extends Comparable\u0026lt;ScheduledFuture\u0026gt;\u0026gt; 이걸 추론할 수 있고 \u0026lt;T extends Comparable\u0026lt;? super T\u0026gt;\u0026gt; 이거로는 \u0026lt;ScheduledFuture extends Comparable\u0026lt;Delayed (super ScheduledFuture)\u0026gt;\u0026gt; 를 추론 할 수 있다.  형인자 vs 와일드카드 에선 와일드카드를 쓰자 #  public static \u0026lt;E\u0026gt; void swap(List\u0026lt;E\u0026gt; list, int i, int j); public static void swap(List\u0026lt;?\u0026gt; list, int i ,int j); 많은 method 가 형인자 형태와 와일드카드 형태 두가지로 표현 가능 public API 에서는 와일드카드가 좋음. 간단하기 때문에.\n 형인자가 메소드 선언에서만 나타나면 와일드카드로 바꾸자\n // 문제 있음 public static void swap(List\u0026lt;?\u0026gt; list, int i, int j){ list.set(i, list.set(j, list.get(i))); } 컴파일 에러 발생. List\u0026lt;?\u0026gt; 에는 null 말고 어떤 것도 넣을 수 없기 때문 해결 방법으로 helper method 에서 타입 추론 도와주도록 함\npublic static void swap(List\u0026lt;?\u0026gt; list, int i, int j) { swapHelper(list, i, j); } private static \u0026lt;E\u0026gt; void swapHelper(List\u0026lt;E\u0026gt; list, int i, int j) { list.set(i, list.set(j, list.get(i))); } 요약 #   와일드카드 쓰면 좀 더 유연한 API 구현 가능 널리 쓰일 라이브러리라면 필수적으로 고려해야 한다 PECS 암기하자 암기하자 모든 Comparable 과 Comparator 는 Consumer 이다  Item 32: Combine generics and varargs judiciously generic 과 다인자변수를 잘 조합하자 #  varargs 는 method args 를 다인자로 받을 수 있게 한 것\nstatic void func(int... ints); //client func(1,2,3,4); 내부적으로 인자를 array 에 보관. 인자가 generic 이면 Heap Pollution 문제 생길 수 있다.\n Heap Pollution : 형인자 자료형 변수가 형인자 자료형이 아닌 객체를 참조할 때 상황.. runtime 에서 ClassCastException 날 가능성 높음.  static void dangerous(List\u0026lt;String\u0026gt;... stringLists){ // 형인자 자료형 array 가 생겨서 heap pollution  List\u0026lt;Integer\u0026gt; intList = Arrays.asList(42, 11); Object[] objects = stringLists; objects[0] = intList; String s = stringLists[0].get(0); // ClassCastException 발생 } // client public static void main(String... args){ dangerous(Arrays.asList(\u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;), Arrays.asList(\u0026#34;c\u0026#34;, \u0026#34;d\u0026#34;)); }  generic varargs array parameter 에 값 저장하는 건 좋지 않다.  의문 1 : generic array 만드는 건 못하게 하면서 method 에 generic varargs parameter 허용하는 이유는??\nList\u0026lt;String\u0026gt;[] = new ArrayList\u0026lt;String\u0026gt;[10]; // 불가능 error static void dangerous(List\u0026lt;String\u0026gt;... stringLists){ ...} //가능 warning 위험을 감수하고 서라도 유용할 때가 있어서 java 언어 설계자들이 남겨둠 Java library 들은 generic + varargs 이미 많이 쓰고 있다. Arrays.asList(T\u0026hellip; a), Collections.addAll(Collection\u0026lt;? super T\u0026gt; c) 등등. 이 Method 들은 typesafe 하다.\nmethod를 typesafe 하게 만들었어도 java 7 이전에는 warning 무시하던지, 호출할 때마다 @SuppressWarnings(\u0026quot;unchecked\u0026quot;) 붙여야 했다. java7 에 @SafeVarags 어노테이션 나와서 method 선언부에 붙여주면 warning은 안 뜬다. 중요한 건 정말 typesafe 할 때만 붙여주어야 한다는 것. typesafe 조건 #   generic varargs array에 아무 것도 새로 저장하지 말 것(overwrite 하지 말 것) 그 array의 reference 를 method 밖으로 노출시키지 말 것(해당 method 외의 다른 code 가 1번을 위반할 수 있다)  typesafe 의 예 input 으로 들어온 리스트의 배열의 원소들을 하나의 리스트로 만들어서 내보냄. @SafeVarargs static \u0026lt;T\u0026gt; List\u0026lt;T\u0026gt; flatten(List\u0026lt;? extends T\u0026gt;... Lists) { List\u0026lt;T\u0026gt; result = new ArrayList\u0026lt;\u0026gt;(); for(List\u0026lt;? extends T\u0026gt; list : lists){ return.addAll(list); } return result } 중요한게 Override 안 될 메소드에만 @SafeVarargs 다는게 중요 가능한 모든 override된 method 들이 safe 한 지 보장하는 것은 불가능하기 때문 Java8 에서는 static method나 final instance method 에만 저 annotation을 달 수 있고, Java9 에서는 private instance method 도 가능해졌다.\n또 다른 대안은 varargs 사용하지 않고 List parameter를 사용하는 것\nstatic \u0026lt;T\u0026gt; List\u0026lt;T\u0026gt; flatten(List\u0026lt;List\u0026lt;? extends T\u0026gt;\u0026gt; Lists) { List\u0026lt;T\u0026gt; result = new ArrayList\u0026lt;\u0026gt;(); for(List\u0026lt;? extends T\u0026gt; list : lists){ result.addAll(list); } return result } 요야야야약 #   varargs 랑 generic은 잘 안 맞는다 generic varargs parameter 는 typesafe 하지는 않지만, 문법적으로는 맞다. method의 parameter 로 generic varargs parameter 쓸 꺼면 typesafe 한지 확인하고 @SafeVarargs 꼭 달아라  Item 33: Consider typesafe heterogeneous containers 형 안전 다형성 컨테이너를 쓰면 어떨지 따져보라 #  Generic은 Set 이나 Map 같은 collection 이나 ThreadLocal 이나 AtomicReference 같은 하나의 원소만을 담는 컨테이너에 많이 쓰인다. 이 때 형인자를 받는 부분은 컨테이너임. 보통은 컨테이너당 type parameter 가 정해져 있다. 이것을 유연하게 하나의 컨테이너에 여러 Type 이 담기면서도 형안정성을 유지할 수 있게 해보자.즉 컨테이너가 아니라 key 값에 형인자를 지정하자.\n// Typesafe heterogeneous container pattern 형 안전 다형성 컨테이너 public class Favorites { private Map\u0026lt;Class\u0026lt;?\u0026gt;, Object\u0026gt; favorites = new HashMap\u0026lt;\u0026gt;(); public \u0026lt;T\u0026gt; void putFavorite(Class\u0026lt;T\u0026gt; type, T instance) { favorites.put(Objects.requireNonNull(type), instance); } public \u0026lt;T\u0026gt; T getFavorite(Class\u0026lt;T\u0026gt; type) { return type.cast(favorites.get(type)); } } // client 부분 public static void main(String[] args) { Favorites f = new Favorites(); f.putFavorite(String.class, \u0026#34;Java\u0026#34;); f.putFavorite(Integer.class, 12345); String favoriteString = f.getFavorite(String.class); String favoriteInteger = f.getFavorite(Integer.class); } Favorites 객체는 형 안전(type 에 맞게 캐스팅해서 돌려줌 Class.cast), 다형성(하나의 type 이 아닌 여러 type을 컨테이너 내부에 보관 Class\u0026lt;?\u0026gt;)\n private Map\u0026lt;Class\u0026lt;?\u0026gt;, Object\u0026gt; favorites 여기서 map에 unbounded wildcard 쓰면 아무것도 못하지 않나요?   여기서 와일드 카드는 map(컨테이너)이 아니라 key에 사용된다. 모든 키가 상이한 형인자 자료형 가질 수 있다는 의미.\n  favorites 의 value가 그냥 Object 인데 괜찮나?   type은 key 이고 해당 해당 type으로 알아서 value를 캐스팅해주면 좋겠지만 java type system 이 그렇게 강력하진 않다. 하지만 우리는 그걸 알고 있으니 꺼내올 때 적용 해주면 됨\n 현재 Favorites 2가지 문제 있음\n 악의적인 클라이언트가 형 안전성을 꺠뜨릴 수 있다.  // client 부분 public static void main(String[] args) { Favorites f = new Favorites(); Class a = String.class; // use raw type Class!  f.putFavorite(a, 1234); // putFavorite 잘 작동함... key: String.class value: Integer } raw type을 사용하면 generic 을 passing 하기 때문에 문제 발생. dynamic type checking 을 해주어야 한다.\npublic \u0026lt;T\u0026gt; void putFavorite(Class\u0026lt;T\u0026gt; type, T instance) { favorites.put(Objects.requireNonNull(type), type.cast(instance)); } 같은 전략을 쓰는 컬랙션 wrapper class: checkedSet, checkedList, checkedMap\nList safeList = Collections.checkedList(new ArrayList(), String.clss); safeList.add(123); // ClassCastException 발생 실체 불가능한 자료형(non-reifiable type) 에는 쓰일 수 없다.   reifiable type : type 정보를 runtime 에서 전부 사용 가능. ex) primitive, non-generic, raw type, invocations of unbound wildcards non-reifiable type : type erasure 에 의해 type 정보가 compile time 에서 지워짐 ex) unbound wildcard 를 제외한 generic  따라서 key로 String String[] 은 쓰일 수 있지만 List\u0026lt;String\u0026gt; 은 쓰일 수 없다. List\u0026lt;String\u0026gt; 의 class 객체를 얻을 수 없기 때문. List\u0026lt;String\u0026gt; 이랑 List\u0026lt;Integer\u0026gt; 는 같은 class 객체 List.class를 공유한다. 만일 자료형 리터럴(List\u0026lt;String\u0026gt;.class)이 가능하면 Favorites 객체는 올바르게 동작 못할 것 해결책 #   상위 자료형 토큰(super type token) 상속과 reflection 사용해서 구현  String.class(클래스 리터럴) -\u0026gt; Class\u0026lt;String\u0026gt; (타입 토큰) ??? -\u0026gt; Class\u0026lt;List\u0026lt;String\u0026gt;\u0026gt; 얻을 수 있다면 가능\nClass.getGenericSuperClass() #   바로 위 수퍼 클래스의 타입을 반환 수퍼 클래스가 parameterized type 이면 실제 타입 파라미터를 반영한 타입을 반환  ParameterizedType.getActualTypeArguments() #   실제 파라미터 정보를 구한다.  즉 다음과 같이 실제 타입을 구할 수 있다\nclass Super\u0026lt;T\u0026gt; {} class Sub extends Super\u0026lt;List\u0026lt;String\u0026gt;\u0026gt; {} Sub sub = new Sub(); Type typeOfGenericSuperclass = sub.getClass().getGenericSuperclass(); //Super\u0026lt;List\u0026lt;String\u0026gt;\u0026gt; Type actualType = ((ParameterizedType) typeOfGenericSuperclass).getActualTypeArguments()[0]; // List\u0026lt;String\u0026gt; 코드 구현도 찾아서 했는데 복잡해서\u0026hellip;\n한정적 자료형 토큰(bound type parameter) #  Favorites 가 사용하는 자료형 토큰은 비한정적(unbound). get put 에 전달되는 argument를 제한 하고 싶을 때에는 한정적 자료형\nannotation API: 한정적 자료형 토큰 많이 씀\npublic \u0026lt;T extends Annotation\u0026gt; T getAnnotation(Class\u0026lt;T\u0026gt; annotationType)  getAnnotation : 프로그램 실행 중에 어노테이션을 읽은 메소드. AnnotatedElement 인터페이스에 있음 AnnotatedElement : 클래스나 메서드, 필드 등 프로그램 요소들, 즉 리플렉션 객체를 표현하는 리플렉션 자료형들이 구현하는 인터페이스  // 컴파일 시점에는 자료형을 알 수 없는 어노테이션을 실행시간에 읽어내는 메서드 // 방식 1 무점검 형변환 static Annotation getAnnotation(AnnotatedElement element, String annotationTypeName) { Class\u0026lt;?\u0026gt; annotationType = null; try { @SuppressWarnings(\u0026#34;unchecked\u0026#34;) annonationType = (Class\u0026lt;? extends Annotation\u0026gt;) Class.forName(annotationTypeName); //무점검 형변환 이므로 warning 발생  } catch (Exception ex) { throw new IllegalArgumentException(ex); } return element.getAnnotation(annotationType); } 클래스 Class 는 이런 종류 형변환 안전하게 동적으로 처리해주는 객체 메서드 asSubclass 가 이미 있다. 특정 객체를 하위 클래스의 class 객체로 형변환시켜줌.\n// 컴파일 시점에는 자료형을 알 수 없는 어노테이션을 실행시간에 읽어내는 메서드 // 방식 2 dynamic 형변환 메서드 사용 static Annotation getAnnotation(AnnotatedElement element, String annotationTypeName) { Class\u0026lt;?\u0026gt; annotationType = null; try { annonationType = Class.forName(annotationTypeName); } catch (Exception ex) { throw new IllegalArgumentException(ex); } return element.getAnnotation( annotationType.asSubclass(Annotation.class); ) } //asSubclass 구현 .. @SuppressWarnings(\u0026#34;unchecked\u0026#34;) public \u0026lt;U\u0026gt; Class\u0026lt;? extends U\u0026gt; asSubclass(Class\u0026lt;U\u0026gt; clazz) { if (clazz.isAssignableFrom(this)) return (Class\u0026lt;? extends U\u0026gt;) this; else throw new ClassCastException(this.toString()); } 요오오오약 #   컨테이너 대신 키를 제네릭으로 하면 형인자 개수의 제약이 없는 형 안전 다형성 컨테이너를 만들 수 있다. 그런 컨테이너는 Class 객체를 키로 쓰는데 그러한 객체를 자료형 토큰(type token) 이라고 한다. 키 자료형을 직접 구현하는 것도 가능하다. 예를 들어 DB 레코드를 표현하는 DataBaseRow 클래스(컨테이너) 는 제네릭 자료형 Column를 키로 사용할 수 있다.  "},{"id":41,"href":"/TIL/effectivejava/lambdasandstreams/","title":"Effective Java","section":"Effective Java","content":"Chapter 7 Lambdas and Streams #  자바8에 함수형 인터페이스, 람다 메서드 참조 등이 추가됨. Stream API 또한 추가되어서 이러한 언어변화에 맞는 데이터 요소 처리를 돕는다.\n규칙 42 익명 클래스 보다 람다를 쓰자 #  오래전부터 1개의 추상 메소드를 갖는 인터페이스는 function type 으로 쓰여옴. 이 인터페이스를 구현한 function objects 는 함수를 나타냄. JDK1.1 부터 함수 객체를 만드는 가장 대표적인 수단은 익명 클래스였음 // 글자 길이로 정렬하는 함수 객체 Collections.sort(words, new Comparator\u0026lt;String\u0026gt;() { public int compare(String s1, String s2) { return Integer.compare(s1.length(), s2.length()); } }) // java8 부터 Collections.sort(words, (s1,s 2) -\u0026gt; Integer.compare(s1.length(), s2.length())); 람다의 특징 #   lambda의 타입(Comparator) parameter (String s1, String s2) return value (int) 코드에 표시 안됨. 컴파일러가 컨텍스트를 보고 다 추론함. 특정 경우는 컴파일러가 추론 못하고 프로그래머가 타입을 지정해야 할 수도 있음. 추론 규칙을 자세히 이해하기는 어려운데, 일단 가능한 한 다 생략해버려도 된다.  컴파일러가 추론할 때 Generic을 많이 이용하기 때문에 잘 쓰는게 좋다. 위 예제에서 words 가 List아니라 List 로 선언 되었으면 컴파일 되지 않는다.\nComparator 가 제공하는 snippet 메서드를 이용하면 더 짧게 할 수 있다.\nCollections.sort(words, comparingInt(String::length)); java8 부터 List에 추가된 메소드를 이용하면 더 줄 일 수 있다.\nwords.sort(comparingInt(String::length)); 앞서 enum type 에 나왔던 Operation을 람다로 리팩토링하면 다음과 같다\n// lambdas 적용 전 public enum Operation { PLUS(\u0026#34;+\u0026#34;) { public double apply(double x, double y) {return x + y;} }, MINUS(\u0026#34;-\u0026#34;) { public double apply(double x, double y) {return x - y;} }, TIMES(\u0026#34;*\u0026#34;) { public double apply(double x, double y) {return x * y;} }, DIVIDE(\u0026#34;/\u0026#34;) { public double apply(double x, double y) {return x / y;} }; private final String symbol; Operation(STring sysmbol) {this.symbol = symbol;} public abstract double apply(double x, double y); } public enum Operation { PLUS(\u0026#34;+\u0026#34;, (x, y) -\u0026gt; x + y), MINUS(\u0026#34;-\u0026#34;, (x, y) -\u0026gt; x - y), TIMES(\u0026#34;*\u0026#34;, (x, y) -\u0026gt; x * y), DIVIDE(\u0026#34;/\u0026#34;, (x, y) -\u0026gt; x / y); private final String symbol; private final DoubleBinaryOperator op; Operation(String symbol, DoubleBinaryOperator op) { this.symbol = symbol; this.op = op; } public double apply(double x, double y) { return op.applyAsDouble(x, y); } } DoubleBinaryOperator 는 java.util.function에 정의된 함수형 인터페이스 중 하나. 2개의 double을 인자로 받아서 하나의 double을 반환한다.\n주의할 점 #  람다는 이름과 설명이 없기 때문에 코드가 그 내용을 설명해주지 못하거나 또는 두 세 줄이 넘어가면 안쓰는 게 좋다. 한 줄이 이상적이고 최대 3줄이 허용범위임.\n익명 클래스가 람다보다 좋은 점 #    객체를 생성할 수 있다??(lambda는 객체가 아닌가?)\n  여러 추상 메소드가 있는 경우에도 쓸 수 있다\n  람다는 자기 자신의 참조를 얻을 수 없다 (lambda 에서 this 는 감싸고 있는 instance 를 의미. 익명 클래스는 클래스 자기 자신을 의미)\n  람다와 익명클래스 둘 다 직렬화 역직렬화 믿을 수 없음. (JVM 따라 달라서 인 듯)\n  가급적 람다와 익명 클래스 직렬화 하지 말 것.\n  정말 하고 싶으면 private static nested class의 객체를 이용할 것 (Comparator 처럼)\n  요약 #   람다는 함수 객체를 이용하는 최고의 방법 진짜 클래스 객체가 필요하지 않으면 익명 클래스보단 람다 쓰자 람다 쓰면 함수형 프로그래밍 입문 하는 거다 어서 쓰자  규칙 43 람다보다 메소드 참조를 쓰자 #  람다의 장점은 간결함임. 자바는 람다보다 더 간견한 방식을 추가함: method reference\n"},{"id":42,"href":"/TIL/effectivejava/methodscommontoallobjects/item10/","title":"Effective Java","section":"Effective Java","content":"Item 10: Obey the general contract when overriding equals #  equals를 구현하는 건 쉽지 않다. 가장 쉬운 방법은 override 하지 않는 것이다. 다음 조건 중 하나라도 만족하면 구현하지 않는 것이 좋다.\n Each instance of the class is inherently unique. Thread와 같은 객체는 값보다 엔티티 자체를 표현한다. Object에서 제공하는 equals로 충분하다 There is no need for he class to provide a logical equality test. Client가 해당 기능을 필요하지 않다고 생각한다면 굳이 구현할 필요가 없다. A superclass has already overridden equals, and the superclass behavior is appropriate for this class. 예를 들어 Set은 AbstractSet, List 는 AbstractList, Map은 AbstractMap에서 미리 구현했다. The class is private or package-private and your are certain that its equals method will never be invoked. 정말 위험을 감수하기 싫으면 다음과 같이 처리할 수도 있다.  @Override public boolean equals(Object o) { throw new AssertionError(); } 정말 equlas 를 override 하고 싶으면 일반 규칙을 준수해야 한다. 다음과 같다.\n Reflexive: for any Non-null reference value x, x.equals(x) must return true Symmetric: for any non-null reference values x and y, x.equals(y) == y.equals(x) Transitive: for any non-null reference values x,y,z, if x.equals(y) == true and y.equals(z) == true then x.equals(z) must return true Consistent: equals가 여러번 불려도 x, y 가 변경되지 않았다면 항상 같은 값을 return 해야 한다. x.equals(null) must return false  \u0026hellip; 갑자기 이산수학이.. 하나씩 살펴보자\n Reflexivity 이건 객체는 자기 자신과 항상 같아야 함을 뜻한다. 이걸 위반하는게 더 힘든데, 이 어려운 걸 해낸다면 collection에서 자기 자신을 찾을 수 없을 것이다. Symmetry 는 두 객체의 equals 값이 항상 같아야 한다는 것이다. 다음과 같이 만들면 위반할 수 있다.  // violate sysmmetry public final class CaseInsensitiveString { private final String s; public CaseInsensitiveString(String s) { this.s = Objects.requireNonNull(s) } @Override public boolean equals(Object o) { if(o instanceof CaseInsensitiveString) { return s.equalsInnoreCase( ((CaseInsensitiveString)o).s ); } if(o instanceof String) { return s.equalsIgnoreCase(String o); // one-way interoperability!  } return false; } } 위의 경우 CaseInsensitiveString.equals(String s) 는 true 가 나올수 있지만 String.equals(CaseInsensitiveString cis) 는 항상 false가 나오게 된다. 이렇게 되면 이 객체의 행동을 예측할 수 없게 된다. 따라서 String과 통합하려는 시도는\u0026hellip; 멍청하다고 할 수 있다.\n// 그냥 String 통합은 포기! @Override public boolean equals(Object o) { return o instanceof CaseInsensitiveString \u0026amp;\u0026amp; s.equalsInnoreCase(((CaseInsensitiveString)o).s); }  Transitivity 이건 a와 b가 같고 b와 c 가 같으면 a와 c 가 같아야 함을 말한다. 위반하는걸 상상하기 어려운데\u0026hellip; subclass가 equals에 영항을 주는 추가 정보를 담는 경우를 생각해보자.  public class Point { private final int x; private final int y; public Point(int x, int y) { this.x = x; this.y = y; } @Override public boolean equals(Object o) { if(!(o instanceof Point)) return false Point p = (Point)o; return p.x == x \u0026amp;\u0026amp; p.y == y; } } public class ColorPoint extends Point { private final Color color; public ColorPoint(int x, int y, Color color) { super(x, y); this.color = color; } } 이 상태로 두면 ColorPoint는 부모인 Point의 equals를 사용하게 된다. 당연히 color 정보는 무시되고, 이걸 의도하진 않았겠으니 override 해야 할 거다.\n// violates symmetry @Override public boolean equals(Object o) { if(!(o instanceof ColorPoint)) { return false; } return super.equals(o) \u0026amp;\u0026amp; ((ColorPoint)o).color == color; } 문제는 Point와 ColorPoint를 비교할 때 생긴다. 전자는 color를 무시하고 비교하지만 후자는 항상 false가 나오기 때문이다. 따라서 symmetry 를 위반한다. 그래서 만약 다음과 같이 바꾼다면\n// violates transivity @Override public boolean equals(Object o) { if(!(o instanceof Point)) { return false; } // o is norla Point  if(!(o instanceof ColorPoint)) { return o.equals(this); } // o is ColorPoint  return super.equals(o) \u0026amp;\u0026amp; ((ColorPoint)o).color == color; } 이러면 sysmmetry는 해결되지만, transitivity에서 문제가 생긴다.\n// what if? ColorPoint p1 = new ColorPoint(1, 2, Color.RED); Point p2 = new Point(1, 2); ColorPoint p3 = new ColorPoint(1, 2, Color.BLUE); p1.equals(p2) =\u0026gt; true p2.equals(p3) =\u0026gt; true p1.equals(p3) =\u0026gt; false 왜냐하면 Point는 color를 무시하기 때문에 이런 결과가 나온다. 또한 다른 subclass가 있다고 한다면 무한 recursion에 빠질 수 있다.\ngetClass를 사용해서 해결할 수 있다는 사람들도 있다.\n@Override public boolean equals(Object o) { if(o == null || o.getClass() != getClass()) { return false; } Point p = (Point) o; return p.x == x \u0026amp;\u0026amp; p.y == y; } 같은 클래스여야만 equals를 확인한다. 그럴듯해보이지만 결과는 그렇지 않다. 상속을 완전 무시하는 결과이다. 따라서 지양해야하는 방향이다.\n그럼 해결책은 무엇일까? 이건 객체지향 언어의 근본적인 동일성 문제이다. equals를 깨지 않으면서 클래스를 상속받아 값을 추가할 방법은 없다.\n상속을 통한 방법은 없지만, 좋은 방법이 있다, Item 18: 상속보단 구성! ColorPoint가 Point를 상속하는 대신 필드를 갖게하고 view 메소드를 주는 것이다.\npublic class ColorPoint { private final Point point; private final Color color; public ColorPoint(int x, int y, Color color) { point = new Point(x, y); this.color = Objects.requireNonNull(color); } public Point asPoint() { return point; } @Override public boolean equals(Object o) { if(!(o instanceof ColorPoint)) { return false; } ColorPoint cp = (ColorPoint)o; return cp.point.equals(point) \u0026amp;\u0026amp; cp.color.equals(color); } }  Non-nullity: instanceof keyword 가 인자가 null로 들어오면 false를 return하기 때문에 굳이 null check를 별도로 할 필요는 없다.  결론적으로 수준높은 equals를 짜기 위해 다음 과정이 필요하다.\n Use the == operator to check if the argument is a reference to this object. 최적화를 위한 것 Use the instanceof operator to check if the argument has the correct type. interface 가 있다면 interface를 이용해라(Collection) Cast the argument to the correct type For each significant field in the class, check if that field of the argument matches the corresponding field of this object  "},{"id":43,"href":"/TIL/effectivejava/methodscommontoallobjects/item11/","title":"Effective Java","section":"Effective Java","content":"Item 11: Always override hashCode when you override equals #  equals를 구현한 클래스는 항상 hashcode 를 구현해야 한다. 그렇지 않으면 HashMap 이나 HashSet 같은 collection을 제대로 사용할 수 없다. 다음과 같은 규약이 있다.\n 한 객체에 반복적으로 hashcode 가 호출될 때, 항상 같은 값을 반환해야 한다. equals로 true로 판단되는 객체는 같은 hashcode를 반환해야 한다. equals로 false가 나올 때 다른 hashcode가 나올 필요는 없다. 하지만 다른 값 나오게 하는게 hashtable 성능을 향상 시킨다.  가장 많이 실수하는게 2번째 규칙이다. 2 개의 다른 객체는 equals를 통해 같게 할 수 있지만 Object의 hashcode로는 그냥 다른 2개의 객체이다. 예를 들어 다음과 같은 HashMap 예제를 생각해보자\nMap\u0026lt;PhoneNumber, String\u0026gt; m = new HashMap\u0026lt;\u0026gt;(); m.put(new PhoneNumber(707, 867, 5309), \u0026#34;Jenny\u0026#34;); m.get(new PhoneNumber(707, 867, 5309)); 이러면 \u0026ldquo;Jenny\u0026quot;를 돌려주기를 기대하겠지만 실상은 null을 반환한다. 왜냐하면 새로운 객체를 만들어 넣기 때문에 hashcode 값이 다르기 때문이다. 해결 방법은 적절한 hashcode() 함수를 구현하는 것이다.\n방법은 다음과 같다\n result 란 이름의 int 변수를 선언해서 중요 변수들ㅇ릐 값을 2.1 방식으로 계산해 초기화한다. 모든 중요 변수들에 대해 다음 작업을 진행한다.  필드에 대해 int hashcode 를 계산한다.  필드가 primitive type이면 Type.hashcode(f) 를 이용해 값을 계산한다. 필드가 객체이고, 이 클래스의 equals 메소드가 해당 객체의 equals를 이용한다면 해당 필드의 hashCode 메소드를 이용해라. 더 복잡한 비교가 필요하면 canonical representation 을 이용해서 hashCode를 구해라. 만약 필드가 null이면 0 을 쓰는 것이 전통적이다. 필드가 array라면 각각의 중요한 element 가 분리된 필드인 것처럼 적용해라. array가 중요하지 않은 녀석이면 0이 아닌 상수를 써도 된다. 모든 element가 중요하면 Arrays.hashCode()를 써라   위의 작업을 통해 구해진 hashcode를 result와 합친다.   result = 31 * result + c;\n result 를 반환한다.    equals에 쓰이지 않는 필드는 사용해서는 안된다. 2.2의 과정을 반복적으로 수행하면 필드 순서에 따라 다른 hashcode가 나오게 되어 더 좋은 hash function이 된다. 31은 홀수 소수이기 때문에 선택되었는데, 만약 짝수라면 overflow 발생 했을 때 정보가 사라지게 되는 단점이 있다. 소수를 쓰는 이유는 덜 명확한데 그냥 그렇게 써왔다. 31의 장점은 최적화를 위해 쉬프트 연산과 뺄샘으로 대체할 수 있다는 것이다.\n 31 * i = (i\u0026laquo;5) - i\n 모던 JVM은 이 작업을 자동으로 진행한다.\n// 전형적인 hashcode @Override public int hashCode() { int result = Short.hashCode(areaCode); result = 31 * result + Short.hashCode(prefix); result = 31 * result + Short.hashCode(lineNum); return result; } // 좀 더 느리고 평범한 hashcode @Override public int hashCode() { return Objects.hash(lineNum, prefix, areaCode); } 만약 클래스가 immutable 하고 hashcode 계산하는 비용이 크다면 캐싱을 생각해볼 수 있다.\nprivate int hashCode; @Override public int hashCode() { int result = hashCode; if( result == 0) { result = 31 * result + Short.hashCode(prefix); result = 31 * result + Short.hashCode(lineNum); hashCode = result; } return result; } 요약하면 equlas 쓸 땐 항상 hashcode를 오버라이딩 해야 한다.\n"},{"id":44,"href":"/TIL/effectivejava/methodscommontoallobjects/item12/","title":"Effective Java","section":"Effective Java","content":"Always override toString #  Object 가 default toString 메소드를 제공하지만 사람이 읽기에 충분치 한다. [해당 클래스이름]@[Hexa hashcode] 형태를 이루고 있다. 따라서 모든 하위 클래스에서 toString을 override 하는게 좋다. 그리고 특정 포멧을 결정하든 말든 주석으로 의도를 명확히 써놓아야 한다.\n"},{"id":45,"href":"/TIL/effectivejava/methodscommontoallobjects/item13/","title":"Effective Java","section":"Effective Java","content":"Item 13: Override clone judiciusly #  Cloneable 인터페이스는 복사를 허용하기 위해 만들어졌다. 하지만 Object의 clone method를 쓸 수 없기 때문에 목적 달성에 실패했다.\npublic class Employee { private String name; public Employee(String name) { this.name = name; } public String getName() { return name; } public static void main(String[] args) { Employee emp = new Employee(\u0026#34;Abhi\u0026#34;); try { Employee emp2 = (Employee) emp.clone(); System.out.println(emp2.getName()); } catch (CloneNotSupportedException e) { e.printStackTrace(); } } } // return CloneNotSupportedException... 그럼 Cloneable 인터페이스는 무슨 역할을 할까? 그것은 Object의 clone 메소드의 동작을 정한다. 만약 한 클래스가 Cloneable을 구현했다면 Object.clone() 메소드는 field-by-field copy 객체 를 반환한다. 구현하지 않았다면 CloneNotSupportedException을 반환한다. 이건 매우 드문 인터페이스의 사용이다. 보통 인터페이스 구현은 클라이언트에게 그 클래스가 할수 있는 것을 말해준다. 이 경우 인터페이스는 부모클래스의 보호된 메소드 동작을 허용하게 한다. 실제 상황에서 Cloneable을 구현한 클래스는 적절한 public clone method를 반환해야 한다. 하지만 생성자를 호출하지 않고 객체를 생성하기 때문에 매우 위험하다.\nclone 메소드에선 super.clone() 을 호출해야 한다. 꼭\u0026hellip; 이걸 하지 않고 부모 클래스의 생성자를 호출하면 컴파일러는 문제를 일으키지 않지만 실제 JVM 동작에서 원치 않는 동작을 할 것이다. 예외적으로 Cloneable을 구현한 클래스가 final이면 sub클래스가 없기 때문에 이런 걱정을 할 필요가 없다. 하지만 super.clone() 을 호출하지 ㅇ낳으면 굳이 Cloneable을 구현할 필요가 없다, Object의 clone 구현에 의존할 필요가 없으니까!\n잘 동작하는 clone 메소드를 제공하는 부모클래스를 가진 클래스에서 Cloneable을 구현한다고 생각해보자. 우선 super.clone을 호출하자. 반환되는 객체는 완벽한 replica 이다. 모든 필드를 primitive나 immutable 객체로 선언했다면 더 처리할 필요가 없다.\n//Item 11의 PhoneNumber 예제 @Override public PhoneNumber clone() { try { return (PhoneNumber) super.clone(); } catch(CloneNotSupportedException e) { throw new AssertionError(); // Can\u0026#39;t happen.. !  } } return 타입을 자기 자신 클래스로 하는게 바람직하다. 클라이언트의 불필요한 캐스팅도 막고 java에서 covariant return type을 지원하기 때문에!\n만약 field에 mutable object 가 있으면 대재앙이 일어난다. 예를 들어 Item 7의 스택을 생각해보자 이 클래스를 cloneable 하게 만들기 위해 단순히 super.clone() 을 한다면 copy stack 객체는 size 필드는 같지만 elements field는 original 객체의 array와 같은 array를 바라보게 된다. 따라서 original을 변경하면 NPE가 발생할 가능성이 아주 많다. 결과적으로 clone 메소드는 생성자처럼 기능한다. 따라서 original 객체에 영향을 주지 않게 만들어야 한다. 위 예제에서 stack이 적절히 동작하게 만드려면 stack의 내부도 copy 해야 한다. 가장 쉬운 방법은 elements array도 copy 하는 것이다.\nOverride public Stack clone() { try { Stack stack = (Stack)super.clone(); result.elements = elements.clone(); return result; } catch (CloneNotSupportedException e) { thorw new AssertionError(); } } 근데 위의 예제는 stack.elements 가 final 필드면 불가능하다. 이건 근본적인 문제인데, serialization 처럼 mutable objects를 final 필드로 갖고 있는 형태와 사용할 수 없다. cloneable 하려면 final을 없애야 한다.\n단순 recursive copy 만으로는 부족할 수 있다. hashtable을 생각해보자\npublic class HashTable implements Cloneable { private Entry[] buckets = ...; private static class Entry { final Object key; Object value; Entry next; Entry(Object key, Object value, Entry next) { this.key = key; this.value = value; this.next = next; } } } Stack에서 했던 것 처럼 buckets array를 recursive 하게 clone 해보자\n@Override public HashTable clone() { try { HashTable result = (HashTable) super.clone(); result.buckets = buckets.clone(); return result; } catch (CloneNotSupportedException e) { thorw new AssertionError(); } } Copy hashtable은 자신만의 bucket 이 있지만 링크드리스트는 오리지날과 같다. 따라서 비정상동작 할 것이다. 이걸 고치기 위해선 각각 bucket 마다 링크드리스트도 copy 해야 한다.\npublic class HashTable implements Cloneable { ///...  private static class Entry { final Object key; Object value; Entry next; Entry(Object key, Object value, Entry next) { this.key = key; this.value = value; this.next = next; } Entry deepCopy() { // recursively copy the linked list  return new Entry(key, value, next == null? null : next.deepCopy()); } } @Override public HashTable clone() { try { HashTable result = (hashTable)super.clone(); result.buckets = new Entry[buckets.length]; for (int i = 0; i \u0026lt; buckets.length; i++) { if(buckets[i] != null) { results[i] = buckets[i].deepCopy(); } } return result; } catch (CloneNotSupportedException e) { thorw new AssertionError(); } } 잘 동작하는데, deepCopy가 recursive라서 stackoverFlow 가 발생할 수 있다. 이를 iteration으로 바꾸면\u0026hellip;\nEntry deepCopy() { Entry result = new Entry(key, vaule, next); for (Entry p = result; p.next != null; p = p.next) { p.next = new Entry(p.next.key, p.next.value, p.next.next); } } 결국 복잡한 mutable 객체를 cloning 하는 최종 방법은 우선 super.clone을 불러서 필드를 초기화하고 original 객체의 state를 재생산하는 것이다. 따라서 HashTable 예제에서 클로닝이 제대로 된 후에 put 메소드가 불려서 복사된 객체에서 동작한다. 이 방식이 깔끔하긴 하지만 super.clone() 한 필드를 덮어써야 하기 때문에 느릴 수 있다.\n생성자와 같이 clone 메소드 내에서는 override 가능한 메소드를 불려선 안된다. 이게 가능하게 되면 subclass가 제대로 필드 바꾸기 전에 original을 오염시킬 수 있다. 따라서 put(key, value) 는 final 이거나 private 여야 한다.\npublic clone 메소드는 CloneNotSupportedException을 throw 해서는 안된다, check exception 을 사용하지 않는게 쓰기 편하기 때문에.\n상속을 위한 클래스를 설계할 때에는 Cloneable을 implements 해서는 안된다. 만약 clone을 구현한다면 Object의 clone 메소드 처럼 CloneNotSupportedException을 throw 하는 protected 메소드로 구현해야 한다. 그래야 subclass 들은 마치 Object를 바로 상속받은 것 처럼 Cloneable을 구현할지 말지 자유를 얻을 수 있다. 반대로 clone 동작을 허용하지 않는 것을 택했다면 아예 막을 수 있다.\n@Override public final Object clone() throws CloneNotSuportedException { throw new CloneNotSupportedException(); } 또 Objects의 clone() 메소드는 sync 하지 않기 때문에 병렬 프로그래밍을 한다면 synchronization을 고려해야 한다.\n이런 복잡한 작업이 꼭 필요할까? 거의 아니다.copy 생성자나 copy factory를 구현하는게 더 좋은 방법이다.\n// Copy constructor public Yum(Yum yum){}; // Copy factory public static Yum newInstance(Yum yum){}; 클론에 비해 위 방식들의 장점은 이상한 객체 생성을 하지 않아도 된다는 것이다.final field도 신경쓸 필요 없다. 불필요한 exception 던지지 않는다. casting도 필요 없다. 또한 자신이 속한 class의 인터페이스를 구현한 타입 클래스도 인자로 받을 수 있다. 예를 들어 TreeSet을 HashSet으로 바꾸려 한다면 clone은 지원하지 않지만, new TreeSet(hashSet); 으로 가능하다.\n결론적으로 array 복사정도면 모를까 거의 쓰지 말자.. copy constructor 나 copy factory 쓰자\n"},{"id":46,"href":"/TIL/effectivejava/methodscommontoallobjects/item14/","title":"Effective Java","section":"Effective Java","content":"Item 14: Consider implementing Comparable #  Comparable은 Object에 정의된 인터페이스가 아니고, 단독 인터페이스이다. equals와 비슷한데 순서를 정하게 해준다. Comparable을 구현한 객체 배열은 다음과 같이 정렬할 수 있다.\nArrays.sort(a); 기본적으로 java에서 값을 나타내는 클래스는 Comparable을 구현한다. 만약 알파벳 순서나, 수치 순서, 연대 순 등과 같은 natural ordering이 필요하다면 반드시 Comparable 인터페이스를 구현해야 한다.\npublic interface Comparable\u0026lt;T\u0026gt; { int compareTo(T t); } compareTo의 일반적인 규약은 equals와 비슷하다.\n 이 객체가 비교하고자 하는 녀석보다 작으면 음수를 반환, 같으면 0을 반환 크면 양수를 반환한다. 비교할 수 없는 녀석이면 ClassCastException 을 반환한다.\n  sgn() 은 signum function을 의미한다. sgn(x.compareTo(y)) == -sgn(y.compareTo(x)) for all x and y(이건 x.compareTo(y) 가 exception 나오면 y.compareTo(x) 도 exception 을 반환해야 한다는 것을 의미한다) transitive 함을 보장해야 한다.(x.compareTo(y) \u0026gt; 0 \u0026amp;\u0026amp; y.compareTo(z) \u0026gt; 0 이면 x.compareTo(z) \u0026gt; 0 이여야 한다.) x.compareTo(y) == 0 이면 sgn(x.compare(z)) == sgn(y.compare(z)) 여야 한다. (x.compareTo(y) == 0) == (x.equals(y)) 는 강제는 아니지만 정말 추천한다. Comparable을 구현하면서 이 규약을 위반하는 경우 분명히 명시해야 한다. \u0026ldquo;이 클래스는 equals와 대치되는 순서를 갖고 있습니다.\u0026rdquo;  보면 equals와 굉장히 닮아 있다, reflexivity symmetry transitivity 모두를 만족해야 한다. 따라서 같은 문제가 있다. 기존 compareTo 규약을 유지하면서 상속을 통해 확장할 방법이 없다. Comparable을 구현한 클래스에 값을 추가하고 싶다면 상속하지 마라. 구성을 통해 필드로 해당 객체를 사용하는 것이 유일한 방법이다.\n마지막 규약은 compareTo의 equality 판단 값이 equals의 판단과 같아야 한다는 것이다. 둘이 다르면 일관성이 깨졌다고 표현하고, 동작은 하겠지만 Collection, Set, Map 에서 생각대로 동작하지 않을 수 있다. 왜냐하면 이런 인터페이스들은 equals 를 이용해 보통 정의되지만, sorted algorithm은 보통 compareTo를 이용하기 때문이다. 큰 재앙은 아니지만 주의해야 한다.\ncompareTo method에서는 필드를 비교하면 되는데 객체의 경우 recursive하게 compareTo를 불러주면 된다. 만약 객체가 Comparable을 상속하지 안았다면 Comparator를 대신 써라.\npublic final class CaseInsensitiveString implements Comparable\u0026lt;CaseInsensitiveString\u0026gt; { public int compareTo(CaseInsensitiveString cis) { return String.CASE_INSENSITIVE_ORDER.compare(s, cis.s); } } 이전 버전의 책에서는 비교에서 부등흐를 사용했는데 java6부터 static compare methods들이 모든 boxed primitive type에 추가되었다. 부등호 쓰지말고 static method 사용하자.\n만약 중요한 필드가 여러개라면 비교하는 순서가 중요해진다. 가장 중요한 필드부터 차례대로 비교하고, 0이 아닌 값이 나오면 그 순간에 반환하면 된다.\npublic int compareTo(PhoneNumber pn) { int result = Short.compare(areaCode, pn.areaCode); if (result == 0) { result = Short.compare(prefix, pn.prefix); if (result == 0) { result = Short.compare(lineNum, pn.lineNum); } } return result; } 요약하면 값을 비교해야할 필요가 있을 땐 Comparable을 구현해서 쉽게 정렬하고 검색할 수 있게 해라. 부등호 사용은 피하고 static method를 사용하거나 Comparator를 구현한 Comparator를 이용해라.\n"},{"id":47,"href":"/TIL/effectivejava/serialization/","title":"Effective Java","section":"Effective Java","content":"Serialization #  규칙 76 readObject 메서드는 방어적으로 구현하라 #  변경 불가능 클래스 조차, 직렬화를 통해 불변식이 깨질 수 있다.\n 불변식 깨짐 -\u0026gt; readObject 유효성 검사 악의적 객체 참조 -\u0026gt; readObject 에서 방어적 복사  immutable class #  // 규칙 39 Period 클래스 public final class Period { private final Date start; private final Date end; public Period(Date start, Date end) { this.start = new Date(start.getTime()); this.end = new Date(end.getTime()); // 방어적 규칙  if (this.start.compareTo(this.end) \u0026gt; 0) { throw new IllegalArgumentException( start + \u0026#34; after \u0026#34; + end ); } } public Date start() { return new Date(start.getTime()); } public Date end() { return new Date(end.getTime()); } @Override public String toString() { return start + \u0026#34; - \u0026#34; + end; } } 방어 규칙 #   내부 주소는 공개하지 않는다 start \u0026lt;= end 이어야 한다.  공격1. 악의적인 바이트 스트림 공격 #  public class BogusPeriod { // Byte stream could not have come from real Period instance!  private static final byte[] serializedForm = new byte[] { (byte) 0xac, (byte) 0xed, 0x00, 0x05, 0x73, 0x72, 0x00, 0x06, 0x50, 0x65, 0x72, 0x69, 0x6f, 0x64, 0x40, 0x7e, (byte) 0xf8, 0x2b, 0x4f, 0x46, (byte) 0xc0, (byte) 0xf4, 0x02, 0x00, 0x02, 0x4c, 0x00, 0x03, 0x65, 0x6e, 0x64, 0x74, 0x00, 0x10, 0x4c, 0x6a, 0x61, 0x76, 0x61, 0x2f, 0x75, 0x74, 0x69, 0x6c, 0x2f, 0x44, 0x61, 0x74, 0x65, 0x3b, 0x4c, 0x00, 0x05, 0x73, 0x74, 0x61, 0x72, 0x74, 0x71, 0x00, 0x7e, 0x00, 0x01, 0x78, 0x70, 0x73, 0x72, 0x00, 0x0e, 0x6a, 0x61, 0x76, 0x61, 0x2e, 0x75, 0x74, 0x69, 0x6c, 0x2e, 0x44, 0x61, 0x74, 0x65, 0x68, 0x6a, (byte) 0x81, 0x01, 0x4b, 0x59, 0x74, 0x19, 0x03, 0x00, 0x00, 0x78, 0x70, 0x77, 0x08, 0x00, 0x00, 0x00, 0x66, (byte) 0xdf, 0x6e, 0x1e, 0x00, 0x78, 0x73, 0x71, 0x00, 0x7e, 0x00, 0x03, 0x77, 0x08, 0x00, 0x00, 0x00, (byte) 0xd5, 0x17, 0x69, 0x22, 0x00, 0x78 }; private static Object deserialize(byte[] sf) { try { return new ObjectInputStream(new ByteArrayInputStream(sf)).readObject(); } catch (IOException | ClassNotFoundException e) { throw new IllegalArgumentException(e); } } public static void main(String [] args) { Period p = (Period) deserialize(serializedForm); System.out.println(p); // Sat Jan 02 05:00:00 KST 1999 - Mon Jan 02 05:00:00 KST 1984  // 불변식 깨짐 ...!  } } 해결책1. readObject에서 유효성 검사 구현 #  Serializable 만 implements 하면 직렬화는 되지만 불변식 깨진다. readObject  메소드 는 실질적으로 생성자나 마찬가지(byte stream을 인자로 받는 생성자)\n유효성 검사하는 readObject 메소드를 추가한다.\nprivate void readObject(ObjectInputStream s) throws IOException, ClassNotFoundException { s.defaultReadObject(); // non-static, non-transient field 채워줌  if (start.compareTo(end) \u0026gt; 0) { throw new InvalidObjectException(start + \u0026#34; after \u0026#34; + end); } } 공격2. 악의적 객체 참조 #  public class MutablePeriod { public final Period period; public final Date start; public final Date end; public MutablePeriod() { try { ByteArrayOutputStream bos = new ByteArrayOutputStream(); ObjectOutputStream out = new ObjectOutputStream(bos); out.writeObject(new Period(new Date(), new Date())); /* * 악의적 \u0026#34;previous object refs\u0026#34; 를 추가 * Period 내부 Date 필드에 대한 것 */ byte[] ref = {0x71, 0, 0x7e, 0, 5}; bos.write(ref); // start field  ref[4] = 4; // {0x71, 0, 0x7e, 0, 4}  bos.write(ref); // end field  // Period 와 훔친 Date 참조 역직렬화  ObjectInputStream in = new ObjectInputStream(new ByteArrayInputStream(bos.toByteArray())); period = (Period) in.readObject(); start = (Date) in.readObject(); end = (Date) in.readObject(); } catch (IOException | ClassNotFoundException e) { throw new AssertionError(e); } } } public static void main(String[] args) { MutablePeriod mp = new MutablePeriod(); Period p = mp.period; Date pEnd = mp.end; pEnd.setYear(78); System.out.println(p); pEnd.setYear(69); System.out.println(p); } // 결과 // Mon Oct 08 18:04:19 KST 2018 - Sun Oct 08 18:04:19 KST 1978 // Mon Oct 08 18:04:19 KST 2018 - Wed Oct 08 18:04:19 KST 1969 Period 역직렬화 과정에서 객체 참조가 노출됨. 방어적 복사를 readObject() 에서도 해야 한다.\n해결책2 방어적 복사 #  private void readObject(ObjectInputStream s) throws IOException, ClassNotFoundException { s.defaultReadObject(); // non-static, non-transient field 채워줌  start = new Date(start.getTime()); // start랑 end final 빼줘야 함  end = new Date(end.getTime()); if (start.compareTo(end) \u0026gt; 0) { throw new InvalidObjectException(start + \u0026#34; after \u0026#34; + end); } } java 1.4부터 위 처럼 방어적 복사 안해도 되도록 writeUnshared와 readUnshared 메소드 추가되었는데, 뒤에 나올 규칙77에 취약하므로 그냥 방어적 복사 사용할 것. readObject 에서 override 가능한 메소드 호출하지 말 것. 보장 못함.\n요약 #   readMobject 를 구현 할 때는 public 생성자 구현하듯이 해야 한다. 어떤 바이트스트림이 주어지더라도 유효한 객체가 생성될 수 있게 해야 한다. 안전한 메서드 구현은 다음 지침들을 따르자  private 로 남아야 하는 객체 참조 필드를 가진 클래스는 해당 객체를 방어적으로 복사해야 한다. 불변식을 검사해서 위반되면 InvalidObjectException을 던저야 한다. 불변식 검사는 방어적 복사 끝난 후에 실행되어야 한다. 객체 완전 역직렬화 한 다음 유효성 검사해야 한다면 ObjectInputValidation 인터페이스를 이용해라 직-간접적으로 override 가능 메소드 호출하지 말 것    // ObjectInputValidation 사용법 // readObject가 다 끝나고 return 되기 직전에 validation 해줌 interface ObjectInputValidation { public void validateObject() throws InvalidObjectException; } public class ObjectInputStreamDemo { public static void main(String[] args) { try { ObjectInputStream ois = new ObjectInputStream(new FileInputStream(\u0026#34;test.txt\u0026#34;)); Example a = (Example) ois.readObject(); } catch (Exception ex) { ex.printStackTrace(); } } static class Example implements Serializable, ObjectInputValidation { private String s = \u0026#34;Hello World!\u0026#34;; private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException { in.defaultReadObject(); in.registerValidation(this, 0); // 콜백 등록  } @Override public void validateObject() throws InvalidObjectException { if (this.s.equals(\u0026#34;Hello World!\u0026#34;)) { System.out.println(\u0026#34;Validated.\u0026#34;); } else { System.out.println(\u0026#34;Not validated.\u0026#34;); throw new InvalidObjectException(\u0026#34;Not validated.\u0026#34;); } } } } (byte) 0xac, (byte) 0xed, //STREAM_MAGIC. Specifies that this is a serialization protocol. 0x00, 0x05, // STREAM_VERSION. The serialization version. 0x73, // TC_OBJECT. Specifies that this is a new Object. 0x72, // TC_CLASSDESC. Specifies that this is a new class. 0x00, 0x06, // Length of the class name. 0x50, 0x65, 0x72, 0x69, 0x6f, 0x64, // the name of the class \u0026#39;P e r i o d\u0026#39; 0x40, 0x7e, (byte) 0xf8, 0x2b, 0x4f, 0x46, (byte) 0xc0, (byte) 0xf4, // SerialVersionUID, the serial version identifier of this class. 0x02, // Various flags. This particular flag says that the object supports serialization. 0x00, 0x02, // Number of fields in this class. 0x4c, // ?? field type 0x00, 0x03, // Length of the field name 0x65, 0x6e, 0x64, // e n d 0x74, // TC_STRING. Represents a new string. 0x00, 0x10, // Length of the string. 0x4c, 0x6a, 0x61, 0x76, 0x61, 0x2f, 0x75, 0x74, 0x69, 0x6c, 0x2f, 0x44, 0x61, 0x74, 0x65, 0x3b, // Ljava/util/Date; 0x4c, // ?? field type 0x00, 0x05, // Length of the field name 0x73, 0x74, 0x61, 0x72, 0x74, // s t a r t 0x71, // TC_REFERENCE. Reference to an object already written into the stream. 0x00, 0x7e, 0x00, 0x01, // 1번째 참조..? 0x78, // TC_ENDBLOCKDATA, the end of the optional block data for an object. 0x70, //TC_NULL, which represents the fact that there are no more superclasses because we have reached the top of the class hierarchy. 0x73, // TC_OBJECT. Specifies that this is a new Object. 0x72, // TC_CLASSDESC. Specifies that this is a new class. 0x00, 0x0e, // Length of the class name. 0x6a, 0x61, 0x76, 0x61, 0x2e, 0x75, 0x74, 0x69, 0x6c, 0x2e, 0x44, 0x61, 0x74, 0x65, // java.util.Date 0x68, 0x6a, (byte) 0x81, 0x01, 0x4b, 0x59, 0x74, 0x19, // serialVersionUID of the java.util.Date class 0x03, // Varius flags. SC_WRITE_METHOD. 0x00, 0x00, // Number of fields in this class. 0x78, // TC_ENDBLOCKDATA, the end of the optional block data for an object. 0x70, //TC_NULL, which represents the fact that there are no more superclasses because we have reached the top of the class hierarchy. 0x77, //TC_BLOCKDATA 0x08, 0x00, 0x00, 0x00, 0x66, (byte) 0xdf, 0x6e, 0x1e, 0x00, 0x78, 0x73, 0x71, 0x00, 0x7e, 0x00, 0x03, // 3번 째 참조..? 0x77, 0x08,0x00, 0x00, 0x00, (byte) 0xd5, 0x17, 0x69, 0x22, 0x00, 0x78 }; 오라클 스펙\nserialization 알고리즘 참조\n규칙77 개체 통제가 필요하다면 readResolve 대신 enum 자료형을 사용해라 #  앞서 다룬 싱글톤 패턴은 \u0026ldquo;implements Serializable\u0026rdquo; 을 붙이는 순간 깨진다.\npublic class Elvis { public static final Elvis INSTANCE = new Elvis(); private Elvis(){} }  기본 직렬화 형태, 사용자 정의 직렬화 형태 상관 없이 클래스에 명시적 readObject 있든 없든 상관 없다 모든 readObject 메서드는 새로 생성된 객체를 반환하는데 이 객체는 클래스가 초기화될 때 만들었던 객체가 아니다  readResove 통한 싱글톤 #  readResolve 는 역직렬화 끝나서 만들어진 객체에 대해 호출된다. 새로 만들어진 객체 대신 이 메서드가 반환하는 객체가 사용자에게 간다.\npublic class Elvis { public static final Elvis INSTANCE = new Elvis(); private Elvis(){} private Object readResolve() { return INSTANCE; } }  역직렬화된 객체는 무시. 싱글톤 객체 그냥 반환함 따라서 객체의 모든 필드는 transient 어야 한다 개체 통제를 위해 readResolve 쓸 때는 모든 객체 필드를 transient로 해야 한다 안 그러면 MutablePeriod 처럼 참조 가로채기 가능  비-transient 필드 통한 참조 가로채기 #  싱글톤 객체에 비-transient 필드가 있는 경우, 해당 필드의 내용은 객체의 readResolve가 실행되기 전에 역직렬화 되어야 한다. 따라서 이 부분을 바이트 스트림 조작을 통해 다른 객체로 갈아 끼면, 참조 필드가 역직렬화 되는 순간 원래 객체를 \u0026ldquo;훔칠 수\u0026rdquo; 있다. (원래는 참조를 잃고 GC 되어야 할\u0026hellip;)\n 먼저 도둑이 숨을 직렬화된 싱글턴 객체를 참조하는 객체 필드와 readResolve 메서드를 갖춘 도둑 클래스를 만듬 직렬화 스트림에서 싱글턴의 비-transient 필드가 참조하는 대상을 도둑 객체로 바꿔놓는다 이러면 참조 순환이 발생함(싱글턴은 도둑객체 포함, 도둑객체는 싱글턴 참조) 싱글턴이 도둑객체 포함하므로 싱글턴 역직렬화될 때 도둑 객체의 readResolve() 가 먼저 실행됨. 이 때 싱글톤 객체의 참조를 static 필드에 복사한다 그 다음 원래 대로 도둑 객체 숨겼던 원래 필드 자료형에 맞는 값을 반환한다. 안 그러면 ClassCastExecption 발생  // 잘못된 싱글톤 public class Elvis implements Serializable { public static final Elvis INSTANCE = new Elvis(); private Elvis(){} private String[] favoriteSongs = {\u0026#34;Hound Dog\u0026#34;, \u0026#34;Heartbreak Hotel\u0026#34;}; public void printFavorites() { System.out.println(Arrays.toString(favoriteSongs)); } private Object readResolve() { return INSTANCE; } } //도둑 클래스 public class ElvisStealer implements Serializable { static Elvis impersonator; private Elvis payload; private Object readResolve() { // 아직 relosve 되지 않은 Elvis 객체 저장  impersonator = payload; //favoriteSongs 필드 자료형에 맞는 객체 반환  return new String[] {\u0026#34;A Fool Such as I\u0026#34;}; } private static final long serialVersionUID = 0; } public class ElvisImpersonator { private static final byte[] serializedForm = new byte[]{ (byte) 0xac, (byte) 0xed, 0x00, 0x05, 0x73, 0x72, 0x00, 0x05, 0x45, 0x6c, 0x76, 0x69, 0x73, (byte) 0x84, (byte) 0xe6, (byte) 0x93, 0x33, (byte) 0xc3, (byte) 0xf4, (byte) 0x8b, 0x32, 0x02, 0x00, 0x01, 0x4c, 0x00, 0x0d, 0x66, 0x61, 0x76, 0x6f, 0x72, 0x69, 0x74, 0x65, 0x53, 0x6f, 0x6e, 0x67, 0x73, 0x74, 0x00, 0x12, 0x4c, 0x6a, 0x61, 0x76, 0x61, 0x2f, 0x6c, 0x61, 0x6e, 0x67, 0x2f, 0x4f, 0x62, 0x6a, 0x65, 0x63, 0x74, 0x3b, 0x78, 0x70, 0x73, 0x72, 0x00, 0x0c, 0x45, 0x6c, 0x76, 0x69, 0x73, 0x53, 0x74, 0x65, 0x61, 0x6c, 0x65, 0x72, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x01, 0x4c, 0x00, 0x07, 0x70, 0x61, 0x79, 0x6c, 0x6f, 0x61, 0x64, 0x74, 0x00, 0x07, 0x4c, 0x45, 0x6c, 0x76, 0x69, 0x73, 0x3b, 0x78, 0x70, 0x71, 0x00, 0x7e, 0x00, 0x02 }; private static Object deserialize(byte[] sf) { try { InputStream is = new ByteArrayInputStream(sf); ObjectInputStream ois = new ObjectInputStream(is); return ois.readObject(); } catch (Exception e) { throw new IllegalArgumentException(e); } } public static void main(String[] args) { // ElvisStealer.impersonator 를 초기화 하고  // 진짜 Elvis 객체를 반환 한다 (Elvis.INSTANCE)  Elvis elvis = (Elvis) deserialize(serializedForm); Elvis impersonator = ElvisStealer.impersonator; elvis.printFavorites(); impersonator.printFavorites(); } //[Hound Dog, Heartbreak Hotel]  //[A Fool Such as I] } 해결책 #  대신 직력화 가능 클래스를 enum 으로 구현하면 확실히 싱글톤 보장이 됨. JVM이 보장해주고 프로그래머는 신경 쓸 필요 없음.\npublic enum Elvis { INSTANCE; privates String[] favoriteSongs = {\u0026#34;Hound Dog\u0026#34;, \u0026#34;Heartbreak Hotel\u0026#34;}; //... } 하지만 직렬화 가능 클래스의 객체수를 컴파일 시점에서 알 수 없는 경우 enum을 통해 구현 할 수 없음. readResolve 써야함\nreadResove와 접근 권한 #   readResolve 메서드를 final 클래스에 두는 경우엔 반드시 private으로 선언해야 한다. final 클래스가 아닐 때, readResolve가 private이면 하위 클래스에는 적용되지 않는다. final 클래스가 아닐 때, readResolve가 protected나 public이면, readResolve를 재정의하지 않은 모든 하위 클래스에 적용이 될 텐데 이러면 직렬화된 하위 클래스 객체를 deserialize 하면 상위 클래스 객체가 만들어져 ClassCastException이 발생할 것이다.  요약 #   개체 수 관련 불변식 강제하고 싶으면 enum 쓰자 그런 상황이 아니면 반드시 readResolve 를 구현해야하고 모든 객체 필드는 기본 자료형이나 transient로 선언해야 한다.  규칙78 직렬화된 객체 대신 직렬화 프락시를 고려해 보라 #  직렬화를 사용하면 버그나 보안 결함 생길 가능성 높음 일반 생성자 대신 언어 외적인 매커니즘을 이용하기 때문\n이에 대안으로 직렬화 프록시 패턴이 있다.\n private static nested class (== serialization proxy)를 만든다. (outer class 객체의 논리적 상태를 간결하게 표현하는) 바깥 클래스를 인자 자료형으로 사용하는 생성자 하나 (일관성 검사 필요 없음, 방어적 복사 필요 없음) 바깥 클래스에 writeReplace 메서드 구현 proxy 클래스에 자기와 논리적으로 동일한 바깥 클래스객체 반환하는 readResolve 메서드 추가  private static class SerializationProxy implements Serializable { private final Date start; private final Date end; SerializationProxy(Period p) { this.start = p.start; this.end = p.end; } private static final long serialVersionUID = 1241142L; } 다음과 같이 바깥 클래스에 writeReplace() 구현하면 직렬화 시스템은 바깥 클래스를 직렬화된 객체 만들지 않음\nprivate Object writeReplace() { return new SerializationProxy(this); } 근데 공격자는 앞선 바이트스트림 공격처럼 만드려 시도 할 수 있다. 그걸 막으려면 readObject를 바깥 클래스에 추가하면 된다.\nprivate void readObject(ObjectInputStream stream) throws InvalidObjectException { throw new InvalidObjectException(\u0026#34;Proxy require!\u0026#34;); } 마지막으로 SerializationProxy 클래스에 readResolve를 추가. Public API만 이용하기 때문에 아름답다. (직렬화 특성 거의 제거)\nprivate Object readResolve() { return new Period(start, end); } 장점\n 방어적 복사 접근법 처럼 바이트 스트림 통한 공격 방지 내부 필드 탈취 공격도 저절로 중단 외부 클래스 필드를 final로 선언할 수 있어서 진정한 immutable class 구현 가능 직렬화 도중 유효성 검사도 필요 없음 역직렬화된 객체가 애초에 직렬화된 객체와 다른 클래스가 되도록 할 수 있음(?? 장점인가..??)  EnumSet의 경우 생성자가 없고 팩토리 메서드로 EnumSet 객체를 얻는데, 실제로는 자료형 크기가 64 이하면 RegularEnumSet, 64 보다 크면 JumboEnumSet을 반환한다. 만약 64개 원소를 갖는 enumSet 객체를 직렬화 한다음 enum 자료형에 다섯 개의 원소를 더 추가하고, 방금 직렬화한 객체를 역직렬화 하면? 처음엔 RegularEnumSet Type 이었겠지만 나중엔 JumboEnumSet Type으로 변환 될 것이다.\n// EnumSet 의 직렬화 프록시 // EnumSet\u0026#39;s serialization proxy  private static class SerializationProxy \u0026lt;E extends Enum\u0026lt;E\u0026gt;\u0026gt; implements Serializable { // The element type of this enum set.  private final Class\u0026lt;E\u0026gt; elementType; // The elements contained in this enum set.  private final Enum[] elements; SerializationProxy(EnumSet\u0026lt;E\u0026gt; set) { elementType = set.elementType; elements = set.toArray(EMPTY_ENUM_ARRAY); // (Item 43)  } private Object readResolve() { EnumSet\u0026lt;E\u0026gt; result = EnumSet.noneOf(elementType); for (Enum e : elements) result.add((E)e); return result; } private static final long serialVersionUID = 362491234563181265L; } // 팩토리 메소드 내부  public static \u0026lt;E extends Enum\u0026lt;E\u0026gt;\u0026gt; EnumSet\u0026lt;E\u0026gt; noneOf(Class\u0026lt;E\u0026gt; elementType) { Enum\u0026lt;?\u0026gt;[] universe = getUniverse(elementType); if (universe == null) throw new ClassCastException(elementType + \u0026#34; not an enum\u0026#34;); if (universe.length \u0026lt;= 64) return new RegularEnumSet\u0026lt;\u0026gt;(elementType, universe); else return new JumboEnumSet\u0026lt;\u0026gt;(elementType, universe); } 직렬화 프록시 단점 #   클라이언트가 확장할 수 있는 클래스에는 적용 불가. 객체 그래프에 순환이 있으면 사용 불가. 어떤 객체의 메서드를 해당 객체의 직렬화 프록시의 readResolve 에서 호출하면 ClassCastException 이 뜬다. 아직 실제 객체를 가진것이 아니기 때문. 직렬화 프고시는 방어적 복사 기법에 비해 비용이 더 많이 듬  요약 #   클라이언트가 확장할 수 없는 클래스에 readObject나 writeObject를 구현해야 할 때는 직렬화 프록시 패턴 도입을 고려. 단순하지 않은 불변식을 만족해야 하는 객체를 안정적으로 직렬화하는 가장 쉬운 방법  "},{"id":48,"href":"/TIL/effectivepython/pythonicthinking/item1/","title":"Effective Python","section":"Effective Python","content":"Item 1: Know Which Version of Python You\u0026rsquo;re Using #  python 은 보통 python2.7 의 alias 이다. 가끔은 더 낮은 버전을 쓰는 곳도 있다. 이를 확실히 하기 위해선 \u0026ndash;version flag를 사용한다.\n$ python --version Python 2.7.10 python3 는 보통 Python3를 사용하기위해 쓰인다.\n$ python3 --version Python 3.8.0 runtime 에서도 sys module을 통해 호출 가능하다.\nimport sys print(sys.version_info) print(sys.version) # sys.version_info(major=3, minor=6, micro=9, releaselevel=\u0026#39;final\u0026#39;, serial=0) # 3.6.9 (default, Jan 15 2020, 10:45:58) [GCC 5.4.0 20160609] 기억해야 할 것 #   Python3가 최신이고 지원되는 버전이며 앞으로 프로젝트는 이걸로 해야 한다. 당신 시스템 버전이 기대하는 버전과 맞는지 항상 확인해라 Python2는 2020 1월 부로 지원 중단된다.  "},{"id":49,"href":"/TIL/effectivepython/pythonicthinking/item2/","title":"Effective Python","section":"Effective Python","content":"Item 2: Follow the PEP 8 Style Guide #  Python Enhancement Proposal #8, 다른 말로 PEP 8 은 파이썬 코드 스타일 가이드이다. 일관된 코딩 스타일을 갖는 것은 가독성을 높인다. 프로젝트에서 다른 팀원과 스타일을 공유하는 것이 협업의 기본이다. 물론 혼자 일하더라도 이 가이드를 따르는 게 추후 유지보수 비용을 줄여준다.\nWhiteSpace #  "},{"id":50,"href":"/TIL/java/access-modifier/","title":"Java","section":"Java","content":"Access modifier #  java 에는 4개의 access modifier 가 있다.\n public () protected default(package private) private  위의 순서대로 public에 가까울 수록 제한이 적고, private에 갈수록 제한이 커진다.\n| Class | Package | Subclass | Subclass | World | | |(same pkg)|(diff pkg)| ————————————+———————+—————————+——————————+——————————+———————— public | + | + | + | + | + ————————————+———————+—————————+——————————+——————————+———————— protected | + | + | + | + | ————————————+———————+—————————+——————————+——————————+———————— default | + | + | + | | ————————————+———————+—————————+——————————+——————————+———————— private | + | | | | + : accessible blank : not accessible https://stackoverflow.com/questions/215497/in-java-difference-between-package-private-public-protected-and-private\n"},{"id":51,"href":"/TIL/java/annotation/","title":"Java","section":"Java","content":"Annotation #  @ 골뱅이를 통해서 추가 정보를 전달하는 방식을 annotation 이라고 한다. class에 대한 meta data를 저장하는 방식이다. 과거에는 XML을 통해 meta data를 많이 저장하였으나, 더 java 스러운 방식으로 현재 annotation을 표준 명세에 정의하였다. java.lang의 reflection을 통해 runtime에 annotation 에 접근할 수 있다.\n@Target() @Retention() public @interface MyAnnotation { int value(); int otherValue(); } Target 과 Retention은 annotation 을 위한 built-in annotation 이다. Target은 Type, Field, Method, Parameter, Constructor, Local variable, AnnotationType, Package, Type parameter, Type use로 할 수 있다. 즉 이 annotation을 붙이는 대상을 method로 할지, field로 할지 정하는 annotation이다. retention의 경우 Source, Class, Runtime 3가지 옵션이 있다. java 파일을 source 단계 -\u0026gt; 컴파일 후 .class 단계 -\u0026gt; JVM 위의 runtime 단계로 나눠볼 수 있는데, Source의 경우 컴파일러만 참고하고 bytecode에는 남지 않는 정보이고 @Override, Class는 컴파일 단계까지는 존재하며 runtime에서 사라지는 정보( 이것이 default 이다) 마지막으로 Runtime은 끝까지 살아남는 정보들이다. RUNTIME의 경우 reflection 을 통해 값을 runtime에 확인할 수 있다.\n"},{"id":52,"href":"/TIL/java/atomic-volatile-synchronized/","title":"Java","section":"Java","content":"atomic volatile synchronized #  Atomic #  java 는 java.concurrent.atomic Class 가 있다. Lock이나 synchronized keyword가 없어도 병렬 수행의 안전성이 하드웨어에 의해 보장된다. 내부적으로 CAS(compare-and-swap) 을 활용한다. 한 method 인 incrementAndGet을 보면 다음과 같다.(JDK 7 기준)\npublic final long incrementAndGet(){ for(;;){ long current = get(); long next = current + 1; if (compareAndSet(current, next)) reutrn next; } } get() 으로 현재 val을 가져오고, 2줄 아래 if 문에서 다시 memory의 값과 비교하여서 변동이 없으면 next value를 set하고, 변동이 있다면 다시 for문을 도는 형태이다. compareAndSet은 hardware 적으로 atomic을 보장한 native(assembly) 연산이다. 즉 lock을 사용하지 않고,다른 thread에 의한 변동이 없을 때까지 for 문을 도는 형태이다.\n대표적으로 AtomicInteger, AtomicBoolean, AtomicLong, AtomicReference 가 있다. JDK 8 에서는 LongAdder, LongAccumulator 등 이 추가되었다.\nvolatile #  volatile은 변수의 가시성(visibility)를 보장한다. 변수들은 Main memory 또는 CPU의 cache에 저장되는데, 멀티 쓰레딩 환경에서 해당 변수의 최신값이 다른 cpu에 있을 지, main memory에 있을지 보장할 수 없다. 따라서 volatile 키워드는 main memory에 값이 써지는 것을 보장합니다. 또 volatile 변수의 읽기 쓰기 연산은 JVM에 의해 재배치 되지 않는다.(????)\nsynchronized #  monitorlock 이나 intrinsic lock .. 재진입 가능한 락이다. 같은 락을 한 thread에서 여러번 얻을 수 있음.\n"},{"id":53,"href":"/TIL/java/class-loader/","title":"Java","section":"Java","content":"Class loader #  다음과 같은 test code를 돌려보자\npublic void printClassLoaders() throws ClassNotFoundException { System.out.println(\u0026#34;Classloader of this class:\u0026#34; + PrintClassLoader.class.getClassLoader()); System.out.println(\u0026#34;Classloader of Logging:\u0026#34; + Logging.class.getClassLoader()); System.out.println(\u0026#34;Classloader of ArrayList:\u0026#34; + ArrayList.class.getClassLoader()); // result  // Class loader of this class:sun.misc.Launcher$AppClassLoader@18b4aac2  // Class loader of Logging:sun.misc.Launcher$ExtClassLoader@3caeaf62  // Class loader of ArrayList:null }  Bootstrap class loader (c로 구현) jvm 구동 시킬 때 작동함 getClassLoader() 시에 null 로 나옴 Extension class loader Application class loader (system class loader)  java 에서 class 들은 java.lang.ClassLoader의 instance에 의해 loading 된다. 그런데 class loader 또한 class 이다. 그럼 class loader는 누가 load 할까? 바로 bootstrap class loader 이다. 이 것은 rt.jar나 $JAVA_HOME/jre/lib 에 있는 core library를 loading 할 책임이 있다.또한 다른 class loader의 부모의 역할도 한다. bootstrap loader는 JVM의 core 역할을 하고, native code로 쓰여 있다.\nExtension loader는 bootstrap loader의 child이며 core java class의 extension 들을 loading 하는 역할을 한다. $JAVA_HOME/lib/ext 에 있거나 java.ext.dirs system property에 등록된 것들을 이 loader가 loading 한다.\napplication level class는 application class loader가 관리한다. java.class.path property의 경로에서 clss를 찾는다. -classpath 나 -cp 옵션으로 주어지는 classpath에서 찾는 모든 file을 load한다. 또한 Extension loader의 child 이다.\nclass-loader의 동작을 살펴보자.\ndelegation principle\n java.lang.ClassLoader.loadClass() method는 runtime에 class definition을 loading 책임이 있다.\n 1. 이미 loading 되어 있는지 확인하고(``findLoadedClass(name)``) 2. loading 안 됐으면 부모 loader에게 위임한다. (``parent.loadClass(name, false)`` or ```findBootstrapClassOrNull(name)`) 3. recursive하게 부모의 부모에게 가는데, 부모에게 서 찾을 수 없으면 자기 자신의 classpath에서 찾아 본다.(``finClass(name)``)  찾지 못할 경우 ClassNotFoundException을 뱉어낸다.\nvisibility principle\n Child classloader는 부모 classloader가 load한 class를 볼 수 있지만, 반대는 안 된다.\n uniqueness principle\n 부모 class loader가 load한 class는 자식 class loader가 load 하면 안된다.\n 코너 케이스로 JNDI의 경우 core class 는 bootstrap loader 에 의해 load 되지만, 이 core class들이 JNDI provider 를 load 해야 할 수 있습니다. JNDI provider는 보통 classpath에 등록되어 application class loader의 담당이므로 부모 loader가 자식 class loader에서 class를 찾아야 합니다. 일반적인 delegation model로는 풀 수 없으며 이 경우 thread context loader를 이용하여 hierachy 를 tunneling 합니다.\nCustom class loader\n추가 조사 할 것 #   defineClass findClass loadClass  동 메소드.. sync or pararell class load\n"},{"id":54,"href":"/TIL/java/collection/","title":"Java","section":"Java","content":"java.util.Collection #    List 중복 허용\n  Set, SortedSet, NavigableSet 중복 불가\n  Queue, Deque concurrency 위해서..\n  Map, SortedMap, NavigableMap\n  equals/hashCode Iterator(한 방향)/ListIterator(양 방향) Collections class(cf. Arrays class) Vector, Hashable, Enumeration =\u0026gt; legacy! 쓰지마셍\u0026hellip; Wrappers: unmodifiable, synchronized, checked\njava.util.concurrent #   BlockingQueue   모든 큐 기반 동시 콜렉션의 기본에있는 인터페이스. BlockingQueue에 요소를 추가하는 동안, 공간이 없으면 사용 가능하게 될 때까지 기다릴 수 있고 검색 할 때 요소가 비어있을 때까지 사용할 수있을 때까지 대기합니다.\n  ArrayBlockingQueue   Array를 기반으로 한 blocking queue 입니다. 일단 인스턴스화되면 사이즈를 조정할 수 없다.\n  SynchronousQueue   용량이 9인 blocking queue입니다.\n  PriorityBlockingQueue   blocking queue에 기반한 우선순휘 큐. unbounded 입니다.\n  LinkedBlockingQueue   선택적으로 bounded 할 수 있는 queue이다.\n  DelayQueue   일정 기간이 지난 element 만 빼낼 수 있다. unbounded queue 이다.\n  BlockingDeque   blockingqueue 에 deque 의 명세가 있는 인터페이스 이다.\n  LinkedBlockingDeque   linked node로 blockingdeque 구현했다.\n  TransferQueue   producer 가 Element를 넣고 consumer가 receive 할 때 까지 기다리는 method가 있는 blocking queue.\n  LinkedTransferQueue   transferqueue 구현체.\n  ConcurrentMap   thread safety 와 atomicity 가 보장된 map interface\n  ConcurrentHashMap   concurrent map 구현체\n  ConcurrentNavigableMap   a Java concurrent collection interface that extends ConcurrentMap and adds operations of NavigableMap.\n  ConcurrentSkipListMap   ConcurrentNavigableMap 구현체.\n "},{"id":55,"href":"/TIL/java/enum/","title":"Java","section":"Java","content":"enum #  다음과 같은 enum class 가 있다고 하자.\npublic enum Season{ Spring(\u0026#34;March through May\u0026#34;), Summer(\u0026#34;Jun throuh August\u0026#34;), Fall(\u0026#34;September through November\u0026#34;), Winter(\u0026#34;Decomber through Febnruary\u0026#34;); private String span; Season(String months){ this.span = months; } public String getSpan() { return this.span; } } 이를 컴파일 할 경우\npublic final enum Season { public static final enum Season Spring; public static final enum Season Summer; public static final enum Season Fall; public static final enum Season Winter; private java.lang.String span; private static final synthetic Season[] ENUM$VALUES; static {}; private Season(java.lang.String arg0, int arg1, java.lang.String months); public static Season[] values(); public static Season valueOf(java.lang.String arg0); } 이런 코드가 나온다.\nenum은 Enum class를 상속받게 된다.\npublic abstract class Enum\u0026lt;E extends Enum\u0026lt;E\u0026gt;\u0026gt; extends Object implements Comparable\u0026lt;E\u0026gt;, Serializable 즉\npublic final class Season extends Enum\u0026lt;Season\u0026gt;{ //... } 라고 볼 수 있다. enum은 결국 final class가 되므로 상속이 불가능하고, 선언한 변수들 또한 static final이기 때문에 static{} 이 부분에서 초기화되고 수정이 불가능하다. instance가 1개로 제한되므로 오류의 경우가 줄어든다.\n참조: oracle docs\n"},{"id":56,"href":"/TIL/java/garbage-collection/","title":"Java","section":"Java","content":"garbage-collection #  reachable finalized\nlive object가 아닌 dead object를 garbage\n serial vs parallel vs cms vs G1 (찾아보자) concurrent vs stop-the-world compacting vs non-compacting vs copying (non-compacting releases object in-place and can cause fragmentation)  Collector 종류\n mark-seep-compact collector  serial 혹은 parallel. young이든 old든 짦고 긴 STW pause가 필요   mark \u0026amp; sweep collector : pause time이 짧다  CMS(Concurrent Mark \u0026amp; Sweep) collector는 compaction을 하지 않는다. fagmentation 이슈가 발생   G1 collector  CMS와 유사하지만 대부분 reclaimable한 region들에 대해서 compaction 수행    "},{"id":57,"href":"/TIL/java/jvm-option/","title":"Java","section":"Java","content":"JVM options #  class load log 보기 -verbose:class\ndirect momory 최대 크기 지정 VM -XX:MaxDirectMemorySize=\u0026lt;size\u0026gt;\n"},{"id":58,"href":"/TIL/java/lambda/","title":"Java","section":"Java","content":"Lambda Expression #  Java 8 부터 람다 표현식을 지원한다. 핵심은 지울 수 있는 건 다 지우고 컴파일러에게 맡기자! 이다.\ninterface Flyable void fly() class Bird implements Flyable{ @Override public void fly(){ System.out.println(\u0026#34;I believe I can fly\u0026#34;); } } Flyable fly = new Flyable(){ @Override public void fly(){ System.out.println(\u0026#34;I believe I can fly\u0026#34;); } } Flyable 이라는 interface를 구현한다고 해보자. 이를 구현한 Bird라는 클래스를 만드는게 일반 방법이고, 재사용성이 없다면 아래 방식으로 익명 inner class를 활용할 수도 있다. 그런데 단순히 method 하나 사용하려고 객체를 새로 생성하고 Override 해주는 게 귀찮게 느껴진다. 위의 코드는 다음과 같이 수정할 수 있다.\nFlyable fly = () -\u0026gt; System.out.println(\u0026#34;I believe I can fly\u0026#34;);  이미 변수 선언에서 Type을 알고 있으므로 new 를 할 필요가 없다. 구현하려는 method가 1개 이므로 이름 없어도 된다. method를 알고 있으니까 parameter 도 간소화 할 수 있다.  FunctionalInterface #  java는 method를 1급객체로 취급하지 않기 때문에 다른 언어들 처럼 바로 lambda를 사용하지는 못한다. 구현해야할 method가 1개인 functional interface를 사용하여 hint를 주게 된다.\n@FunctionalInterface interface Flyable{ void fly() } 이는 인터페이스에 method가 1개 가 아니면 컴파일 에러를 발생시켜 오류를 줄여준다. 또한 실제 class를 만드는 것이 아니기 때문에 메모리 부담이 줄어든다(익명 inner class의 경우 class를 만드는 것이기 때문에 메모리 부담 가중)\njava built-in functional interface #   Runnable  thread 생성할 때 보통 사용하는 interface 이다. void 타입의 parameter 또한 없다.\n Supplier\u0026lt;T\u0026gt;  인자는 받지 않고, T type을 리턴한다. 순수함수는 input parameter에만 영향을 받으므로 항상 같은 값을 리턴한다.\n Consumer\u0026lt;T\u0026gt;  void type 이며 T를 인풋 parameter로 받는다.\n Function\u0026lt;T, R\u0026gt;  하나의 인자와 리턴타입을 갖는다.\n Predicate\u0026lt;T\u0026gt;  하나의 인자를 받고 리턴 타입은 boolean으로 고정이다.\n UnaryOperator\u0026lt;T\u0026gt;  인자와 리턴 타입이 같다.\n BinaryOperator\u0026lt;T\u0026gt;  동일한 타입의 인자 2개를 받아서 역시 동일한 타입으로 리턴한다.\n BiPredicate\u0026lt;T, U\u0026gt;  인자 2개를 받아서 boolean으로 리턴한다.\n BiConsumer\u0026lt;T, U\u0026gt;  인자 2개를 받는 void 타입\n BiFunction\u0026lt;T, U, R\u0026gt;  인자 2개를 받고 리턴한다.\n Comparator\u0026lt;T\u0026gt;  자바 전통적인 인터페이스로 객체간 비교 때 사용된다.\n Callable\u0026lt;T\u0026gt;  runnable에 대응되는 interface로 Future 객체를 사용할 때 사용된다.\n참조사이트\nclousure #  자유 변수! unbound variable, free variable\ncurrying #  argument가 1개인 anonymous function이 multi arg를 지원하는가\nMixin #  다른 class의 method를 가지고 있는 class. 상속 외에 다른 방식으로 reuse 함. 이를 java 에서 받기 위해 default 생김.\nDefault Method #  provides a default impl for any class that implements the interface without overriding the method. 기존 interface 수정하지 않고 새로운 기능성 구현. 다중상속처럼 구현됨 다만 state(멤버 변수) 를 선언할 수 없고, 오로지 동작(method) 만 가능\nJava 8 lambda #   functional interface default method streams invokeDynamic java.util.Spliterator  "},{"id":59,"href":"/TIL/java/loading-linking-initialization/","title":"Java","section":"Java","content":"loading/linking/initialization #  loading, linking 그리고 initialization은 .class 인 바이트 코드가 jvm으로 불리면서 시작하는 초기 프로세스 이다. (instantiation, GC, finalization은 중간 단계이고 unloading 을 끝 프로세스라고 볼 수 있다)\n loading  이 단계 에서는 특정 이름을 가진 클래스나 인터페이스의 .class 파일을 찾고 이 것을 해석하여 JVM 내부 데이터 구조에 맞게 바꿉니다. class loader 가 이러한 역할을 수행한다. class loader는 기본적으로 .class 파일들을 cache하기 때문에 한 번만 load하면 됩니다. 요약하면 loading 단계에서는 다음과 같은 3가지 일을 합니다.\n Create a binary stream of data from the class file Parse the binary data according to the internal data structure Create an instance of java.lang.Class   linking  링킹에서는 class나 interface를 가져와서 JVM의 run-time state와 합치는 일을 합니다. 링킹은 verification, preparation, resolution 3 단계로 구성됩니다. verification 과정에서는 semantic을 체크하고 JVM 무결성을 방해하는지 검증합니다. preparation 과정에서 JVM은 클래스 변수에 메모리를 할당하고 type에 따라 default value로 초기화 합니다. 그러나 실제 초기화(user가 define 한) 는 initialization phase 까지 실행되지는 않습니다. resolution 단계에서 JVM은 참조되는 class, interface, field 그리고 method 를 constant pool(symbolic table)에 위치 시키고 symbolic 참조에서 구체적인 값을 결정합니다.\n initialization  initialization class 나 interface의 initialization method를 실행합니다. static value나 static initializer에 정의한 값으로 class variable을 초기화합니다. 그리고 초기화가 안 됐다면 super-class를 initialization 해줍니다.\n"},{"id":60,"href":"/TIL/java/nested-class/","title":"Java","section":"Java","content":"nested-class #  class 내부에 class를 정의한 것을 nested class라고 한다.\n inner class method local inner class anonymous inner class static nested class  4 종류가 있다. 1 ~ 3 은 non-static, 4는 static class 이다.\ninner class(member inner class)의 경우 inner class를 private 로 선언하여도 outer class에서 inner에 접근이 가능하며, inner 에서도 outer의 private 멤버에 접근 가능하다.\nclass Outer{ //...  class Inner{ //...  } } LinkedList class 내의 ListItr class가 한 예이다.\nmethod-local Inner class 는 외부 class의 method에 내부 class를 정의하여 사용 한다.\nclass Outer{ //...  void my_method(){ //...  class Inner(){ void my_method2(){ //...  } } Inner in = new Inner(); in.my_method2(); } //... } anonymous Inner class는 클래스의 선언과 초기화를 동시에 하는 방식이다. class나 interface의 method를 override 할 때 보통 사용한다. Android 할 때 button eventListener 만들 때 이런 식으로 했던 것 같다.\nabstract class AnonymousInner { public abstract void mymethod(); } public class Outer_class { public static void main(String args[]) { AnonymousInner inner = new AnonymousInner() { public void mymethod() { System.out.println(\u0026#34;This is an example of anonymous inner class\u0026#34;); } }; inner.mymethod(); } } compile 과정에서 자동으로 class를 생성해주기 때문에 코드량이 많이 줄어든다.\nstatic nested class 는 outer class의 static member이다. 초기화 없이 접근할 수 있다.\npublic class Outer { static class Nested_Demo { public void my_method() { System.out.println(\u0026#34;This is my nested class\u0026#34;); } } public static void main(String args[]) { Outer.Nested_Demo nested = new Outer.Nested_Demo(); nested.my_method(); } } 이 방식은 singleton object를 만들 때 enum이나 DCL보다 간편해서 많이 쓰인다.\n참조 tutorialspoint 링크\n"},{"id":61,"href":"/TIL/java/optional/","title":"Java","section":"Java","content":"Optional API #  Java는 c나 c++에 있는 포인터를 대부분 숨겼다. 하지만 하나 못 숨긴게 있었으니 바로 null pointer 이다. null 인 변수에 접근하려고 하면 NPE(Null Pointer Exception) 이 여지없이 떨어지기 때문에 항상 방어적 코드를 작성해야 했다.\nif( val == null){ return \u0026#34;\u0026#34;; } else { return val; } val이 단순히 객체면 상관없지만, 만약 reference를 계속 따라가는 형태라면?\nObject4 obj4 = obj1.getObject2().getObject3().getObject4(); // 방어적 코드  if(obj1 != null){ if(obj1.getObject2() != null){ if(obj1.getObject2().getObject3() != null){ obj4 = obj1.getObject2().getObject3().getObject4(); } } } 이러면 각 method 호출 직전마다 null check를 해주어야 한다. 마치 js의 callback 지옥과 같은 형태가 될 것이다. 조금 수정해보면\nif (obj1 != null \u0026amp;\u0026amp; obj1.getObject2() != null \u0026amp;\u0026amp; obj1.getObject2().getObject3() != null) obj4 = obj1.getObject2().getObject3().getObject4(); 와 같이 if문 하나에서 다 체크 할 수 있다. 헬퍼 메소드를 활용한다면\nprivate boolean isValidObject(Obj1 obj1){ return obj1 != null \u0026amp;\u0026amp; obj1.getObject2() != null \u0026amp;\u0026amp; obj1.getObject2().getObject3() != null; } if (isValidObject(obj1)) obj4 = obj1.getObject2().getObject3().getObject4(); 와 같이 만들 수 있다.\noptional #  optional은 object를 감싼 wrapping 객체이다. 그래서 외부에서 null 체크를 보이지 않게 한다. 위의 코드를 바꿔보면\nOptional\u0026lt;Obj1\u0026gt; op = Optional.ofNullable(obj1); Obj4 obj4 = op.map(Object1::getObject2).map(Object2::getObject3).map(Object3::getObject4).orElse(null) 와 같이 짤 수 있다. get을 3번 실행하는데 그 중 npe가 발생하면 orElse가 실행되어 null value로 obj4를 채워준다.\n"},{"id":62,"href":"/TIL/java/static-initializer/","title":"Java","section":"Java","content":"initializer #  enum을 조사하던 중 enum class를 컴파일 하면 static {}; block이 static 내부에 생기는 것을 발견하였다.\npublic class Abc{ static { // static initializer  } { // instance initializer  } Abc(){ // constructor  } } class 에서 크게 3가지의 초기화 method를 생각할 수 있다. constructor, static initializer, instance initializer 이다. static initializer는 class가 불리는 시점 즉 class loader에서 불릴 때 호출 되는 method 이다. Final static 변수를 초기화 해줄 때 로직이 필요하다면 여기서 해주어야 한다.\ninstance initializer의 경우 생성자와 비슷한데, 컴파일 과정에서 생성자 앞쪽으로 자동으로 복사가 된다. 여러 생성자가 있을 때 공통되는 로직을 instance initializer로 해놓을 경우 코드 중복을 막을 수 있다. 3가지 rule이 있는데\n instance initializer는 instance 생성 시에 실행 super(); 뒤에 실행 { } 이 여러 개가 있다면 차례 대로 실행  이다.\n"},{"id":63,"href":"/TIL/java/streamio/","title":"Java","section":"Java","content":"Stream IO #  java.io package 에 선언되어 있다.\n  ByteStream 은 말 그대로 Byte 단위의 입출력을 담당한다. InputStream/OutputStream\n  CharacterStream 은 Java char, 2Byte 단위로 작동한다.\n  Reader/Writer 가 두 Stream 간의 interface 역할을 한다.\nByteStream -\u0026gt; CharacterStream 해주는게 InputStreamReader CharacterStream -\u0026gt; ByteStream 해주는게 OutputStreamWriter\nNIO #  stream IO 는 non-blocking IO가 없다. 다 blocking임. 대용량 처리 같은 거할 때 critical 하다. 그래서 java.nio package 사용. stream이 아니라 buffer 기본으로 사용.\nChannel 사용 (FileChannel, SocektChannel) Selector (epoll 로 구현) Multiplexing/Nonblocking 에 유리\nNIO Direct Buffer\n ByteBuffer.allocateDirect java heap에 할당하지 않고 그냥 malloc 호출 내부적으로 요청한 크기만큼 할당  "},{"id":64,"href":"/TIL/java/streams/","title":"Java","section":"Java","content":"Stream #  stream은 java의 자료구조(List, Map, Set \u0026hellip;) 들을 선언적으로 다룬다. 자료 구조들은 util.collection에 대부분 있는데, stream과 collection의 차이는 collection의 경우 자료 구조의 구현체이고, stream은 collection 들이 보관하고 있는 data를 다루는 API 라는 것이다.\n예를 들어 String List에서 h로 시작하는 문자열만 뽑아낸다고 하자. 기존 방식은 List 에서 1개 씩 get을 해온 후 문자열 체크를 할 것이다.\nfor (String str: inputList){ if(str.startWith(\u0026#34;h\u0026#34;)){ outputList.add(str); } } 대략 위와 같은 코드가 된다. collection은 data의 추가, 삭제, 순회 API만 제공하기 때문에 나머지를 직접 구현해야 한다.\n반면 Stream 을 사용하면 다음과 같이 구현할 수 있다.\nList\u0026lt;String\u0026gt; outputList = inputList.stream() .filter(str -\u0026gt; str.startWith(\u0026#34;h\u0026#34;)) .collect(Collectors.toList()); stream 은\n source : collection, array, generator, ftn, IO, intermediate op : filter, map, terminal op : forEach, reduce, sum,  로 구성되어 있다.\nAPI 몇 가지를 보면\n//중간연산 Stream\u0026lt;R\u0026gt; map(Function\u0026lt;A, R\u0026gt;) Stream\u0026lt;T\u0026gt; filter(Predicate\u0026lt;T\u0026gt;) Stream\u0026lt;T\u0026gt; peek(Consumer\u0026lt;T\u0026gt;) //최종연산 R collect(Collector) void forEach(Consumer\u0026lt;T\u0026gt;) Optional\u0026lt;T\u0026gt; reduce(BinaryOperator\u0026lt;T\u0026gt;) boolean allMatch(Predicate\u0026lt;T\u0026gt;) boolean anyMath(Predicate\u0026lt;T\u0026gt;) 등이 있다.\n"},{"id":65,"href":"/TIL/java/thread/","title":"Java","section":"Java","content":"Thread #  기본적으로 main thread 존재(java launcher에 의해 실행되는 사용자 thread. public static void miain(String[]) 실행)\n시작 creator thread에서 start() 호출하면 새로 thread 만들어서 해당 thread에서 run() 실행\n종료 run() method가 종료되면 thread가 종료\n다른 방식으로 thread를 제어하는 method는 모두 금지\n stop() destroy() suspend() resume()  why? 쓰레드가 임의의 lock을 잡은 상태에서 stop하거나 suspend 했을 때 답이 없다. JVM이 오버헤드가 너무 커진다.\n남은 방법은 interrupt를 해당 thread에 notification 하는 것 뿐. 사용자 코드에서 flag를 활용하여 직접 종료/일시중지/재개 등을 구현해야 한다.\njava interrupt는 Object.wait(), Thread.sleep(), Thread.join() 을 깨울 수 있다. InterruptedException이 발생하면서 해당 thread의 interrupted flag가 clear 된다. (thread는 내부적으로 interrupted 당했는지 알고 있다) 다른 blocking operation 진행 중이었다면 interrupted flag가 set 된다. interruptible channel은 interrupt 되면 바로 종료하면서 ClosedByInterruptedException을 리턴하지만, 그렇지 않으면 계속 block 되어 있다.(flag만 set 되고)\n 주의사항 : thread 에서 loop를 돌면 매번 flag를 체크해서 interrupted를 체크해야 한다.\n interrupt 상태 체크\n public static boolean interrupted(); 현재 쓰레드의 interrupted flag를 알려주고 reset public boolean isInterrupted(); Thread 객체가 가리키는 thread의 현재 interrupted flag를 알려줌  Thread의 상태\n NEW (start 호출 전) RUNNABLE (run 실행 상태) BLOCKED (synchronized lock을 기다리는 상태) WAITING (Object.join, Thread.join, LockSupport.park 를 실행 중인 상태) TIMED_WAITING (time 인자를 줘서 wait, join, park를 실행하였거나 thread.sleep 인 상태) TERMINATED (thread가 종료한 상태)  ContextClassLoader thread 별로 특별한 의미를 가진 classLoader를 지정함 쓰레드를 만들 때 creator thread로 부터 copy(상속) 받음 main thread의 context classloader는 null thread pool 을 고려한 api\nLock and Conditions monitor 객체: lock \u0026amp;n unlock의 대상 wait으로 기다리고, notify로 wait하고 있는 놈 중 하나를 깨운다.\n interrupt 발생한 경우 notify 받는 경우 wait_timeout 발생시 spurious wakeup  Spurious wakeup notify가 없어도 wait이 깨어날 수 있다\u0026hellip; 이 것을 대비해서 코드를 짜야한다.\nHotspot JVM에서 lock 구현 2-word object header(array는 3word) 1st word: mark word (unsed by sync, gc, cache and hashCode)\npark, unpark 1bit의 state 갖는다. 알 필요가 있는가..?\nJava memory model\n Atomicity  java long과 double 제외한 모든 data field 에 대한 update는 atomic volatile 로 선언되면 모든 field가 atomic   Visibility  한 쓰레드에서 이루어진 data field update를 다른 쓰레드에서 보는 걸 보장하려면 두 쓰레드가 lock 공유하거나 해당 필드가 volatile로 선언되거나 읽는 쓰레드가 해당 필드를 처음 접근할 때 thread가 종료될 때는 flush 되므로 join을 통해 기다리는 thread는 종료 thread의 write를 모두 읽을 수 있다.   Ordering  lock 혹은 volatile을 제외하면 컴파일러에 의한 어떤 reordering도 가능    volatile Volatile 필드에 접근하는 서로 다른 쓰레드들 간에 happens-before 관계가 성립해야함\n volatile 필드에 write하면 해당 쓰레드의 모든 변수들을 flush하는 효과가 있어야 함 volatile 필드에 read할 때에도 cache 값이 invalidate 되어야 함  "},{"id":66,"href":"/TIL/java/threads-executors/","title":"Java","section":"Java","content":"Thread Excecutor #  Executor는 thread 생성 및 관리를 해주는 클래스이다. thread 를 직접 생성 하고 제어 하는 데에서 나올 수 있는 복잡성을 줄여준다. Executors 라는 Factory class 를 활용하거나 또는 직접 생성해줄 수도 있다.\nExecutorService executor = Executors.newFixedThreadPool(10); // by Executors  ExecutorService executor = new ThreadPoolExecutor(1, 1, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue\u0026lt;Runnable\u0026gt;()); // directly ExecutorService 는 interface 이다.\n newFixedThreadPool : 고정된 갯수의 thread를 유지하는 executor이다. newSingleThreadExecutor : 1개의 thread만 유지하는 executor이다. newCachedThreadPool : thread 를 적당한 시간 동안만 cache 하는 executor이다. newScheduledThreadPool : 일정 기간이나, 주기적으로 작업하는 thread pool 을 생성한다. newSingleThreadScheduledExecutor : thread가 1개인 scheduledThreadPool 이다.  Runnable #  ExecutorService 에서 thread 들이 할 일을 queue에 넣는다. 이 일을 Runnable 또는 Callable interface 로 만들 수 있다.\nRunnable runnableTask = () -\u0026gt; { try { TimeUnit.MILLISECONDS.sleep(1000); } catch (InterruptedExecption e) { e.printStackTrace(); } }; Callable\u0026lt;String\u0026gt; callableTask = () -\u0026gt; { TimeUnit.MILLISECONDS.sleep(1000); return \u0026#34;Task\u0026#39;s execution\u0026#34;; } ExecutorService의 API를 살펴보면\n execute() submit() invokeAny() invokeAll()  등이 있다. execute 는 void 타입으로, task가 실행 중인지 끝났는지 확인 할 방법이 없다. submit 은 Callable 이나 Runnable task 를 받아서 Future type을 return 한다. 이 Future을 통해 진행 상황을 알 수 있다. invokeAny 와 invokeAll 의 경우 Collection\u0026lt;Callable\u0026gt; 를 input으로 받아서 any의 경우 아무거나 1개의 return 값을 return 해주고 all은 모든 callable의 future를 return 해준다.\nShutdown Executor #  Executorservice는 기본적으로 GC되지 않는다. 그래서 필요할 때는 명시적으로 destory 해야 한다. shutdown 과 shutdownNow 가 있는데, 둘 다 바로 thread가 꺼짐을 보장하지는 않는다. 따라서 다음과 같은 방법을 추천한다.\nexecutorService.shutdown(); try { if (!executorService.awaitTermination(800, TimeUnit.MILLISECONDS)) { executorService.shutdownNow(); } } catch (InterruptedException e) { executorService.shutdownNow(); } Future interface #  "},{"id":67,"href":"/TIL/js/babel/","title":"JavaScript","section":"JavaScript","content":"babel 은 es6/es7 를 es5로 트랜스컴파일 하기 위한 도구입니다. babel\n babel-cli babel-core babel-polyfill  로 구성되어 있다.\n"},{"id":68,"href":"/TIL/js/ecmascript/","title":"JavaScript","section":"JavaScript","content":"Constants #   Constants  Scoping #   Block-Scoped Variables Block-Scoped Functions  Arrow Functions #   Expression Bodies Statement Bodies Lexical this  Extended Parameter Handling #   Default Parameter Values Rest Parameter Spread Operator  Template Literals #   String Interpolation Custom Interpolation Raw String Access  Extended Literals #   Binary \u0026amp; Octal Literal Unicode String \u0026amp; RegExp Literal  Enhanced Regular Expression #   Regular Expression Sticky Matching  Enhanced Object Properties #   Property Shorthand Computed Property Names Method Properties  Destructuring Assignment #   Array Matching Object Matching, Shorthand Notation Object Matching, Deep Matching Object And Array Matching, Default Values Parameter Context Matching Fail-Soft Destructuring  Modules #   Value Export/Import Default \u0026amp; Wildcard  Classes #   Class Definition Class Inheritance Class Inheritance, From Expressions Base Class Access Static Members Getter/Setter  Symbol Type #   Symbol Type Global Symbols  Iterators #   Iterator \u0026amp; For-Of Operator Generators Generator Function, Iterator Protocol Generator Function, Direct Use Generator Matching Generator Control-Flow Generator Methods  Map/Set \u0026amp; WeakMap/WeakSet #   Set Data-Structure Map Data-Structure Weak-Link Data-Structures  Typed Arrays #   Typed Arrays  New Built-In Methods #   Object Property Assignment Array Element Finding String Repeating String Searching Number Type Checking Number Safety Checking Number Comparison Number Truncation Number Sign Determination  Promises #   Promise Usage Promise Combination  Meta-Programming #   Proxying Reflection  Internationalization \u0026amp; Localization #   Collation Number Formatting Currency Formatting Date/Time Formatting  "},{"id":69,"href":"/TIL/js/webpack-babel-config/","title":"JavaScript","section":"JavaScript","content":"Webpack-Babel-Config #  Webpack is modular manager for js. Babel is transcompiler for ES+.These two library can join!We should check 3 files. package.json webpack.config.js .babelrc\n{ \u0026#34;author\u0026#34;: \u0026#34;sangmoon\u0026#34;, \u0026#34;license\u0026#34;: \u0026#34;ISC\u0026#34;, \u0026#34;devDependencies\u0026#34;: { \u0026#34;babel-core\u0026#34;: \u0026#34;^6.26.0\u0026#34;, \u0026#34;babel-loader\u0026#34;: \u0026#34;^7.1.2\u0026#34;, \u0026#34;babel-plugin-transform-async-to-generator\u0026#34;: \u0026#34;^6.24.1\u0026#34;, \u0026#34;babel-polyfill\u0026#34;: \u0026#34;^6.26.0\u0026#34;, \u0026#34;babel-preset-es2015\u0026#34;: \u0026#34;^6.24.1\u0026#34;, \u0026#34;webpack\u0026#34;: \u0026#34;^3.10.0\u0026#34;, \u0026#34;webpack-dev-server\u0026#34;: \u0026#34;^2.11.1\u0026#34; }, \u0026#34;babel\u0026#34;: { \u0026#34;presets\u0026#34;: [ \u0026#34;es2015\u0026#34; ] } } var path = require(\u0026#39;path\u0026#39;); module.exports = { //....  module:{ rules: [ { test: /\\.js$/, exclude: /(node_modules)/, loader: \u0026#39;babel-loader\u0026#39;, } ] }, resolve: { modules:[\u0026#39;node_modules\u0026#39;], extensions: [\u0026#39;.js\u0026#39;, \u0026#39;.json\u0026#39;, \u0026#39;.css\u0026#39;] }, devServer: { port: 8000 }, // 애플리케이션의타겟 환경  target: \u0026#39;web\u0026#39; }; { \u0026#34;presets\u0026#34;: [\u0026#34;es2015\u0026#34;], \u0026#34;plugins\u0026#34;: [\u0026#34;transform-async-to-generator\u0026#34;] } Through this setting, you can use webpack-babel collaboration!\n"},{"id":70,"href":"/TIL/linux/network-setting/","title":"Linux","section":"Linux","content":"/etc/network/interfaces를 수정하도록 한다.\nsudo vi /etc/network/interfaces # This file describes the network interfaces available on your system  # and how to activate them. For more information, see interfaces(5).  # The loopback network interface  auto lo iface lo inet loopback # The primary network interface  # auto eth0  # iface eth0 inet dhcp  # menual  auto eth0 iface eth0 inet static address 192.168.0.20 netmask 255.255.255.0 network 192.168.0.0 broadcast 192.168.0.255 gateway 192.168.0.1 dns-nameservers 168.126.63.1 168.126.63.2 8.8.8.8 이런 식으로 설정하면 된다.\n"},{"id":71,"href":"/TIL/linux/permission/","title":"Linux","section":"Linux","content":"unix file permission #  3 가지 permission 종류가 있다.\n r - read w - write x - execute  그리고 file 일 때와 directory 일 때 다른 의미를 갖는다. File\n read - you can open, read and copy the file. write - you can modify the file. execute - you can execute the file if it\u0026rsquo;s executable.  directory\n read - you can ls the directory and see the contents. write - you can make and removes files in the directory. execute - you can cd into that directory.  ls -l 을 하면 파일의 permission을 볼 수 있다. 총 10개의 구분자로 되어 있다. [- \u0026mdash; \u0026mdash; \u0026mdash; ] [owner] [group] 맨 앞은 directory인지 구분. 다음 3개씩의 구분은 rwx 를 표현하는 3 쌍이다. 맨 처음은 owner의 권한, 그 다음은 group에 대한 권한, 마지막은 나머지 모두에 대한 권한이다.\n권한을 바꾸고 싶을 경우 chmod 키워드를 사용한다.\n read : 4 write: 2 execute: 1 의 값으로 계산해서 더한 것을 권한으로 한다. 즉  chmod 777 /myfolder 라는 명령어는 myfolder에 owner, group에 상관없이 모든 권한을 주겠다는 뜻이다.\n"},{"id":72,"href":"/TIL/linux/ubuntu-env-setting/","title":"Linux","section":"Linux","content":" /etc/environment  시스템 단계에서 설정하는 파일\n모든 유저들에게 적용됨\n왠만하면 건들지 말자.\n~/.profile  각 사용자마다 개별적으로 가지고있는 스크립트 파일\n/etc/profile 아니면 /etc/profile.d/*.sh  ~/.profile과 유사하지만 전역 스크립트.\n이게 먼저 실행되고 개별 ~/.profile이 실행된다.\n( /etc/profile이 /etc/profile.d/ 안에 있는 모든 *.sh 스크립트들을 실행시킴)\n"},{"id":73,"href":"/TIL/mysql/mysql-user-privileges/","title":"Mysql","section":"Mysql","content":"2018/01/29\n이번에 컴퓨터 ip 변경으로 인해 새로운 작업 환경을 구축하던 중 mysql connection이 튕겨서 문제 발생. select user, host from mysql.users 를 통해 보니 user name과 host가 구분되어 있어 host ip가 달라지면 접속이 안되는 현상임을 알았다. 기존 유저에 변경하려다가 잘 안되서 그냥 현재 ip에 새로운 유저를 등록하고 권한을 주기로 함.\nmysql -u root -p mysql\u0026gt; CREATE USER \u0026#39;username\u0026#39;@\u0026#39;host\u0026#39; IDENTIFIED BY \u0026#39;password\u0026#39;; -\u0026gt; GRANT ALL PRIVILEGES ON *.* TO \u0026#39;username\u0026#39;@\u0026#39;host\u0026#39; WITH GRANT OPTION; 참조 stackoverflow\n"},{"id":74,"href":"/TIL/os/write-through-vs-write-back/","title":"OS","section":"OS","content":"2018/01/18\nOS에서 Cache 정책\n읽기 정책은 둘다 같다. 가장 가까운 캐시에 있으면 hit, 없으면 miss로 아래 단계 cache 또는 memory에 접근하여 hit 할 때 까지 반복한다.\n쓰기의 경우 다음 2가지 정책이 존재한다.\n write-through cache에 write 하고, 다음 cache에 또 write하고 .. 메모리까지 한번에 write한다.  장점은 로직이 매우 단순하다. 반면 write 작업의 overhead가 커진다. 같은 메모리를 지속적으로 변경하는 작업을 수행한다면,\n모든 level의 cache,memory를 write해야하기 때문에 불필요한 자원소모가 생긴다.\nwrite-back 우선 cache에 write를 하고, dirty bit를 assgin한다. 하위 계층으로 넘어가지 않는다.  그리고 dirty bit이 할당된 cache block을 cache에서 제거해야 할 때, 그 때 하위 계층으로 write 작업을 진행한다.\n단점은 로직이 상대적으로 복잡하다. dirty bit를 고려해야 하며 data가 통일되지 않은 state가 오래 존재하기 때문에 이를 생각해야한다.\n또한 멀티 코어의 경우 다른 코어에서는 코어 내부의 cache가 unvisible 하기 때문에 이를 관리하는 장치가 필요하다.\n장점으로는 write 오버헤드가 낮아서 성능상 이득이 있다.\n"},{"id":75,"href":"/TIL/spring/aop/","title":"Spring","section":"Spring","content":"AOP #   개발의 핵심적인 비즈니스 로직을 개발하는 데에만 집중하고, 나머지 부가적인 기능은 설정을 통해서 조정하라\n 관련 용어 #   Aspect: 공통 관심사에 대한 추상적 명칭. 로깅이나 보안, 트랜잭션 같은 기능 자체 Advice: 실제로 Aspect를 구현한 객체 Join points: Advice를 적용할 수 있는 대상. Spring에서는 각 객체의 method Pointcuts: 여러 메소드 중 실제 Adivce가 적용될 대상 메소드 target: pointcuts을 갖는 객체 Proxy: Advice가 적용될 때 만들어지는 객체 Introduction: target엔느 없는 새로운 메소드나 인스턴스 변수를 추가하는 기능 Weaving: Advicd와 target이 결합하여 프록시 객체를 만드는 과정  Advice의 종류 #   Before Advice: target의 메소드 호출 전에 사용 After returning: target의 메소두 호출 이후에 적용 After throwing: target의 예외 발생 후 적용 After: target의 메소드 호출 후 예외발생에 관계없이 적용 Around: target의 메소드 호출 이전 이후 모두 적용  "},{"id":76,"href":"/TIL/spring/file-upload/","title":"Spring","section":"Spring","content":"spring에서 파일 업로드는 2가지 방식을 택할 수 있다\n HTML FORM 사용하기 다음과 같은 형식으로 파일 업로드를 실행 할 수 있다.  \u0026lt;form action=\u0026#34;uploadfile\u0026#34; method=\u0026#34;post\u0026#34; enctype=\u0026#34;multipart/form-data\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;file\u0026#34; name=\u0026#34;file\u0026#34;\u0026gt;\u0026lt;input type=\u0026#34;submit\u0026#34;\u0026gt; \u0026lt;/form\u0026gt; ajax 사용하기 drag-drop을 구현하려면 ajax를 이용한다. 우선 기본적으로 브라우저에 image를 드래그 하면 창으로 보여주기 때문에 이를 preventDefault 함수로 막는다  \u0026lt;script\u0026gt; $(\u0026#34;.fileDrop\u0026#34;).on(\u0026#34;dragenter dragdover\u0026#34;, function(e){ e.preventDefault() }) $(\u0026#34;.fileDrop\u0026#34;).on(\u0026#34;drop\u0026#34;, function(e){ e.preventDefault() }) \u0026lt;/script\u0026gt; "},{"id":77,"href":"/TIL/spring/korean-encoding/","title":"Spring","section":"Spring","content":"다음과 같은 내용을 web.xml에 추가한다.\n\u0026lt;filter\u0026gt; \u0026lt;filter-name\u0026gt;encoding\u0026lt;/filter-name\u0026gt; \u0026lt;filter-class\u0026gt;org.springframework.web.filter.CharacterEncodingFilter\u0026lt;/filter-class\u0026gt; \u0026lt;init-param\u0026gt; \u0026lt;param-name\u0026gt;encoding\u0026lt;/param-name\u0026gt; \u0026lt;param-value\u0026gt;UTF-8\u0026lt;/param-value\u0026gt; \u0026lt;/init-param\u0026gt; \u0026lt;/filter\u0026gt; \u0026lt;filter-mapping\u0026gt; \u0026lt;filter-name\u0026gt;encoding\u0026lt;/filter-name\u0026gt; \u0026lt;url-pattern\u0026gt;/*\u0026lt;/url-pattern\u0026gt; \u0026lt;/filter-mapping\u0026gt; "},{"id":78,"href":"/TIL/spring/requestbody-responsebody/","title":"Spring","section":"Spring","content":"@RequestBody anotation 은 controller로 들어온 요청에서 request body의 내용물을 converting 할때 사용한다. 우선 request의 Content-type을 처리할 수 있는 HttpMessageConverter 구현체를 찾는다. 그리고 converting 처리를 통해 request body를 java object로 바꿔서 사용한다.\nPOST / HTTP/1.1 Host: localhost:8000 Connection: keep-alive Content-Type: application/json { \u0026#34;name\u0026#34;: \u0026#34;sangmoon\u0026#34;, \u0026#34;age\u0026#34;: \u0026#34;26\u0026#34; } Class Person{ String name; Integer age; } @RequestMapping(value=\u0026#34;/\u0026#34;, method=RequestMethod.POST) public String test(@requestBody Person person){ .... } @ResponseBody는 jsp를 return 해주지 않고 바로 http response를 return 해주기 위한 annotation 이다. 보통 @Controller + @ResponseBody를 해서 Rest용 Controller를 만드는데 @RestController annotation은 이둘을 합쳐놓은 것이다. request header에 있는 Accept keyword를 통해 보통 convert된다.\n@ResponseBody 를 사용하면 예외 처리 상황에서 어려움을 겪을 수 있다. 이 때 ResponseEntity를 사용하면 404나 500같은 상태 코드를 사용자에게 전송할수 있다.\n"},{"id":79,"href":"/TIL/spring/spring-mvc-config/","title":"Spring","section":"Spring","content":"2018/01/19\n스프링은 기본적으로 xml 기반의 설정파일은 관리한다.라이브러리 dependency 및 예약어 들을 관리하는 pom.xml. 가 있고root-context.xml 은 모든 SERVICE나 DAO layer bean을 담고 있다. compunent-scan을 통해 해당 경로의 Bean들을 찾는다.web-context.xml 은 servlet 정보들을 담고 있는데, 해당 servlet이 담당할 resolver나 handler 정보를 가지고 있다.web.xml에는 위에 web-context.xml에 등록한 servlet들 정보와, root-config.xml에 등록한 정보를 등록해서 dispatcherServlet 을 생성한다.\n하지만 xml파일은 가독성이 떨어지고 디버깅이 어려운 단점이 있다. 그래서 Spring3.1 이후로 java-based 설정이 추가되었다.\n\u0026lt;!-- web-servlet.xml --\u0026gt; \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;beans xmlns=\u0026#34;http://www.springframework.org/schema/beans\u0026#34; xmlns:mvc=\u0026#34;http://www.springframework.org/schema/mvc\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xmlns:context=\u0026#34;http://www.springframework.org/schema/context\u0026#34; xsi:schemaLocation=\u0026#34;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.2.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-3.2.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.2.xsd\u0026#34;\u0026gt; \u0026lt;!-- Scan for spring annotated components --\u0026gt; \u0026lt;context:component-scan base-package=\u0026#34;com.luckyryan.sample\u0026#34;/\u0026gt; \u0026lt;!-- Process annotations on registered beans like @Autowired... --\u0026gt; \u0026lt;context:annotation-config/\u0026gt; \u0026lt;!-- This tag registers the DefaultAnnotationHandlerMapping and AnnotationMethodHandlerAdapter beans that are required for Spring MVC --\u0026gt; \u0026lt;mvc:annotation-driven/\u0026gt; \u0026lt;!-- Exception Resolver that resolves exceptions through @ExceptionHandler methods --\u0026gt; \u0026lt;bean class=\u0026#34;org.springframework.web.servlet.mvc.method.annotation.ExceptionHandlerExceptionResolver\u0026#34;/\u0026gt; \u0026lt;!-- View Resolver for JSPs --\u0026gt; \u0026lt;bean class=\u0026#34;org.springframework.web.servlet.view.InternalResourceViewResolver\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;prefix\u0026#34; value=\u0026#34;/WEB-INF/pages/\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;suffix\u0026#34; value=\u0026#34;.jsp\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;!-- This tag allows for mapping the DispatcherServlet to \u0026#34;/\u0026#34; --\u0026gt; \u0026lt;mvc:default-servlet-handler/\u0026gt; \u0026lt;!-- resources exclusions from servlet mapping --\u0026gt; \u0026lt;mvc:resources mapping=\u0026#34;/assets/**\u0026#34; location=\u0026#34;classpath:/META-INF/resources/webjars/\u0026#34;/\u0026gt; \u0026lt;mvc:resources mapping=\u0026#34;/css/**\u0026#34; location=\u0026#34;/css/\u0026#34;/\u0026gt; \u0026lt;mvc:resources mapping=\u0026#34;/img/**\u0026#34; location=\u0026#34;/img/\u0026#34;/\u0026gt; \u0026lt;mvc:resources mapping=\u0026#34;/js/**\u0026#34; location=\u0026#34;/js/\u0026#34;/\u0026gt; \u0026lt;/beans\u0026gt; 이렇다고 하자. 이 설정을 config.java로 옮긴다면;\n@EnableWebMvc //\u0026lt;mvc:annotation-drvien\u0026gt; 과 같다. @ComponentScan(basePackages = {\u0026#34;com.luckyryan.sample\u0026#34;}) //\u0026lt;context:component-scan base-package=\u0026#34;com.luckyryan.sample\u0026#34;/\u0026gt; 과 같다. @Configuration // Bean 을 갖고 있음을 알려줌. public class appConfig extends WebMvcConfigurerAdapter { @Override // static resource handler  public void addResourceHandlers(ResourceHandlerRegistry registry) { registry.addResourceHandler(\u0026#34;/assets/**\u0026#34;).addResourceLocations(\u0026#34;classpath:/META-INF/resources/webjars/\u0026#34;).setCachePeriod(31556926); registry.addResourceHandler(\u0026#34;/css/**\u0026#34;).addResourceLocations(\u0026#34;/css/\u0026#34;).setCachePeriod(31556926); registry.addResourceHandler(\u0026#34;/img/**\u0026#34;).addResourceLocations(\u0026#34;/img/\u0026#34;).setCachePeriod(31556926); registry.addResourceHandler(\u0026#34;/js/**\u0026#34;).addResourceLocations(\u0026#34;/js/\u0026#34;).setCachePeriod(31556926); } @Override // \u0026lt;mvc:default-servlet-handler/\u0026gt; 와 같다.  public void configureDefaultServletHandling(DefaultServletHandlerConfigurer configurer) { configurer.enable(); } @Bean // View Resolver for JSPs bean과 같다  public InternalResourceViewResolver getInternalResourceViewResolver() { InternalResourceViewResolver resolver = new InternalResourceViewResolver(); resolver.setPrefix(\u0026#34;/WEB-INF/pages/\u0026#34;); resolver.setSuffix(\u0026#34;.jsp\u0026#34;); return resolver; } } 이와 같은 방식으로 해당 bean 이나 기본 해당 config의 base object를 상속해서 설정을 구성 할 수 있다. 앞으로 설정 파일에 대해 하나씩 분석해보겠다\u0026hellip;\n"},{"id":80,"href":"/TIL/spring/spring-security-custom-validator-pattern/","title":"Spring","section":"Spring","content":"2018/10/17\nSpring security에서의 custom validator pattern\n// User.java  @Entity(name=\u0026#34;user\u0026#34;) @PasswordMatches public class User { //중략..  @ValidEmail @NotNull @NotEmpty private String email; }  PasswordMatches의 경우 confirm field와 password field를 비교하기에 User 만들 때 사용.. ValidEmail의 경우 Email 형식인지 확인  @Target({ElementType.TYPE, ElementType.ANNOTATION_TYPE}) @Retention(RetentionPolicy.RUNTIME) @Constraint(validatedBy = PasswordMatchesValidator.class) @Documented public @interface PasswordMatches { String message() default \u0026#34;Passwords don\u0026#39;t match\u0026#34;; Class\u0026lt;?\u0026gt;[] groups() default {}; Class\u0026lt;? extends Payload\u0026gt;[] payload() default {}; } //PasswordMatchesValidator public class PasswordMatchesValidator implements ConstraintValidator\u0026lt;PasswordMatches, Object\u0026gt;{ @Override public void initialize(PasswordMatches constrainAnnotation) {} @Override public boolean isValid(Object obj, ConstraintValidatorContext context) { User user = (User) obj; return user.getPassword().equals(user.getMatchingPassword()); } } @Target({ElementType.TYPE, ElementType.FIELD, ElementType.ANNOTATION_TYPE}) @Retention(value = RetentionPolicy.RUNTIME) @Constraint(validatedBy = EmailValidator.class) @Documented public @interface ValidEmail { } public class EmailValidator implements ConstraintValidator\u0026lt;ValidEmail, String\u0026gt; { private Pattern pattern; private Matcher matcher; private static final String EMAIL_PATTERN = \u0026#34;^[_A-Za-z0-9-+]+ (.[_A-Za-z0-9-]+)*@\u0026#34; + \u0026#34;[A-Za-z0-9-]+(.[A-Za-z0-9]+)*(.[A-Za-z]{2,})$\u0026#34;; @Override public void initialize(ValidEmail constriantAnotation) { } @Override public boolean isValid(String email, ConstraintValidatorContext context) { return (validateEmail(email)); } private boolean validateEmail(String email) { pattern = Pattern.compile(EMAIL_PATTERN); matcher = pattern.matcher(email); return matcher.matches(); } } "},{"id":81,"href":"/TIL/spring/spring-security-retrieve-user-info/","title":"Spring","section":"Spring","content":"2018/01/25\n스프링 시큐리티로 유저 정보 얻기! #   Bean으로 부터 유저 정보 얻기 SecurityConytextHolder 로 부터 현재 인증된 principal을 얻을 수 있다.  Authentication authentication = SecurityContextHolder.getContext().getAuthentication(); String currentPrincipalName = authentication.getName();\t체크하기 전에 유저가 있는지 체크할 수 있다.\nAuthentication authentication = SecurityContextHolder.getContext().getAuthentication(); if (!(authentication instanceof AnonymousAuthenticationToken)) { String currentUserName = authentication.getName(); return currentUserName; } 하지만 static call은 좋지 않다\u0026hellip;\n컨트롤러에서는 (@Controller) 추가적인 방법이 가능하다. Principal 에 method argument로 접근이 가능하다.  import java.security.Principal; import org.springframework.stereotype.Controller; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RequestMethod; import org.springframework.web.bind.annotation.ResponseBody; @Controller public class SecurityController { @RequestMapping(value = \u0026#34;/username\u0026#34;, method = RequestMethod.GET) @ResponseBody public String currentUserName(Principal principal) { return principal.getName(); } } authentication token 으로 접근 할 수도 있다.\nimport org.springframework.security.core.Authentication; import org.springframework.stereotype.Controller; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RequestMethod; import org.springframework.web.bind.annotation.ResponseBody; @Controller public class SecurityController { @RequestMapping(value = \u0026#34;/username\u0026#34;, method = RequestMethod.GET) @ResponseBody public String currentUserName(Authentication authentication) { return authentication.getName(); } } HTTP request로 부터 직접 접근도 가능하다.\nimport java.security.Principal; import javax.servlet.http.HttpServletRequest; import org.springframework.stereotype.Controller; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RequestMethod; import org.springframework.web.bind.annotation.ResponseBody; @Controller public class SecurityController { @RequestMapping(value = \u0026#34;/username\u0026#34;, method = RequestMethod.GET) @ResponseBody public String currentUserNameSimple(HttpServletRequest request) { Principal principal = request.getUserPrincipal(); return principal.getName(); } } Spring의 DI를 이용하면 컨트롤러가 아니어도 어디서든 접근이 가능하다! 이를 위해 간단한 인터페이스를 구성하자.  public interface IAuthenticationFacade { Authentication getAuthentication(); } @Component public class AuthenticationFacade implements IAuthenticationFacade { @Override public Authentication getAuthentication() { return SecurityContextHolder.getContext().getAuthentication(); } } DI를 활용해 다음과 같이 decoupled 시켜서 스프링의 장점을 활용할 수 있다.\n@Controller public class SecurityController { @Autowired private IAuthenticationFacade authenticationFacade; @RequestMapping(value = \u0026#34;/username\u0026#34;, method = RequestMethod.GET) @ResponseBody public String currentUserNameSimple() { Authentication authentication = authenticationFacade.getAuthentication(); return authentication.getName(); } } JSP 에서는 어떻게 가져오지? 현재 인증 정보는 JSP에서 접근 할 수도 있다. 우선 spring-security-taglib를 pom.xml에 추가하고  \u0026lt;%@ taglib prefix=\u0026quot;security\u0026quot; uri=\u0026quot;http://www.springframework.org/security/tags\u0026quot; %\u0026gt; 라고 jsp에 include하면 된다.\n\u0026lt;security:authorize access=\u0026quot;isAuthenticated()\u0026quot;\u0026gt; authenticated as \u0026lt;security:authentication property=\u0026quot;principal.username\u0026quot; /\u0026gt; \u0026lt;/security:authorize\u0026gt; 그러면 위와 같이 접근 할 수 있다.\n다음 두 곳을 참조하였다.\nBaeldung\ngithub-project\n"},{"id":82,"href":"/TIL/spring/transaction/","title":"Spring","section":"Spring","content":"transaction #  @Transactional annotation으로 처리 한다.\nPropagation 속성 #   PROPAGATION_MADATORY PROPAGATION_NESTED PROPAGATION_NEVER PROPAGATION_NOT_SUPPORTED PROPAGATION_REQUIRED PROPAGATION_REQUIRED_NEW PROPAGATIN_SUPPORTS  "},{"id":83,"href":"/TIL/spring/web-config/","title":"Spring","section":"Spring","content":"2018/01/19\nWebConfig 설정을 알아보자. servlet.xml을 대체하는 java class이다. WebConfig가 상속받는 abstract class는 다음 WebMvcConfigurerAdapter 이다. 이 abstract class는 WebMvcConfigurer 라는 interface를 구현했는데 이는 원하는 method만 override하면 실행되도록 하기 위함이다. 해당 method가 어떤 설정에 해당하는지 알아보자. spring docs\npublic abstract class WebMvcConfigurerAdapter implements WebMvcConfigurer { @Override public void configurePathMatch(PathMatchConfigurer configurer) { } @Override public void configureContentNegotiation(ContentNegotiationConfigurer configurer) { } @Override public void configureAsyncSupport(AsyncSupportConfigurer configurer) { } @Override public void configureDefaultServletHandling(DefaultServletHandlerConfigurer configurer) { } @Override public void addFormatters(FormatterRegistry registry) { } @Override public void addInterceptors(InterceptorRegistry registry) { } @Override public void addResourceHandlers(ResourceHandlerRegistry registry) { } @Override public void addCorsMappings(CorsRegistry registry) { } @Override public void addViewControllers(ViewControllerRegistry registry) { } @Override public void configureViewResolvers(ViewResolverRegistry registry) { } @Override public void addArgumentResolvers(List\u0026lt;HandlerMethodArgumentResolver\u0026gt; argumentResolvers) { } @Override public void addReturnValueHandlers(List\u0026lt;HandlerMethodReturnValueHandler\u0026gt; returnValueHandlers) { } @Override public void configureMessageConverters(List\u0026lt;HttpMessageConverter\u0026lt;?\u0026gt;\u0026gt; converters) { } @Override public void extendMessageConverters(List\u0026lt;HttpMessageConverter\u0026lt;?\u0026gt;\u0026gt; converters) { } @Override public void configureHandlerExceptionResolvers(List\u0026lt;HandlerExceptionResolver\u0026gt; exceptionResolvers) { } @Override public void extendHandlerExceptionResolvers(List\u0026lt;HandlerExceptionResolver\u0026gt; exceptionResolvers) { } @Override public Validator getValidator() { return null; } @Override public MessageCodesResolver getMessageCodesResolver() { return null; } } public void configurePathMatch(PathMatchConfigurer configurer) 는 \u0026lt;mvc:path-matching\u0026gt; 태크와 같은 역할을 한다.suffix-pattern, trailing-slash, registered-suffixes-only, path-helper, path-matcher 등을 등록할 수 있다.\npublic void configureContentNegotiation(ContentNegotiationConfigurer configurer) 는 \u0026lt;mvc:annotation-driven content-negotiation-manager=\u0026quot;??\u0026quot;/\u0026gt; tag를 대신한다. content-negotiation은 어떤 type의 content를 보내줄지 클라이언트에게 위임하는 것이다.\npublic void configureAsyncSupport(AsyncSupportConfigurer configurer)는 spring 내에서 async한 task를 하고자 할 때 thread pool과 타임아웃, taskexecuter등을 설정한다.\npublic void configureDefaultServletHandling(DefaultServletHandlerConfigurer configurer) 는 어떤 servlet과도 match가 안될때 갈 deafultServlet을 설정한다.\npublic void addFormatters(FormatterRegistry registry) 는 \u0026lt;mvc:annotation-driven conversion-service=\u0026quot;??\u0026quot;/\u0026gt; 태그 역할을 한다.\npublic void addInterceptors(InterceptorRegistry registry) 는 interceptor 를 등록하는 부분이다.\npublic void addResourceHandlers(ResourceHandlerRegistry registry)는 html, css, js 같은 static resources 들을 처리하는 handler를 등록한다.\npublic void addCorsMappings(CorsRegistry registry)는 cross origin resource sharing을 위한 메소드로 이곳에서의 설정은 global하게 적용된다.\npublic void addViewControllers(ViewControllerRegistry registry) static한 view를 등록하는 곳인데 잘 안 쓴다.\npublic void configureViewResolvers(ViewResolverRegistry registry) view template를 처리하는 resolver를 등록한다. suffix나 prefix처리를 할 수 있다.\npublic void addArgumentResolvers(List\u0026lt;HandlerMethodArgumentResolver\u0026gt; argumentResolvers) user로 부터 넘어온 값을 바로 model이나 Object로 받을 수 있다. 하지만 Model과 1:1 parameter mapping 이 안되거나, form object가 아니거나, request body에 값이 없으면 mapping이 제대로 안될 수 있다이런 경우 addArgumentResolvers를 이용해 특정 행동을 하는 argumentResolver를 추가할 수 있다.\npublic void addReturnValueHandlers(List\u0026lt;HandlerMethodReturnValueHandler\u0026gt; returnValueHandlers) 컨트롤러에서 특정 타입의 value를 반환 할 때 이를 처리하는 handler이다.\npublic void configureMessageConverters(List\u0026lt;HttpMessageConverter\u0026lt;?\u0026gt;\u0026gt; converters) 특정 mime에 대한 converter를 등록한다. jackson이 많이 쓰인다.. 이걸 쓰면 기존 default들이 다 turn off된다.\npublic void extendMessageConverters(List\u0026lt;HttpMessageConverter\u0026lt;?\u0026gt;\u0026gt; converters) default를 냅두고 custom 한가지만 집어 넣는다.\npublic void configureHandlerExceptionResolvers(List\u0026lt;HandlerExceptionResolver\u0026gt; exceptionResolvers) Exception 발생시 어떻게 해야할지 알려준다. default들은 turn off 시킨다.\npublic void extendHandlerExceptionResolvers(List\u0026lt;HandlerExceptionResolver\u0026gt; exceptionResolvers)  기존 default handler 를 확장한다.\npublic Validator getValidator() validator 등록\npublic MessageCodesResolver getMessageCodesResolver() 에러 방생시 error code와 Object name으로 사용할 message code를 리턴한다.\n"}]