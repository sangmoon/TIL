<!doctype html><html lang=en dir=ltr>
<head>
<meta charset=utf-8>
<meta name=viewport content="width=device-width,initial-scale=1">
<meta name=description content="자바 잘 짜보자">
<meta name=theme-color content="#FFFFFF">
<meta name=color-scheme content="light dark"><meta property="og:title" content="Effective Java">
<meta property="og:description" content="자바 잘 짜보자">
<meta property="og:type" content="article">
<meta property="og:url" content="https://sangmoon.github.io/TIL/effectivejava/generalprogramming/"><meta property="article:section" content="EffectiveJava">
<meta property="article:published_time" content="2021-10-23T00:00:00+00:00">
<meta property="article:modified_time" content="2021-10-23T00:00:00+00:00">
<title>Effective Java | Sangmoon's TIL</title>
<link rel=manifest href=/TIL/manifest.json>
<link rel=icon href=/TIL/favicon.png type=image/x-icon>
<link rel=stylesheet href=/TIL/book.min.46181bc93375ba932026e753b37c40e6ff8bb16a9ef770c78bcc663e4577b1ba.css integrity="sha256-RhgbyTN1upMgJudTs3xA5v+LsWqe93DHi8xmPkV3sbo=" crossorigin=anonymous>
<script defer src=/TIL/flexsearch.min.js></script>
<script defer src=/TIL/en.search.min.58e317a58bdb983ff9fe64dbce44994883782a83ea5a5d5fbf080e12279c4e0f.js integrity="sha256-WOMXpYvbmD/5/mTbzkSZSIN4KoPqWl1fvwgOEiecTg8=" crossorigin=anonymous></script>
</head>
<body dir=ltr>
<input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control>
<main class="container flex">
<aside class=book-menu>
<div class=book-menu-content>
<nav>
<h2 class=book-brand>
<a class="flex align-center" href=/TIL/><span>Sangmoon's TIL</span>
</a>
</h2>
<div class=book-search>
<input type=text id=book-search-input placeholder=Search aria-label=Search maxlength=64 data-hotkeys=s/>
<div class="book-search-spinner hidden"></div>
<ul id=book-search-results></ul>
</div>
</nav>
<script>(function(){var a=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(b){localStorage.setItem("menu.scrollTop",a.scrollTop)}),a.scrollTop=localStorage.getItem("menu.scrollTop")})()</script>
</div>
</aside>
<div class=book-page>
<header class=book-header>
<div class="flex align-center justify-between">
<label for=menu-control>
<img src=/TIL/svg/menu.svg class=book-icon alt=Menu>
</label>
<strong>Effective Java</strong>
<label for=toc-control>
<img src=/TIL/svg/toc.svg class=book-icon alt="Table of Contents">
</label>
</div>
<aside class="hidden clearfix">
<nav id=TableOfContents>
<ul>
<li><a href=#규칙-53-리플렉션-대신-인터페이스를-이용하라>규칙 53 리플렉션 대신 인터페이스를 이용하라</a>
<ul>
<li><a href=#일반적인-프로그램은-프로그램-실행-중-리플렉션을-통해-객체를-이용하려-하면-안-된다>일반적인 프로그램은 프로그램 실행 중 리플렉션을 통해 객체를 이용하려 하면 안 된다</a></li>
<li><a href=#리플렉션을-아주-제한적으로-사용하면-오버헤드는-피하면서-리플렉션의-장점을-누릴-수-있다>리플렉션을 아주 제한적으로 사용하면 오버헤드는 피하면서 리플렉션의 장점을 누릴 수 있다.</a></li>
<li><a href=#요약>요약</a></li>
</ul>
</li>
<li><a href=#규칙-54-네이티브-메서드는-신중히-사용하라>규칙 54 네이티브 메서드는 신중히 사용하라</a>
<ul>
<li><a href=#네이티브-메서드를-통해-성능을-개선하는-것을-추천-안함>네이티브 메서드를 통해 성능을 개선하는 것을 추천 안함</a></li>
<li><a href=#요약-1>요약</a></li>
</ul>
</li>
<li><a href=#규칙-55-신중하게-최적화하라>규칙 55 신중하게 최적화하라</a>
<ul>
<li><a href=#중간-요약>중간 요약</a></li>
<li><a href=#요약-2>요약</a></li>
</ul>
</li>
<li><a href=#규칙-56-일반적으로-통용되는-작명-관습을-따르라>규칙 56 일반적으로 통용되는 작명 관습을 따르라</a>
<ul>
<li><a href=#요약-3>요약</a></li>
</ul>
</li>
</ul>
</nav>
</aside>
</header>
<article class=markdown><h1 id=일반적인-프로그래밍-원칙들>
일반적인 프로그래밍 원칙들
<a class=anchor href=#%ec%9d%bc%eb%b0%98%ec%a0%81%ec%9d%b8-%ed%94%84%eb%a1%9c%ea%b7%b8%eb%9e%98%eb%b0%8d-%ec%9b%90%ec%b9%99%eb%93%a4>#</a>
</h1>
<h2 id=규칙-53-리플렉션-대신-인터페이스를-이용하라>
규칙 53 리플렉션 대신 인터페이스를 이용하라
<a class=anchor href=#%ea%b7%9c%ec%b9%99-53-%eb%a6%ac%ed%94%8c%eb%a0%89%ec%85%98-%eb%8c%80%ec%8b%a0-%ec%9d%b8%ed%84%b0%ed%8e%98%ec%9d%b4%ec%8a%a4%eb%a5%bc-%ec%9d%b4%ec%9a%a9%ed%95%98%eb%9d%bc>#</a>
</h2>
<p>java.lang.reflect 를 활용하면 클래스 정보를 런타임에 가져 올 수 있다.</p>
<ul>
<li>Class 객체를 통해 생성자(Constructor), 메서드(Method), 필드(Field) 객체를 가져올 수 있다</li>
<li>멤버 이름, 필드 자료형, 메서드 시그니처 들을 알 수 있다.</li>
<li>객체를 생성할 수도 있고, 메서드를 호출할 수도 있으며 필드에 접근할 수도 있다.</li>
</ul>
<p>단점도 많다.</p>
<ul>
<li>컴파일 시점에서 자료형 검사함으로써 얻는 이점을 모두 포기해야 한다 (존재하지 않는, 접근 할 수 없는 method 호출하면 런타임 오류 발생)</li>
<li>리플렉션 코드는 보기 싫고 장황하다. 가독성 떨어진다</li>
<li>성능이 낮다 (저자 컴퓨터에서는 2 ~ 50 배 가량 느렸다)</li>
</ul>
<h3 id=일반적인-프로그램은-프로그램-실행-중-리플렉션을-통해-객체를-이용하려-하면-안-된다>
일반적인 프로그램은 프로그램 실행 중 리플렉션을 통해 객체를 이용하려 하면 안 된다
<a class=anchor href=#%ec%9d%bc%eb%b0%98%ec%a0%81%ec%9d%b8-%ed%94%84%eb%a1%9c%ea%b7%b8%eb%9e%a8%ec%9d%80-%ed%94%84%eb%a1%9c%ea%b7%b8%eb%9e%a8-%ec%8b%a4%ed%96%89-%ec%a4%91-%eb%a6%ac%ed%94%8c%eb%a0%89%ec%85%98%ec%9d%84-%ed%86%b5%ed%95%b4-%ea%b0%9d%ec%b2%b4%eb%a5%bc-%ec%9d%b4%ec%9a%a9%ed%95%98%eb%a0%a4-%ed%95%98%eb%a9%b4-%ec%95%88-%eb%90%9c%eb%8b%a4>#</a>
</h3>
<p>리플렉션이 필요한 복잡한 프로그램 예시 (여기에 포함 안 되면 리플렉션 사용 ㄴㄴ)</p>
<ul>
<li>클래스 브라우저</li>
<li>객체 검사도구</li>
<li>코드 분석 도구</li>
<li>해석적 내장형 시스템(interpretive embedded system) ???</li>
<li>스텁 컴파일러가 없는 원격 프로시저 호출(???)</li>
</ul>
<h3 id=리플렉션을-아주-제한적으로-사용하면-오버헤드는-피하면서-리플렉션의-장점을-누릴-수-있다>
리플렉션을 아주 제한적으로 사용하면 오버헤드는 피하면서 리플렉션의 장점을 누릴 수 있다.
<a class=anchor href=#%eb%a6%ac%ed%94%8c%eb%a0%89%ec%85%98%ec%9d%84-%ec%95%84%ec%a3%bc-%ec%a0%9c%ed%95%9c%ec%a0%81%ec%9c%bc%eb%a1%9c-%ec%82%ac%ec%9a%a9%ed%95%98%eb%a9%b4-%ec%98%a4%eb%b2%84%ed%97%a4%eb%93%9c%eb%8a%94-%ed%94%bc%ed%95%98%eb%a9%b4%ec%84%9c-%eb%a6%ac%ed%94%8c%eb%a0%89%ec%85%98%ec%9d%98-%ec%9e%a5%ec%a0%90%ec%9d%84-%eb%88%84%eb%a6%b4-%ec%88%98-%ec%9e%88%eb%8b%a4>#</a>
</h3>
<ul>
<li>객체 생성은 리플렉션으로, 참조는 인터페이스나 상위 클래스로</li>
</ul>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#75715e>// command line으로 받은 첫번째 인자의 클래스를 이용해 Set&lt;String&gt; 을 만드는 프로그램. 나머지 인자는 해당 Set에 집어 넣음
</span><span style=color:#75715e>// 생성은 리플렉션, 참조와 사용은 인터페이스
</span><span style=color:#75715e></span>
<span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>main</span><span style=color:#f92672>(</span>String<span style=color:#f92672>[]</span> args<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
    Class<span style=color:#f92672>&lt;?</span> <span style=color:#66d9ef>extends</span> Set<span style=color:#f92672>&lt;</span>String<span style=color:#f92672>&gt;&gt;</span> cl <span style=color:#f92672>=</span> <span style=color:#66d9ef>null</span><span style=color:#f92672>;</span>
    <span style=color:#66d9ef>try</span> <span style=color:#f92672>{</span>
        cl <span style=color:#f92672>=</span> <span style=color:#f92672>(</span>Class<span style=color:#f92672>&lt;?</span> <span style=color:#66d9ef>extends</span> Set<span style=color:#f92672>&lt;</span>String<span style=color:#f92672>&gt;&gt;)</span> Class<span style=color:#f92672>.</span><span style=color:#a6e22e>forName</span><span style=color:#f92672>(</span>args<span style=color:#f92672>[</span>0<span style=color:#f92672>]);</span> <span style=color:#75715e>// unchecked cast
</span><span style=color:#75715e></span>    <span style=color:#f92672>}</span> <span style=color:#66d9ef>catch</span> <span style=color:#f92672>(</span>ClassNotFoundException e<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
        System<span style=color:#f92672>.</span><span style=color:#a6e22e>err</span><span style=color:#f92672>.</span><span style=color:#a6e22e>println</span><span style=color:#f92672>(</span><span style=color:#e6db74>&#34;Class not found.&#34;</span><span style=color:#f92672>);</span>
        System<span style=color:#f92672>.</span><span style=color:#a6e22e>exit</span><span style=color:#f92672>(</span>1<span style=color:#f92672>);</span>
    <span style=color:#f92672>}</span>

    <span style=color:#75715e>// get constructor
</span><span style=color:#75715e></span>    Constructor<span style=color:#f92672>&lt;?</span> <span style=color:#66d9ef>extends</span> Set<span style=color:#f92672>&lt;</span>String<span style=color:#f92672>&gt;&gt;</span> cons <span style=color:#f92672>=</span> <span style=color:#66d9ef>null</span><span style=color:#f92672>;</span>
    <span style=color:#66d9ef>try</span> <span style=color:#f92672>{</span>
        cons <span style=color:#f92672>=</span> cl<span style=color:#f92672>.</span><span style=color:#a6e22e>getDeclaredConstructor</span><span style=color:#f92672>();</span>
    <span style=color:#f92672>}</span> <span style=color:#66d9ef>catch</span> <span style=color:#f92672>(</span>NoSuchMethodException e<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
        System<span style=color:#f92672>.</span><span style=color:#a6e22e>err</span><span style=color:#f92672>.</span><span style=color:#a6e22e>println</span><span style=color:#f92672>(</span><span style=color:#e6db74>&#34;No parameterless constructor.&#34;</span><span style=color:#f92672>);</span>
        System<span style=color:#f92672>.</span><span style=color:#a6e22e>exit</span><span style=color:#f92672>(</span>1<span style=color:#f92672>);</span>
    <span style=color:#f92672>}</span>

    <span style=color:#75715e>// Instantiate the set
</span><span style=color:#75715e></span>    Set<span style=color:#f92672>&lt;</span>String<span style=color:#f92672>&gt;</span> s <span style=color:#f92672>=</span> <span style=color:#66d9ef>null</span><span style=color:#f92672>;</span>  <span style=color:#75715e>// Set으로 참조
</span><span style=color:#75715e></span>
    <span style=color:#66d9ef>try</span> <span style=color:#f92672>{</span>
        <span style=color:#75715e>// cl.newInstance() 를 안쓰고 굳이 생성자 호출하는 이유는?
</span><span style=color:#75715e></span>        s <span style=color:#f92672>=</span> cons<span style=color:#f92672>.</span><span style=color:#a6e22e>newInstance</span><span style=color:#f92672>();</span>
    <span style=color:#f92672>}</span> <span style=color:#66d9ef>catch</span> <span style=color:#f92672>(</span>IllegalAccessException e<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
        System<span style=color:#f92672>.</span><span style=color:#a6e22e>err</span><span style=color:#f92672>.</span><span style=color:#a6e22e>println</span><span style=color:#f92672>(</span><span style=color:#e6db74>&#34;Class not accessible.&#34;</span><span style=color:#f92672>);</span>
        System<span style=color:#f92672>.</span><span style=color:#a6e22e>exit</span><span style=color:#f92672>(</span>1<span style=color:#f92672>);</span>
    <span style=color:#f92672>}</span> <span style=color:#66d9ef>catch</span> <span style=color:#f92672>(</span>InstantiationException e<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
        System<span style=color:#f92672>.</span><span style=color:#a6e22e>err</span><span style=color:#f92672>.</span><span style=color:#a6e22e>println</span><span style=color:#f92672>(</span><span style=color:#e6db74>&#34;Class not instantiable&#34;</span><span style=color:#f92672>);</span>
        System<span style=color:#f92672>.</span><span style=color:#a6e22e>exit</span><span style=color:#f92672>(</span>1<span style=color:#f92672>);</span>
    <span style=color:#f92672>}</span> <span style=color:#66d9ef>catch</span> <span style=color:#f92672>(</span>InvocationTargetException e<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
        System<span style=color:#f92672>.</span><span style=color:#a6e22e>err</span><span style=color:#f92672>.</span><span style=color:#a6e22e>println</span><span style=color:#f92672>(</span><span style=color:#e6db74>&#34;Constructor threw &#34;</span> <span style=color:#f92672>+</span> e<span style=color:#f92672>.</span><span style=color:#a6e22e>getCause</span><span style=color:#f92672>());</span>
        System<span style=color:#f92672>.</span><span style=color:#a6e22e>exit</span><span style=color:#f92672>(</span>1<span style=color:#f92672>);</span>
    <span style=color:#f92672>}</span> <span style=color:#66d9ef>catch</span> <span style=color:#f92672>(</span>ClassCastException e<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
        System<span style=color:#f92672>.</span><span style=color:#a6e22e>err</span><span style=color:#f92672>.</span><span style=color:#a6e22e>println</span><span style=color:#f92672>(</span><span style=color:#e6db74>&#34;Class doesn&#39;t implements Set&#34;</span><span style=color:#f92672>);</span>
        System<span style=color:#f92672>.</span><span style=color:#a6e22e>exit</span><span style=color:#f92672>(</span>1<span style=color:#f92672>);</span>
    <span style=color:#f92672>}</span>

    s<span style=color:#f92672>.</span><span style=color:#a6e22e>addAll</span><span style=color:#f92672>(</span>Arrays<span style=color:#f92672>.</span><span style=color:#a6e22e>asList</span><span style=color:#f92672>(</span>args<span style=color:#f92672>).</span><span style=color:#a6e22e>subList</span><span style=color:#f92672>(</span>1<span style=color:#f92672>,</span> args<span style=color:#f92672>.</span><span style=color:#a6e22e>length</span><span style=color:#f92672>));</span>
    System<span style=color:#f92672>.</span><span style=color:#a6e22e>out</span><span style=color:#f92672>.</span><span style=color:#a6e22e>println</span><span style=color:#f92672>(</span>s<span style=color:#f92672>);</span>
    <span style=color:#75715e>/// etc
</span><span style=color:#75715e></span><span style=color:#f92672>}</span>
</code></pre></div><ul>
<li>어떤 클래스가 Set을 구현했는지 검증하는 검사도구로 사용 가능 (generic set tester)</li>
<li>일반적 집합 성능 분석 도구 (generic performance analysis tool) 로도 사용 가능</li>
</ul>
<p>2개의 단점 존재</p>
<ul>
<li>6 가지 런타임 오류 발생. 리플렉션 안 썼으면 컴파일 시점에서 다 감지 가능</li>
<li>클래스 객체 생성 위해 코드 엄청 많이 씀. 생성자 호출로 했으면 한 줄로 가능</li>
</ul>
<p>하지만 객체 생성 부분에서만 나타나는 문제로 일단 객체 생성 후에는 Set&lt;>으로 참조하기 때문에 아무 영향 없다.</p>
<p>리플렉션은 실행 시점에 존재하지 않는 클래스나 메서드, 필드에 대한 종속성 관리에 적합.
어떤 패키지의 버전이 여러가지 이고, 그 전부를 지원하는 또 다른 패키지를 구현해야 할 때
모든 버전을 지원하는 최소한의 환경만 컴파일하고, 새로운 클래스나 메서드는 리플렉션을 통해 접근</p>
<h3 id=요약>
요약
<a class=anchor href=#%ec%9a%94%ec%95%bd>#</a>
</h3>
<ul>
<li>리플렉션은 특정 종류의 복잡한 시스템 프로그래밍에 필요한 강력한 도구</li>
<li>단점 매우 많음</li>
<li>사용하고 싶다면 객체를 만들 때만 사용하고 참조할 때는 컴파일 시에 알고 있는 인터페이스나 상위 클래스만 사용할 것</li>
</ul>
<h2 id=규칙-54-네이티브-메서드는-신중히-사용하라>
규칙 54 네이티브 메서드는 신중히 사용하라
<a class=anchor href=#%ea%b7%9c%ec%b9%99-54-%eb%84%a4%ec%9d%b4%ed%8b%b0%eb%b8%8c-%eb%a9%94%ec%84%9c%eb%93%9c%eb%8a%94-%ec%8b%a0%ec%a4%91%ed%9e%88-%ec%82%ac%ec%9a%a9%ed%95%98%eb%9d%bc>#</a>
</h2>
<p>JNI(java native interface) 는 C나 C++로 작성된 native method 호출하는 데 이용되는 기능.</p>
<p>3가지 용도로 쓰임</p>
<ol>
<li>레지스트리나 파일락 같은 특정 플랫폼에 고유한 기능을 이용</li>
<li>이미 구현되있는 라이브러리를 이용할 수 있음</li>
<li>성능 상 중요한 부분을 네이티브 언어에 맡길 수 있음</li>
</ol>
<h3 id=네이티브-메서드를-통해-성능을-개선하는-것을-추천-안함>
네이티브 메서드를 통해 성능을 개선하는 것을 추천 안함
<a class=anchor href=#%eb%84%a4%ec%9d%b4%ed%8b%b0%eb%b8%8c-%eb%a9%94%ec%84%9c%eb%93%9c%eb%a5%bc-%ed%86%b5%ed%95%b4-%ec%84%b1%eb%8a%a5%ec%9d%84-%ea%b0%9c%ec%84%a0%ed%95%98%eb%8a%94-%ea%b2%83%ec%9d%84-%ec%b6%94%ec%b2%9c-%ec%95%88%ed%95%a8>#</a>
</h3>
<ul>
<li>현재 JVM은 네이티브에 필적하는 성능을 낸다.</li>
<li>네이티브 메서드는 심각한 문제 1. 안전하지 않다. memory corruption error 발생 가능</li>
<li>플랫폼 종속적</li>
<li>디버깅 어려움</li>
<li>네이티브와 jvm 넘나드는 코드 때문에 오히려 성능 떨어질 수 있음</li>
<li>이해하기 어렵고 작성하기 난감한 접착 코드 작성해야 함</li>
</ul>
<h3 id=요약-1>
요약
<a class=anchor href=#%ec%9a%94%ec%95%bd-1>#</a>
</h3>
<ul>
<li>네이티브 메서드 쓰지 마라</li>
<li>퍼포먼스 향상 될 일 거의 없다</li>
<li>굳이 써야 한다면 네이티브 코드를 최소화 하고 전체를 다 테스트 해야한다. 작은 버그가 어플리케이션을 다 망침.</li>
</ul>
<h2 id=규칙-55-신중하게-최적화하라>
규칙 55 신중하게 최적화하라
<a class=anchor href=#%ea%b7%9c%ec%b9%99-55-%ec%8b%a0%ec%a4%91%ed%95%98%ea%b2%8c-%ec%b5%9c%ec%a0%81%ed%99%94%ed%95%98%eb%9d%bc>#</a>
</h2>
<p>최적화 관련 명언 3개가 있다.</p>
<blockquote>
<p>맹목적인 어리석음을 비롯한 다른 어떤 이유보다도, 효율성이라는 이름으로 저질러지는 죄악이 더 많다. - 윌리엄 울프</p>
</blockquote>
<blockquote>
<p>작은 효율성에 대해서는, 말하자면 97% 정도에 대해서는, 잊어버려라. 섣부른 최적화는 모든 악의 근원이다. - 도널드 커누스</p>
</blockquote>
<blockquote>
<p>최적화 할 때는 아래 두 규칙을 따르라.
규칙 1: 하지 마라
규칙 2: (전문가들만 따를 것) 아직은 하지 마라 - 완벽히 명료한, 최적화되지 않은 해답을 얻을 때까지는 - M.A. 잭슨 M</p>
</blockquote>
<h3 id=중간-요약>
중간 요약
<a class=anchor href=#%ec%a4%91%ea%b0%84-%ec%9a%94%ec%95%bd>#</a>
</h3>
<p><code>최적화 하지마라</code></p>
<ul>
<li>
<p>성능 때문에 구조적인 원칙을 희생하지 마라. 빠른 프로그램이 아닌, 좋은 프로그램을 만드려 노력하라. 좋은 프로그램이라면 좋은 구조를 갖추었기 때문에 최적화의 여지도 충분.</p>
</li>
<li>
<p>설계 할 때는 성능을 제약할 가능성이 있는 결정들은 피하라. 가장 까다로운 부분은 모듈간의 상호작용이나 외부와의 상호작용을 명시하는 부분, 즉 <code>API</code>, <code>통신 프로토콜</code>, <code>지속성 데이터 형식</code> 등 이다. 이런 부분은 성능 문제가 발견된 후 수정이 어렵다.</p>
</li>
<li>
<p>API를 설계할 때 내리는 결정들이 성능에 어떤 영향을 끼칠지 생각하라.</p>
<ul>
<li>public 자료형을 변경 가능하게 만들면 방어적 복사를 많이 해야한다.</li>
<li>composition이 적절할 public class에 상속을 적용하면 해당 클래스는 영원히 상위 클래스에 묶이게 되서 하위 클래스 성능에 제약 가해질 수 있다.</li>
<li>인터페이스가 적당한 API 에 구현자료형 사용하면 해당 API가 특정 구현에 종속되어 나중에 더 빠른 구현이 나와도 개선할 수 없다.</li>
</ul>
</li>
<li>
<p>성능을 위해 API를 급진적으로 바꾸는 건 바람직하지 않다.</p>
<ul>
<li>너무 많이 변경된 API를 지원하는건 개발자가 너무 힘들다.</li>
</ul>
</li>
<li>
<p>최적화를 시도할 때마다 전후 성능을 측정하고 비교하라</p>
<ul>
<li>JVM 마다, 릴리스 마다, 프로세서 마다 차이가 크다.</li>
</ul>
</li>
</ul>
<h3 id=요약-2>
요약
<a class=anchor href=#%ec%9a%94%ec%95%bd-2>#</a>
</h3>
<ul>
<li>빠른 프로그램 만들고자 애쓰지 마라</li>
<li>대신 좋은 프로그램 짜기 위해 노력하면 성능은 따라 온다</li>
<li>시스템 설계할 때 API, 통신 프로토콜, 지속성 데이터 형식을 성계할 때 성능 문제를 따져봐라.</li>
<li>성능 문제 있을 때 처음 해야 할건 구현에 쓰인 알고리즘 검토. 이게 잘못되면 저수준 최적화 의미없음.</li>
</ul>
<h2 id=규칙-56-일반적으로-통용되는-작명-관습을-따르라>
규칙 56 일반적으로 통용되는 작명 관습을 따르라
<a class=anchor href=#%ea%b7%9c%ec%b9%99-56-%ec%9d%bc%eb%b0%98%ec%a0%81%ec%9c%bc%eb%a1%9c-%ed%86%b5%ec%9a%a9%eb%90%98%eb%8a%94-%ec%9e%91%eb%aa%85-%ea%b4%80%ec%8a%b5%ec%9d%84-%eb%94%b0%eb%a5%b4%eb%9d%bc>#</a>
</h2>
<ol>
<li>철자에 관한 것</li>
</ol>
<ul>
<li>
<p>package</p>
<ul>
<li>마침표를 구분자로 하는 계층적 이름</li>
<li>소문자 사용</li>
<li>숫자 거의 사용 X</li>
<li>앞에 2개는 조직의 인터넷 도메인을 따온다 (<code>com.tmax</code>)</li>
<li>나머지 부분은 어떤 패키지 인지 설명하는 하나이상의 컴포넌트로 구성</li>
<li>의미가 확실한 약어면 좋음(utilities 보다 util)</li>
</ul>
</li>
<li>
<p>enum, class, interface</p>
<ul>
<li>첫 글자는 대문자</li>
<li>널리 쓰이는 약어(max, min)을 제외하면 약어는 피한다</li>
</ul>
</li>
<li>
<p>메서드, 필드</p>
<ul>
<li>첫 글자는 소문자</li>
<li>상수 필드의 경우 모두 대문자로 쓰며 <code>_</code> 로 구분한다.</li>
</ul>
</li>
<li>
<p>지역 변수</p>
<ul>
<li>메서드, 필드와 같은 규칙</li>
<li>약어를 많이 사용</li>
</ul>
</li>
<li>
<p>자료형 인자</p>
<ul>
<li>보통 하나의 대문자</li>
<li>임의 자료형 T</li>
<li>컬렉션의 요소 자료형 E</li>
<li>맵의 키와 값은 K, V</li>
<li>예외인 경우 X</li>
<li>임의 자료형의 연속은 T, U, V or T1, T2, T3</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th>식별자 자료형</th>
<th>예제</th>
</tr>
</thead>
<tbody>
<tr>
<td>패키지</td>
<td>com.tmax.proobject</td>
</tr>
<tr>
<td>클래스나 인터페이스</td>
<td>ChannelEventHandler, BodyParser</td>
</tr>
<tr>
<td>메서드나 필드</td>
<td>remove, ensureCapacity</td>
</tr>
<tr>
<td>상수 필드</td>
<td>MIN_VALUE, NEGETIVE_INFINITY</td>
</tr>
<tr>
<td>지역 변수</td>
<td>i, xref, houseNumber</td>
</tr>
<tr>
<td>자료형 인자</td>
<td>T, E, K, V, X, T1, T2</td>
</tr>
</tbody>
</table>
<ol start=2>
<li>문법에 관한 것</li>
</ol>
<p>철자 관습보다 가변적이고 논쟁 여지가 많다.</p>
<ul>
<li>패키지는 문법 관습 없음</li>
<li>클래스나 enum 은 단수형 명자나 명사구 붙는다 (Timer, BuffedWriter, ChessPiece)</li>
<li>인터페이스도 클래스와 비슷하며 able이나 ible 같은 형용사격 어미가 붙기도 한다 (Collection, Comparator, Runnable, Iterable, Accessible)</li>
<li>어노테이션은 쓰임새가 너무 다양해 지배적인 규칙이 없다. 명사, 동사, 전치사, 형용사 다 쓰인다 (BindingAnnotation, Inject, ImplementedBy, Singleton)</li>
<li>어떤 동작을 수행하는 메서드는 동사나 동사구를 이름으로 한다(append, add)</li>
<li>boolean 값을 반환하는 method는 보통 is, 가끔 has 로 시작한다 (isDigit, isEmpty, hasSiblings)</li>
<li>boolean 이외의 속성을 반환하는 메서드는 보통 명사나 명사구, get으로 시작한다 (size, hashCode, getTime)</li>
<li>bean 클래스에 속한 메서드이름은 반드시 get으로 시작해야 한다. 속성을 설정하는 건 set으로 시작해야 한다.</li>
<li>객체의 자료형을 변환하는 메서드, 다른 자료형의 <code>독립적 객체</code>를 반환하는 메서드는 보통 toType 형태를 붙인다 (toString, toArray)</li>
<li>인자로 전달받은 객체와 다른 자료형의 <code>View 객체</code>를 반환하는 메서드는 asType 형태의 이름을 붙인다 (asList)</li>
<li>호출 객체와 동일한 기본 자료형 값을 반환하는 경우 typeValue 로 붙인다 (intValue)</li>
<li>정적 팩토리 메서드는 valueOf, of, getInstance, newInstance, getType, newType 등을 붙인다</li>
<li>필드는 특별한 관습 없고 별로 중요하지 않다 (잘 설계된 API는 외부로 필드를 거의 공개 안하기 때문)</li>
<li>boolean field는 메서드와 같은 이름을 붙이거나 is를 생략한다 (initialized, composite)</li>
<li>다른 필드는 보통 명사나 명사구를 쓴다 (height, digits, bodyStyle)</li>
<li>지역 변수는 더 중요하지 않다.</li>
</ul>
<h3 id=요약-3>
요약
<a class=anchor href=#%ec%9a%94%ec%95%bd-3>#</a>
</h3>
<ul>
<li>표준 작명 관습을 내면화 시켜서 제2의 천성인 것 처럼 사용하자</li>
<li>철자 관습은 직관적이며 모호한 부분이 없다</li>
<li>문법 관습은 좀 더 복잡하고 느슨하다</li>
</ul>
</article>
<footer class=book-footer>
<div class="flex flex-wrap justify-between">
</div>
<script>(function(){function a(c){const a=window.getSelection(),b=document.createRange();b.selectNodeContents(c),a.removeAllRanges(),a.addRange(b)}document.querySelectorAll("pre code").forEach(b=>{b.addEventListener("click",function(c){a(b.parentElement),navigator.clipboard&&navigator.clipboard.writeText(b.parentElement.textContent)})})})()</script>
</footer>
<div class=book-comments>
</div>
<label for=menu-control class="hidden book-menu-overlay"></label>
</div>
<aside class=book-toc>
<div class=book-toc-content>
<nav id=TableOfContents>
<ul>
<li><a href=#규칙-53-리플렉션-대신-인터페이스를-이용하라>규칙 53 리플렉션 대신 인터페이스를 이용하라</a>
<ul>
<li><a href=#일반적인-프로그램은-프로그램-실행-중-리플렉션을-통해-객체를-이용하려-하면-안-된다>일반적인 프로그램은 프로그램 실행 중 리플렉션을 통해 객체를 이용하려 하면 안 된다</a></li>
<li><a href=#리플렉션을-아주-제한적으로-사용하면-오버헤드는-피하면서-리플렉션의-장점을-누릴-수-있다>리플렉션을 아주 제한적으로 사용하면 오버헤드는 피하면서 리플렉션의 장점을 누릴 수 있다.</a></li>
<li><a href=#요약>요약</a></li>
</ul>
</li>
<li><a href=#규칙-54-네이티브-메서드는-신중히-사용하라>규칙 54 네이티브 메서드는 신중히 사용하라</a>
<ul>
<li><a href=#네이티브-메서드를-통해-성능을-개선하는-것을-추천-안함>네이티브 메서드를 통해 성능을 개선하는 것을 추천 안함</a></li>
<li><a href=#요약-1>요약</a></li>
</ul>
</li>
<li><a href=#규칙-55-신중하게-최적화하라>규칙 55 신중하게 최적화하라</a>
<ul>
<li><a href=#중간-요약>중간 요약</a></li>
<li><a href=#요약-2>요약</a></li>
</ul>
</li>
<li><a href=#규칙-56-일반적으로-통용되는-작명-관습을-따르라>규칙 56 일반적으로 통용되는 작명 관습을 따르라</a>
<ul>
<li><a href=#요약-3>요약</a></li>
</ul>
</li>
</ul>
</nav>
</div>
</aside>
</main>
</body>
</html>