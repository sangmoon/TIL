<!doctype html><html lang=en dir=ltr>
<head>
<meta charset=utf-8>
<meta name=viewport content="width=device-width,initial-scale=1">
<meta name=description content="자바 잘 짜보자">
<meta name=theme-color content="#FFFFFF">
<meta name=color-scheme content="light dark"><meta property="og:title" content="Effective Java">
<meta property="og:description" content="자바 잘 짜보자">
<meta property="og:type" content="article">
<meta property="og:url" content="https://sangmoon.github.io/TIL/effectivejava/methodscommontoallobjects/item13/"><meta property="article:section" content="EffectiveJava">
<meta property="article:published_time" content="2021-10-23T00:00:00+00:00">
<meta property="article:modified_time" content="2021-10-23T00:00:00+00:00">
<title>Effective Java | Sangmoon's TIL</title>
<link rel=manifest href=/TIL/manifest.json>
<link rel=icon href=/TIL/favicon.png type=image/x-icon>
<link rel=stylesheet href=/TIL/book.min.46181bc93375ba932026e753b37c40e6ff8bb16a9ef770c78bcc663e4577b1ba.css integrity="sha256-RhgbyTN1upMgJudTs3xA5v+LsWqe93DHi8xmPkV3sbo=" crossorigin=anonymous>
<script defer src=/TIL/flexsearch.min.js></script>
<script defer src=/TIL/en.search.min.58e317a58bdb983ff9fe64dbce44994883782a83ea5a5d5fbf080e12279c4e0f.js integrity="sha256-WOMXpYvbmD/5/mTbzkSZSIN4KoPqWl1fvwgOEiecTg8=" crossorigin=anonymous></script>
</head>
<body dir=ltr>
<input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control>
<main class="container flex">
<aside class=book-menu>
<div class=book-menu-content>
<nav>
<h2 class=book-brand>
<a class="flex align-center" href=/TIL/><span>Sangmoon's TIL</span>
</a>
</h2>
<div class=book-search>
<input type=text id=book-search-input placeholder=Search aria-label=Search maxlength=64 data-hotkeys=s/>
<div class="book-search-spinner hidden"></div>
<ul id=book-search-results></ul>
</div>
</nav>
<script>(function(){var a=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(b){localStorage.setItem("menu.scrollTop",a.scrollTop)}),a.scrollTop=localStorage.getItem("menu.scrollTop")})()</script>
</div>
</aside>
<div class=book-page>
<header class=book-header>
<div class="flex align-center justify-between">
<label for=menu-control>
<img src=/TIL/svg/menu.svg class=book-icon alt=Menu>
</label>
<strong>Effective Java</strong>
<label for=toc-control>
<img src=/TIL/svg/toc.svg class=book-icon alt="Table of Contents">
</label>
</div>
<aside class="hidden clearfix">
<nav id=TableOfContents>
<ul>
<li><a href=#item-13-override-clone-judiciusly>Item 13: Override clone judiciusly</a></li>
</ul>
</nav>
</aside>
</header>
<article class=markdown><h2 id=item-13-override-clone-judiciusly>
Item 13: Override clone judiciusly
<a class=anchor href=#item-13-override-clone-judiciusly>#</a>
</h2>
<p><code>Cloneable</code> 인터페이스는 복사를 허용하기 위해 만들어졌다. 하지만 <code>Object</code>의 clone method를 쓸 수 없기 때문에
목적 달성에 실패했다.</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Employee</span> <span style=color:#f92672>{</span>
 
  <span style=color:#66d9ef>private</span> String name<span style=color:#f92672>;</span>
 
  <span style=color:#66d9ef>public</span> <span style=color:#a6e22e>Employee</span><span style=color:#f92672>(</span>String name<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
   <span style=color:#66d9ef>this</span><span style=color:#f92672>.</span><span style=color:#a6e22e>name</span> <span style=color:#f92672>=</span> name<span style=color:#f92672>;</span>
  <span style=color:#f92672>}</span>
 
  <span style=color:#66d9ef>public</span> String <span style=color:#a6e22e>getName</span><span style=color:#f92672>()</span> <span style=color:#f92672>{</span>
   <span style=color:#66d9ef>return</span> name<span style=color:#f92672>;</span>
  <span style=color:#f92672>}</span>
    
  <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>main</span><span style=color:#f92672>(</span>String<span style=color:#f92672>[]</span> args<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
   Employee emp <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Employee<span style=color:#f92672>(</span><span style=color:#e6db74>&#34;Abhi&#34;</span><span style=color:#f92672>);</span>
   <span style=color:#66d9ef>try</span> <span style=color:#f92672>{</span>
       Employee emp2 <span style=color:#f92672>=</span> <span style=color:#f92672>(</span>Employee<span style=color:#f92672>)</span> emp<span style=color:#f92672>.</span><span style=color:#a6e22e>clone</span><span style=color:#f92672>();</span>
       System<span style=color:#f92672>.</span><span style=color:#a6e22e>out</span><span style=color:#f92672>.</span><span style=color:#a6e22e>println</span><span style=color:#f92672>(</span>emp2<span style=color:#f92672>.</span><span style=color:#a6e22e>getName</span><span style=color:#f92672>());</span>
   <span style=color:#f92672>}</span> <span style=color:#66d9ef>catch</span> <span style=color:#f92672>(</span>CloneNotSupportedException e<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
       e<span style=color:#f92672>.</span><span style=color:#a6e22e>printStackTrace</span><span style=color:#f92672>();</span>
   <span style=color:#f92672>}</span>
  <span style=color:#f92672>}</span>
<span style=color:#f92672>}</span>

<span style=color:#75715e>// return CloneNotSupportedException...
</span></code></pre></div><p>그럼 Cloneable 인터페이스는 무슨 역할을 할까? 그것은 Object의 clone 메소드의 동작을 정한다.
만약 한 클래스가 Cloneable을 구현했다면 Object.clone() 메소드는 field-by-field copy 객체 를 반환한다.
구현하지 않았다면 CloneNotSupportedException을 반환한다. 이건 매우 드문 인터페이스의 사용이다. 보통 인터페이스
구현은 클라이언트에게 그 클래스가 할수 있는 것을 말해준다. 이 경우 인터페이스는 부모클래스의 보호된 메소드 동작을 허용하게 한다.
실제 상황에서 Cloneable을 구현한 클래스는 적절한 public clone method를 반환해야 한다. 하지만 생성자를 호출하지 않고
객체를 생성하기 때문에 매우 위험하다.</p>
<p>clone 메소드에선 <code>super.clone()</code> 을 호출해야 한다. 꼭&mldr; 이걸 하지 않고 부모 클래스의 생성자를 호출하면 컴파일러는 문제를 일으키지 않지만 실제 JVM 동작에서 원치 않는 동작을 할 것이다. 예외적으로 Cloneable을 구현한 클래스가 final이면 sub클래스가 없기 때문에 이런 걱정을 할 필요가 없다. 하지만 super.clone() 을 호출하지 ㅇ낳으면 굳이 Cloneable을 구현할 필요가 없다, Object의 clone 구현에 의존할 필요가 없으니까!</p>
<p>잘 동작하는 clone 메소드를 제공하는 부모클래스를 가진 클래스에서 Cloneable을 구현한다고 생각해보자. 우선 <code>super.clone</code>을 호출하자. 반환되는 객체는 완벽한 replica 이다.
모든 필드를 primitive나 immutable 객체로 선언했다면 더 처리할 필요가 없다.</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#75715e>//Item 11의 PhoneNumber 예제
</span><span style=color:#75715e></span><span style=color:#a6e22e>@Override</span> <span style=color:#66d9ef>public</span> PhoneNumber <span style=color:#a6e22e>clone</span><span style=color:#f92672>()</span> <span style=color:#f92672>{</span>
    <span style=color:#66d9ef>try</span> <span style=color:#f92672>{</span>
        <span style=color:#66d9ef>return</span> <span style=color:#f92672>(</span>PhoneNumber<span style=color:#f92672>)</span> <span style=color:#66d9ef>super</span><span style=color:#f92672>.</span><span style=color:#a6e22e>clone</span><span style=color:#f92672>();</span>
    <span style=color:#f92672>}</span> <span style=color:#66d9ef>catch</span><span style=color:#f92672>(</span>CloneNotSupportedException e<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
        <span style=color:#66d9ef>throw</span> <span style=color:#66d9ef>new</span> AssertionError<span style=color:#f92672>();</span> <span style=color:#75715e>// Can&#39;t happen.. !
</span><span style=color:#75715e></span>    <span style=color:#f92672>}</span>
<span style=color:#f92672>}</span>
</code></pre></div><p>return 타입을 자기 자신 클래스로 하는게 바람직하다. 클라이언트의 불필요한 캐스팅도 막고 java에서 covariant return type을 지원하기 때문에!</p>
<p>만약 field에 mutable object 가 있으면 대재앙이 일어난다. 예를 들어 Item 7의 스택을 생각해보자
이 클래스를 cloneable 하게 만들기 위해 단순히 super.clone() 을 한다면 copy stack 객체는 size 필드는 같지만 elements field는 original 객체의 array와
같은 array를 바라보게 된다. 따라서 original을 변경하면 NPE가 발생할 가능성이 아주 많다.
결과적으로 clone 메소드는 생성자처럼 기능한다. 따라서 original 객체에 영향을 주지 않게 만들어야 한다.
위 예제에서 stack이 적절히 동작하게 만드려면 stack의 내부도 copy 해야 한다. 가장 쉬운 방법은 elements array도 copy 하는 것이다.</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java>Override <span style=color:#66d9ef>public</span> Stack <span style=color:#a6e22e>clone</span><span style=color:#f92672>()</span> <span style=color:#f92672>{</span>
    <span style=color:#66d9ef>try</span> <span style=color:#f92672>{</span>
        Stack stack <span style=color:#f92672>=</span> <span style=color:#f92672>(</span>Stack<span style=color:#f92672>)</span><span style=color:#66d9ef>super</span><span style=color:#f92672>.</span><span style=color:#a6e22e>clone</span><span style=color:#f92672>();</span>
        result<span style=color:#f92672>.</span><span style=color:#a6e22e>elements</span> <span style=color:#f92672>=</span> elements<span style=color:#f92672>.</span><span style=color:#a6e22e>clone</span><span style=color:#f92672>();</span>
        <span style=color:#66d9ef>return</span> result<span style=color:#f92672>;</span>
    <span style=color:#f92672>}</span> <span style=color:#66d9ef>catch</span> <span style=color:#f92672>(</span>CloneNotSupportedException e<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
        thorw <span style=color:#66d9ef>new</span> <span style=color:#a6e22e>AssertionError</span><span style=color:#f92672>();</span>
    <span style=color:#f92672>}</span>
<span style=color:#f92672>}</span>
</code></pre></div><p>근데 위의 예제는 stack.elements 가 final 필드면 불가능하다. 이건 근본적인 문제인데, serialization 처럼 mutable objects를 final 필드로 갖고 있는 형태와 사용할 수 없다.
cloneable 하려면 final을 없애야 한다.</p>
<p>단순 recursive copy 만으로는 부족할 수 있다. hashtable을 생각해보자</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>HashTable</span> <span style=color:#66d9ef>implements</span> Cloneable <span style=color:#f92672>{</span>
    <span style=color:#66d9ef>private</span> Entry<span style=color:#f92672>[]</span> buckets <span style=color:#f92672>=</span> <span style=color:#f92672>...;</span>

    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Entry</span> <span style=color:#f92672>{</span>
        <span style=color:#66d9ef>final</span> Object key<span style=color:#f92672>;</span>
        Object value<span style=color:#f92672>;</span>
        Entry next<span style=color:#f92672>;</span>

        Entry<span style=color:#f92672>(</span>Object key<span style=color:#f92672>,</span> Object value<span style=color:#f92672>,</span> Entry next<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
            <span style=color:#66d9ef>this</span><span style=color:#f92672>.</span><span style=color:#a6e22e>key</span> <span style=color:#f92672>=</span> key<span style=color:#f92672>;</span>
            <span style=color:#66d9ef>this</span><span style=color:#f92672>.</span><span style=color:#a6e22e>value</span> <span style=color:#f92672>=</span> value<span style=color:#f92672>;</span>
            <span style=color:#66d9ef>this</span><span style=color:#f92672>.</span><span style=color:#a6e22e>next</span> <span style=color:#f92672>=</span> next<span style=color:#f92672>;</span>
        <span style=color:#f92672>}</span>
    <span style=color:#f92672>}</span>
<span style=color:#f92672>}</span>
</code></pre></div><p>Stack에서 했던 것 처럼 buckets array를 recursive 하게 clone 해보자</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#a6e22e>@Override</span> <span style=color:#66d9ef>public</span> HashTable <span style=color:#a6e22e>clone</span><span style=color:#f92672>()</span> <span style=color:#f92672>{</span>
    <span style=color:#66d9ef>try</span> <span style=color:#f92672>{</span>
        HashTable result <span style=color:#f92672>=</span> <span style=color:#f92672>(</span>HashTable<span style=color:#f92672>)</span> <span style=color:#66d9ef>super</span><span style=color:#f92672>.</span><span style=color:#a6e22e>clone</span><span style=color:#f92672>();</span>
        result<span style=color:#f92672>.</span><span style=color:#a6e22e>buckets</span> <span style=color:#f92672>=</span> buckets<span style=color:#f92672>.</span><span style=color:#a6e22e>clone</span><span style=color:#f92672>();</span>
        <span style=color:#66d9ef>return</span> result<span style=color:#f92672>;</span>
    <span style=color:#f92672>}</span> <span style=color:#66d9ef>catch</span> <span style=color:#f92672>(</span>CloneNotSupportedException e<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
        thorw <span style=color:#66d9ef>new</span> <span style=color:#a6e22e>AssertionError</span><span style=color:#f92672>();</span>
    <span style=color:#f92672>}</span>
<span style=color:#f92672>}</span>
</code></pre></div><p>Copy hashtable은 자신만의 bucket 이 있지만 링크드리스트는 오리지날과 같다. 따라서 비정상동작 할 것이다.
이걸 고치기 위해선 각각 bucket 마다 링크드리스트도 copy 해야 한다.</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>HashTable</span> <span style=color:#66d9ef>implements</span> Cloneable <span style=color:#f92672>{</span>
    <span style=color:#75715e>///...
</span><span style=color:#75715e></span>
        <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Entry</span> <span style=color:#f92672>{</span>
        <span style=color:#66d9ef>final</span> Object key<span style=color:#f92672>;</span>
        Object value<span style=color:#f92672>;</span>
        Entry next<span style=color:#f92672>;</span>

        Entry<span style=color:#f92672>(</span>Object key<span style=color:#f92672>,</span> Object value<span style=color:#f92672>,</span> Entry next<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
            <span style=color:#66d9ef>this</span><span style=color:#f92672>.</span><span style=color:#a6e22e>key</span> <span style=color:#f92672>=</span> key<span style=color:#f92672>;</span>
            <span style=color:#66d9ef>this</span><span style=color:#f92672>.</span><span style=color:#a6e22e>value</span> <span style=color:#f92672>=</span> value<span style=color:#f92672>;</span>
            <span style=color:#66d9ef>this</span><span style=color:#f92672>.</span><span style=color:#a6e22e>next</span> <span style=color:#f92672>=</span> next<span style=color:#f92672>;</span>
        <span style=color:#f92672>}</span>

        Entry <span style=color:#a6e22e>deepCopy</span><span style=color:#f92672>()</span> <span style=color:#f92672>{</span>
            <span style=color:#75715e>// recursively copy the linked list
</span><span style=color:#75715e></span>            <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>new</span> Entry<span style=color:#f92672>(</span>key<span style=color:#f92672>,</span> value<span style=color:#f92672>,</span> next <span style=color:#f92672>==</span> <span style=color:#66d9ef>null</span><span style=color:#f92672>?</span> <span style=color:#66d9ef>null</span> <span style=color:#f92672>:</span> next<span style=color:#f92672>.</span><span style=color:#a6e22e>deepCopy</span><span style=color:#f92672>());</span>
        <span style=color:#f92672>}</span>
    <span style=color:#f92672>}</span>
    
    <span style=color:#a6e22e>@Override</span> <span style=color:#66d9ef>public</span> HashTable <span style=color:#a6e22e>clone</span><span style=color:#f92672>()</span> <span style=color:#f92672>{</span>
        <span style=color:#66d9ef>try</span> <span style=color:#f92672>{</span>
            HashTable result <span style=color:#f92672>=</span> <span style=color:#f92672>(</span>hashTable<span style=color:#f92672>)</span><span style=color:#66d9ef>super</span><span style=color:#f92672>.</span><span style=color:#a6e22e>clone</span><span style=color:#f92672>();</span>
            result<span style=color:#f92672>.</span><span style=color:#a6e22e>buckets</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Entry<span style=color:#f92672>[</span>buckets<span style=color:#f92672>.</span><span style=color:#a6e22e>length</span><span style=color:#f92672>];</span>
            <span style=color:#66d9ef>for</span> <span style=color:#f92672>(</span><span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> 0<span style=color:#f92672>;</span> i <span style=color:#f92672>&lt;</span> buckets<span style=color:#f92672>.</span><span style=color:#a6e22e>length</span><span style=color:#f92672>;</span> i<span style=color:#f92672>++)</span> <span style=color:#f92672>{</span>
                <span style=color:#66d9ef>if</span><span style=color:#f92672>(</span>buckets<span style=color:#f92672>[</span>i<span style=color:#f92672>]</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span><span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
                    results<span style=color:#f92672>[</span>i<span style=color:#f92672>]</span> <span style=color:#f92672>=</span> buckets<span style=color:#f92672>[</span>i<span style=color:#f92672>].</span><span style=color:#a6e22e>deepCopy</span><span style=color:#f92672>();</span>
                <span style=color:#f92672>}</span>
            <span style=color:#f92672>}</span>
            <span style=color:#66d9ef>return</span> result<span style=color:#f92672>;</span>
        <span style=color:#f92672>}</span> <span style=color:#66d9ef>catch</span> <span style=color:#f92672>(</span>CloneNotSupportedException e<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
        thorw <span style=color:#66d9ef>new</span> <span style=color:#a6e22e>AssertionError</span><span style=color:#f92672>();</span>
    <span style=color:#f92672>}</span>
<span style=color:#f92672>}</span>
</code></pre></div><p>잘 동작하는데, deepCopy가 recursive라서 stackoverFlow 가 발생할 수 있다. 이를 iteration으로 바꾸면&mldr;</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java>Entry <span style=color:#a6e22e>deepCopy</span><span style=color:#f92672>()</span> <span style=color:#f92672>{</span>
    Entry result <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Entry<span style=color:#f92672>(</span>key<span style=color:#f92672>,</span> vaule<span style=color:#f92672>,</span> next<span style=color:#f92672>);</span>
    <span style=color:#66d9ef>for</span> <span style=color:#f92672>(</span>Entry p <span style=color:#f92672>=</span> result<span style=color:#f92672>;</span> p<span style=color:#f92672>.</span><span style=color:#a6e22e>next</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span><span style=color:#f92672>;</span> p <span style=color:#f92672>=</span> p<span style=color:#f92672>.</span><span style=color:#a6e22e>next</span><span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
        p<span style=color:#f92672>.</span><span style=color:#a6e22e>next</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Entry<span style=color:#f92672>(</span>p<span style=color:#f92672>.</span><span style=color:#a6e22e>next</span><span style=color:#f92672>.</span><span style=color:#a6e22e>key</span><span style=color:#f92672>,</span> p<span style=color:#f92672>.</span><span style=color:#a6e22e>next</span><span style=color:#f92672>.</span><span style=color:#a6e22e>value</span><span style=color:#f92672>,</span> p<span style=color:#f92672>.</span><span style=color:#a6e22e>next</span><span style=color:#f92672>.</span><span style=color:#a6e22e>next</span><span style=color:#f92672>);</span>
    <span style=color:#f92672>}</span>
<span style=color:#f92672>}</span>
</code></pre></div><p>결국 복잡한 mutable 객체를 cloning 하는 최종 방법은 우선 super.clone을 불러서 필드를 초기화하고 original 객체의 state를 재생산하는 것이다.
따라서 HashTable 예제에서 클로닝이 제대로 된 후에 put 메소드가 불려서 복사된 객체에서 동작한다. 이 방식이 깔끔하긴 하지만 super.clone() 한 필드를
덮어써야 하기 때문에 느릴 수 있다.</p>
<p>생성자와 같이 clone 메소드 내에서는 override 가능한 메소드를 불려선 안된다. 이게 가능하게 되면 subclass가 제대로 필드 바꾸기 전에 original을 오염시킬 수 있다.
따라서 put(key, value) 는 final 이거나 private 여야 한다.</p>
<p>public clone 메소드는 <code>CloneNotSupportedException</code>을 throw 해서는 안된다, check exception 을 사용하지 않는게 쓰기 편하기 때문에.</p>
<p>상속을 위한 클래스를 설계할 때에는 Cloneable을 implements 해서는 안된다. 만약 clone을 구현한다면
Object의 clone 메소드 처럼 CloneNotSupportedException을 throw 하는 protected 메소드로 구현해야 한다.
그래야 subclass 들은 마치 Object를 바로 상속받은 것 처럼 Cloneable을 구현할지 말지 자유를 얻을 수 있다.
반대로 clone 동작을 허용하지 않는 것을 택했다면 아예 막을 수 있다.</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#a6e22e>@Override</span>
<span style=color:#66d9ef>public</span> <span style=color:#66d9ef>final</span> Object <span style=color:#a6e22e>clone</span><span style=color:#f92672>()</span> <span style=color:#66d9ef>throws</span> CloneNotSuportedException <span style=color:#f92672>{</span>
    <span style=color:#66d9ef>throw</span> <span style=color:#66d9ef>new</span> CloneNotSupportedException<span style=color:#f92672>();</span>
<span style=color:#f92672>}</span>
</code></pre></div><p>또 Objects의 clone() 메소드는 sync 하지 않기 때문에 병렬 프로그래밍을 한다면
synchronization을 고려해야 한다.</p>
<p>이런 복잡한 작업이 꼭 필요할까? 거의 아니다.copy 생성자나 copy factory를 구현하는게 더 좋은 방법이다.</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#75715e>// Copy constructor
</span><span style=color:#75715e></span><span style=color:#66d9ef>public</span> <span style=color:#a6e22e>Yum</span><span style=color:#f92672>(</span>Yum yum<span style=color:#f92672>){};</span>

<span style=color:#75715e>// Copy factory
</span><span style=color:#75715e></span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> Yum <span style=color:#a6e22e>newInstance</span><span style=color:#f92672>(</span>Yum yum<span style=color:#f92672>){};</span>
</code></pre></div><p>클론에 비해 위 방식들의 장점은 이상한 객체 생성을 하지 않아도 된다는 것이다.final field도 신경쓸 필요 없다.
불필요한 exception 던지지 않는다. casting도 필요 없다.
또한 자신이 속한 class의 인터페이스를 구현한 타입 클래스도 인자로 받을 수 있다.
예를 들어 TreeSet을 HashSet으로 바꾸려 한다면 clone은 지원하지 않지만, <code>new TreeSet(hashSet);</code> 으로 가능하다.</p>
<p>결론적으로 array 복사정도면 모를까 거의 쓰지 말자.. copy constructor 나 copy factory 쓰자</p>
</article>
<footer class=book-footer>
<div class="flex flex-wrap justify-between">
</div>
<script>(function(){function a(c){const a=window.getSelection(),b=document.createRange();b.selectNodeContents(c),a.removeAllRanges(),a.addRange(b)}document.querySelectorAll("pre code").forEach(b=>{b.addEventListener("click",function(c){a(b.parentElement),navigator.clipboard&&navigator.clipboard.writeText(b.parentElement.textContent)})})})()</script>
</footer>
<div class=book-comments>
</div>
<label for=menu-control class="hidden book-menu-overlay"></label>
</div>
<aside class=book-toc>
<div class=book-toc-content>
<nav id=TableOfContents>
<ul>
<li><a href=#item-13-override-clone-judiciusly>Item 13: Override clone judiciusly</a></li>
</ul>
</nav>
</div>
</aside>
</main>
</body>
</html>